<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BigDeal@blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/luwenchun/luwenchun.github.io/"/>
  <updated>2018-07-06T04:49:59.999Z</updated>
  <id>https://github.com/luwenchun/luwenchun.github.io/</id>
  
  <author>
    <name>卢文春</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端300ms点击延迟和点击穿透</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/07/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E7%82%B9%E5%87%BB%E5%BB%B6%E8%BF%9F%E5%92%8C%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/07/06/移动端300ms点击延迟和点击穿透/</id>
    <published>2018-07-06T04:35:49.087Z</published>
    <updated>2018-07-06T04:49:59.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动端300ms点击延迟由来："><a href="#移动端300ms点击延迟由来：" class="headerlink" title="移动端300ms点击延迟由来："></a>移动端300ms点击延迟由来：</h3><p>故事：2007 年初。苹果公司在发布首款 iPhone 前夕，遇到一个问题：当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。</p><p>这当中最出名的，当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。</p><p>双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。之前人们刚刚接触移动端的页面，在欣喜的时候往往不会care这个300ms的延时问题，可是如今touch端界面如雨后春笋，用户对体验的要求也更高，这300ms带来的卡顿慢慢变得让人难以接受。</p><p>也就是说，移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动。这些行为，尤其是双击缩放，主要是为桌面网站在移动端的浏览体验设计的。而在用户对页面进行操作的时候，移动端浏览器会优先判断用户是否要触发默认的行为。</p><p><strong>重点：由于移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，看用户有没有下一次点击，也就是这次操作是不是双击。</strong></p><h3 id="浏览器开发商的解决方案"><a href="#浏览器开发商的解决方案" class="headerlink" title="浏览器开发商的解决方案"></a>浏览器开发商的解决方案</h3><h4 id="方案一：禁用缩放"><a href="#方案一：禁用缩放" class="headerlink" title="方案一：禁用缩放"></a>方案一：禁用缩放</h4><p>当HTML文档头部包含如下meta标签时：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt;</code></pre><p>表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。</p><p><strong>缺点</strong>：就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。但是通常情况下，我们还是希望页面能通过双指缩放来进行缩放操作，比如放大一张图片，放大一段很小的文字。</p><h4 id="方案二：更改默认的视口宽度"><a href="#方案二：更改默认的视口宽度" class="headerlink" title="方案二：更改默认的视口宽度"></a>方案二：更改默认的视口宽度</h4><p>一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为设备宽度。</p><meta name="viewport" content="width=device-width"><p>因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。</p><p>这个方案相比方案一的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p><h4 id="方案三：CSS-touch-action"><a href="#方案三：CSS-touch-action" class="headerlink" title="方案三：CSS touch-action"></a>方案三：CSS touch-action</h4><p>touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。</p><h4 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h4><h5 id="FastClick"><a href="#FastClick" class="headerlink" title="FastClick"></a>FastClick</h5><p>FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。</p><pre><code>import FastClick from &apos;fastclick&apos;;(function(doc) {    if (&apos;addEventListener&apos; in doc) {    doc.addEventListener(&apos;DOMContentLoaded&apos;, function() {        FastClick.attach(doc.body);    }, false);    }})(document);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;移动端300ms点击延迟由来：&quot;&gt;&lt;a href=&quot;#移动端300ms点击延迟由来：&quot; class=&quot;headerlink&quot; title=&quot;移动端300ms点击延迟由来：&quot;&gt;&lt;/a&gt;移动端300ms点击延迟由来：&lt;/h3&gt;&lt;p&gt;故事：2007 年初。苹果公司在发布
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单实现VUE中的MVVM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0VUE%E4%B8%AD%E7%9A%84MVVM/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/简单实现VUE中的MVVM/</id>
    <published>2018-06-20T02:32:16.283Z</published>
    <updated>2018-04-21T06:31:36.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p>首先，我们需要了解一下 js 中的一个 API :<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty(obj, prop, descriptor)</a></p><p>一般情况下我们为一个对象添加一个属性一般都会这么写</p><pre><code>let object = {}object.test = &apos;test&apos;</code></pre><p>Object.defineProperty 也能做到同样的效果</p><pre><code>let object = {}, test = &apos;test&apos;Object.defineProperty(object, &apos;test&apos;, {    configurable: true,            // 描述该属性的描述符能否被改变，默认值为 false    enumerable: true,               // 能否被遍历，比如 for in，默认值为 false    get: function(){                // 取值的时候调用，object.test，默认值为 false        console.log(&apos;enter get&apos;)        return test    },    set: function(newValue){        // 设置值的时候使用        console.log(&apos;enter set&apos;)        test = newValue    }})</code></pre><p>这样写虽然代码量多了不少，但是却拥有了控制属性取值和设置值的权利，让我们来测试一下。</p><pre><code> object.test// enter get// testobject.test = &apos;test2&apos;// enter set// test2</code></pre><p>接着我们把 defindProperty 这个函数封装同时改造一下，方便我们调用</p><pre><code>let callback = {    target: null}let defineReactive = function(object, key, value){    let array = []    Object.defineProperty(object, key, {        configurable: true,        enumerable: true,        get: function(){            if(callback.target){                array.push(callback.target)            }            return value        },        set: function(newValue){            if(newValue != value){                array.forEach((fun)=&gt;fun(newValue, value))            }            value = newValue        }    })}</code></pre><p>可以从代码中看出来，我在函数内部声明了一个数组用于存放 <strong>callback</strong> 中的 <strong>target</strong>，当对 <strong>object</strong> 进行 <strong>get</strong> 操作(取值操作)的时候，就会往 <strong>callback</strong> 中存放函数，进行 <strong>set</strong> 操作(设置值)的时候执行数组中的函数。看看效果如何</p><pre><code>let object = {}defineReactive(object, &apos;test&apos;, &apos;test&apos;)callback.target = function(newValue, oldValue){console.log(&apos;我被添加进去了，新的值是：&apos; + newValue)}object.test// testcallback.target = nullobject.test = &apos;test2&apos;// 我被添加进去了，新的值是：test2callback.target = function(newValue, oldValue){console.log(&apos;添加第二个函数，新的值是：&apos; + newValue)}object.test// testcallback.target = nullobject.test = &apos;test3&apos;// 我被添加进去了，新的值是：test3// 添加第二个函数，新的值是：test3</code></pre><p>这样我们就达成了在 object.test 的值发生改变时，运行一个函数队列（虽然这个队列挺简陋的）的目的。</p><p>换个说法，当我们取值的时候，函数自动帮我们添加了针对当前值的依赖，当这个值发生变化的时候，处理了这些依赖，比如说 DOM 节点的变化。</p><p>这个也是 VUE 中实现 MVVM 的最核心的代码，当然在 VUE 中，这个依赖收集的过程远比现在的代码要复杂，这里仅仅实现了依赖的收集和触发，对于依赖的管理这里的代码还做不到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;defineProperty&quot;&gt;&lt;a href=&quot;#defineProperty&quot; class=&quot;headerlink&quot; title=&quot;defineProperty&quot;&gt;&lt;/a&gt;defineProperty&lt;/h2&gt;&lt;p&gt;首先，我们需要了解一下 js 中的一个 AP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM常见API</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/操作DOM常用API总结/</id>
    <published>2018-06-20T02:32:16.282Z</published>
    <updated>2018-04-17T15:46:42.098Z</updated>
    
    <content type="html"><![CDATA[<p>文本整理了javascript操作DOM的一些常用的api，根据其作用整理成为创建，修改，查询等多种类型的api，主要用于复习基础知识，加深对原生js的认识。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在讲解操作DOM的api之前，首先我们来复习一下一些基本概念，这些概念是掌握api的关键，必须理解它们。</p><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法。</p><p>Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型，具体如下：</p><pre><code>Node.ELEMENT_NODE:1Node.ATTRIBUTE_NODE:2Node.TEXT_NODE:3Node.CDATA_SECTION_NODE:4Node.ENTITY_REFERENCE_NODE:5Node.ENTITY_NODE:6Node.PROCESSING_INSTRUCTION_NODE:7Node.COMMENT_NODE:8Node.DOCUMENT_NODE:9Node.DOCUMENT_TYPE_NODE:10Node.DOCUMENT_FRAGMENT_NODE:11Node.NOTATION_NODE:12</code></pre><p>假设我们要判断一个Node是不是元素，我们可以这样判断</p><pre><code>if(someNode.nodeType == 1){console.log(&quot;Node is a element&quot;);}</code></pre><p>这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型。</p><p>我们简单来介绍一下这几种类型：</p><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性：</p><pre><code>（1）nodeType为1（2）nodeName为元素标签名，tagName也是返回标签名（3）nodeValue为null（4）parentNode可能是Document或Element（5）子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</code></pre><h3 id="Attribute类型"><a href="#Attribute类型" class="headerlink" title="Attribute类型"></a>Attribute类型</h3><p>Attribute类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性：</p><pre><code>（1）nodeType值为2（2）nodeName是特性的名称（3）nodeValue是特性的值（4）parentNode为null</code></pre><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性：</p><pre><code>（1）nodeType为3（2）nodeName为#text（3）nodeValue为文本内容（4）parentNode是一个Element（5）没有子节点</code></pre><h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>Comment表示HTML文档中的注释，它有下面的几种特征：</p><pre><code>（1）nodeType为8（2）nodeName为#comment（3）nodeValue为注释的内容（4）parentNode可能是Document或Element（5）没有子节点</code></pre><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。</p><p>Document有下面的特性：</p><pre><code>（1）nodeType为9（2）nodeName为#document（3）nodeValue为null（4）parentNode为null（5）子节点可能是一个DocumentType或Element</code></pre><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。</p><p>DocumentFragment有下面的特性：</p><pre><code>（1）nodeType为11（2）nodeName为#document-fragment（3）nodeValue为null（4）parentNode为null</code></pre><p>我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点，想要进一步学习的同学可以查找一下相关资料。</p><h3 id="节点创建型api"><a href="#节点创建型api" class="headerlink" title="节点创建型api"></a>节点创建型api</h3><p>在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。</p><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文本整理了javascript操作DOM的一些常用的api，根据其作用整理成为创建，修改，查询等多种类型的api，主要用于复习基础知识，加深对原生js的认识。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/性能优化方式/</id>
    <published>2018-06-20T02:32:16.280Z</published>
    <updated>2018-04-25T04:24:02.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从服务渲染过程谈性能优化"><a href="#从服务渲染过程谈性能优化" class="headerlink" title="从服务渲染过程谈性能优化"></a>从服务渲染过程谈性能优化</h1><p>本文将结合从在浏览器输入url，到展示最终页面的过程来对其进行一步步分析，并将在web 中的实际应用实践进行总结。</p><h3 id="模式-1-前后分离"><a href="#模式-1-前后分离" class="headerlink" title="模式 1 - 前后分离"></a>模式 1 - 前后分离</h3><p>从用户输入 url　到展示最终页面的过程，这种模式可简单的分为以下 5 部分</p><p>1、用户输入 url，开始拉取静态页面<br>2、静态页面加载完成后，解析文档标签，并开始拉取 CSS （一般 CSS 放于头部）<br>3、接着拉取 JS 文件（一般 JS 文件放于尾部）<br>4、当 JS 加载完成，便开始执行 JS 内容，发出请求并拿到数据<br>5、将数据与资源渲染到页面上，得到最终展示效果</p><p>具体流程图如下</p><p><img src="/../about/qg6ngypp8w.png" alt=""></p><p>这种处理形式应该占据大多数，然而也很容易发现一个问题就是<strong>请求数多，前后依赖大</strong>，如必须等待 JS 加载完成后执行时才会发起 数据请求，等待数据回来用户才可以展示最终页面，这种强依赖的关系使得整个应用的首屏渲染耗时增加不少。</p><h3 id="模式-2-数据直出"><a href="#模式-2-数据直出" class="headerlink" title="模式 2 - 数据直出"></a>模式 2 - 数据直出</h3><blockquote><p>数据请求在server端上提前获取，并和html一同返回，页面模板和数据的渲染在浏览器端上执行</p></blockquote><p>在模式 1 中，第 1 点用户输入 url 时 server 端不做其他处理直接返回 html ，在第 4 点向 server 请求获取数据。那么，同样都是向 server 请求获取，如果在第 1 点中将请求数据放在 server 上，将拿到的数据拼接到 HTML 上一并返回，那么可减少在前端页面上的一次数据请求时间。 这就是模式 2 - 数据直出所做的事，处理方式也很简单</p><p>1、用户输入 url ，在 server 返回 HTML 前去请求获取页面需要的数据<br>2、将数据拼接到 HTML 上 并 一起返回给前端（可以插入 script 标签将数据添加到全局变量上，或放到某个标签的 data 属性中，如 ）<br>3、在前端的JS代码中判断是否已在服务端拿到数据，直接拿该数据进行渲染页面，不再做数据请求</p><p>具体可下面的流程图看出这种模式下</p><p><img src="/../about/xingneng2.png" alt=""></p><p>这种模式与模式1 相比，减少了这两种模式请求数据的耗时差距。这块差距有多少呢？</p><h4 id="发起一个-HTTP-的网络请求过程"><a href="#发起一个-HTTP-的网络请求过程" class="headerlink" title="发起一个 HTTP 的网络请求过程"></a>发起一个 HTTP 的网络请求过程</h4><pre><code>DNS解析（100~200ms可以缓存）        |        |        建立TCP链接 (三次握手100~200ms )                |                |            HTTP Request( 半个RTT )                 |                |            HTTP Response( RTT 不确定优化空间 )</code></pre><p>注: RTT 为 Round-trip time 缩写，表示一个数据包从发出到返回所用的时间。</p><h4 id="HTTP-请求在前后端发出，差距有多少？"><a href="#HTTP-请求在前后端发出，差距有多少？" class="headerlink" title="HTTP 请求在前后端发出，差距有多少？"></a>HTTP 请求在前后端发出，差距有多少？</h4><p>由上面对 HTTP 的网络请求过程可看到建立一次完整的请求返回在耗时上明显的，特别是外网用户在进行 HTTP 请求时，由于网络等因素的影响，在网络连接及传输上将花费很多时间。而在服务端进行数据拉取，即使同样是 HTTP 请求，由于后端之间是处于同一个内网上的，所以传输十分高效，这是差距来源的大头，是优化的刚需。</p><h3 id="模式-3-直出-服务端渲染"><a href="#模式-3-直出-服务端渲染" class="headerlink" title="模式 3 - 直出 (服务端渲染)"></a>模式 3 - 直出 (服务端渲染)</h3><blockquote><p>数据请求在server端上提前获取，页面模板结合数据的渲染处理也在server上完成，输出最终 HTML</p></blockquote><p>模式 2 中将依赖于JS文件加载回来才能去发起的数据请求挪到 server 中，数据随着 HTML 一并返回。然后等待 JS 文件加载完成，JS 将服务端已给到的数据与HTML结合处理，生成最终的页面文档。</p><p>数据请求能放到 server 上，对于数据与HTML结合处理也可以在server上做，从而减少等待 JS 文件的加载时间。 这就是模式3 - 直出 (服务端渲染)，主要处理如下</p><p>1、server 上获取数据并将数据与页面模板结合，在服务端渲染成最终的 HTML<br>2、返回最终的 HTML 展示</p><p>可以从下图看出，页面的首屏展示不再需要等待 JS 文件回来，优化减少了这块时间</p><p><img src="/../about/1c5f64bc-29a7-11e6-800a-bd8b4af30b0f.png" alt=""></p><p>通过以上模式，将模式 1 - 常用模式中的第 3 和 4 点耗时进行了优化，那么可以再继续优化吗？在页面文档不大情况下，可将CSS内联到HTML中，这是优化请求量的做法。直出稍微不同的是需要考虑的是服务端最终渲染出来的文档的大小，在范围内也可将 CSS 文件内联到 HTML 中。这样的话，便优化了 CSS 的获取时间，如下图</p><p><img src="/../about/2b09bc10-29a7-11e6-8fa9-6dc12579b1aa.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>直出能够将常用模式优化到剩下了一次 HTML 请求，加快首屏渲染时间，使用服务端渲染，还能够优化前端渲染难以克服的 SEO 问题。而不管是简单的 数据直出 或是 服务端渲染直出 都能使页面的性能优化得到较大提高，以下将从实际应用中进行说明。</p><h1 id="从输入URL过程谈性能优化"><a href="#从输入URL过程谈性能优化" class="headerlink" title="从输入URL过程谈性能优化"></a>从输入URL过程谈性能优化</h1><pre><code>  1、用户输入网址（假设是个 HTML 页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回 HTML 文件； （善用缓存，减少HTTP请求，减轻服务器压力） 2. 浏览器载入 HTML 代码，发现 &lt;head&gt; 内有一个 &lt;link&gt; 引用外部 CSS 文件,则浏览器立即发送CSS文件请求，获取浏览器返回的CSS文件；  （CSS文件合并，减少HTTP请求） 3. 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； （CSS文件需要放置最上面，避免网页重新渲染） 4. 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； （图片文件合并，减少HTTP请求） 5. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；（最好图片都设置尺寸，避免重新渲染） 6. 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，会立即运行该js代码；（script最好放置页面最下面）                    7. js脚本执行了语句，它令浏览器隐藏掉代码中的某个 &lt;div&gt;,突然就少了一个元素，浏览器不得不重新渲染这部分代码； （页面初始化样式不要使用js控制）    8. 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面…… 9. 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 &lt;link&gt; 标签的 CSS 路径；10. 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</code></pre><h1 id="从渲染DOM树过程谈性能优化"><a href="#从渲染DOM树过程谈性能优化" class="headerlink" title="从渲染DOM树过程谈性能优化"></a>从渲染DOM树过程谈性能优化</h1><p><strong>reflow(回流)</strong></p><p> 说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染， 该过程称为reflow（回流）。</p><p>  reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p><p><strong>repaint(重绘)</strong></p><p>如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow（在IE下需要换一下说法，reflow 要比 repaint 更缓慢）。尽量避免reflow(回流)  ，reflow(回流)是导致DOM脚本执行低效的关键因素之一。页面上任何一个结点触发reflow，都会导致它的子结点及祖先结点重新渲染。</p><blockquote><p>在哪些情况下会导致reflow发生：</p></blockquote><pre><code> 改变窗囗大小 改变文字大小 添加/删除样式表内容的改变，如用户在输入框中敲字激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活)操作class属性脚本操作DOM计算offsetWidth和offsetHeight设置style属性性</code></pre><p> 那么为了减少回流要注意哪些方式呢？      </p><p>1.不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸</p><p>2.尽量通过class来设计元素样式，切忌用style</p><pre><code>var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; //  再一次的 reflow 和 repaintbstyle.color = &quot;blue&quot;; // repaintbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint// new DOM element - reflow, repaintdocument.body.appendChild(document.createTextNode(&apos;dude!&apos;));</code></pre><p>对上面代码优化：</p><pre><code>.b-class{　　padding:20px;　　color:blue;　　border:10px solid red;　　background-color:#fad;　　font-size:2em;}$div.addClass(&quot;b-class&quot;);</code></pre><p>3.实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute</p><p>4.权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。</p><p>5.不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，</p><p>6.这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p><p>7.css里不要有表达式expression</p><p>8.减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</p><p>9.避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</p><p>10.尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。</p><pre><code>在div.first里面加入div.second,在div.second里面加入div.third:        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $(div.first).append($divS));//reflow        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);//reflow优化代码：        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);        $(div.first).append($divS));//reflow或者：        var $divF = $(div.first);        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $divS.hide();        $(div.first).append($divS));        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);        $divS.show();//reflow  </code></pre><p>11.请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。</p><p>如果我们要经常去获取和操作这些值，则可以先将这些值缓存起来例如：</p><pre><code>var windowHeight = window.innerHeight;//reflowfor(i=0;i&lt;10;i++){     $body.height(windowHeight++);   　一系列关于windowHeight的操作....... }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从服务渲染过程谈性能优化&quot;&gt;&lt;a href=&quot;#从服务渲染过程谈性能优化&quot; class=&quot;headerlink&quot; title=&quot;从服务渲染过程谈性能优化&quot;&gt;&lt;/a&gt;从服务渲染过程谈性能优化&lt;/h1&gt;&lt;p&gt;本文将结合从在浏览器输入url，到展示最终页面的过程来对其进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>引用类型</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/引用类型/</id>
    <published>2018-06-20T02:32:16.279Z</published>
    <updated>2018-04-17T14:39:59.834Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>ECMAScript</code> 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类。有时候也被成为<strong>对象定义</strong>，因为他们描述的是一类对象所具有的属性和方法。<br>如前所述，对象是某个特定引用类型的实例。</p><h2 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h2><ul><li>一般来说，访问对象属性有点表示法和方括号两种方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">'name'</span>]) <span class="comment">//'James'</span></span><br><span class="line">alert(person.name)    <span class="comment">//'James'</span></span><br></pre></td></tr></table></figure><p>这两种方式访问对象属性没有任何区别，但方括号可以通过<strong>变量</strong>访问属性；如果属性明中国年包含空格等可能导致语法错误的字符，或者属性名使用的是<strong>关键字或保留字</strong>，也可以使用方括号正确表达。</p><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><ul><li>数组的 length 属性并不是只读的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>]</span><br><span class="line">color.length = <span class="number">4</span></span><br><span class="line">alert(color[<span class="number">3</span>]) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><ul><li>利用 length 属性可以方便的添加末尾项。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color[color.length] = <span class="string">'black'</span></span><br></pre></td></tr></table></figure><ul><li>当设置超过数组长度的数组项时候，数组长度会被重新计算，空的数组项变成了<code>undefined</code>.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color[<span class="number">99</span>] = <span class="string">'brown'</span></span><br><span class="line">alert(color.length)  <span class="comment">//100</span></span><br></pre></td></tr></table></figure><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray()</span><br></pre></td></tr></table></figure><ul><li><code>instanceof</code> 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，实际就存在两个以上不同的全局执行环境，从而存在两个以上的不同版本的 <code>Array</code> 构造函数。</li></ul><h3 id="栈方法和队列方法"><a href="#栈方法和队列方法" class="headerlink" title="栈方法和队列方法"></a>栈方法和队列方法</h3><ul><li><code>push()</code>方法可以接受<strong>任意数量</strong>的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。</li><li><code>pop()</code>方法则从数组末尾移走最后一项，减少数组 length，同时返回移除的项。</li><li><code>shift()</code>方法移除数组中的第一项并返回移除的数组项。</li><li><code>unshift()</code>方法则从数组的前端添加<strong>任意多项</strong>，返回数组长度。</li><li>由此可见：<code>push() unshift()</code>可以接受多项参数，<strong>返回的是数组长度 length</strong>；<code>pop() shift()</code>不接受参数，但是<strong>返回了一个添加项或者返回项</strong>。</li><li><code>shift() push()</code>方法可以模拟队列的方式使用数组，后进前出。</li><li><code>unshift() pop()</code>可以从相反方向模拟队列方法，前进后出。</li></ul><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul><li><code>reverse()</code>反转数组。</li><li><code>sort()</code>默认情况下按升序排列，同时会调用数组项的<code>toString()</code>方法，即使数组中都是数字，<strong>比较的也是字符串</strong>，所以常常出现10在5前这种情况。因此默认方法通常不用。</li></ul><p>以上两种返回的都是排序后的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v2-v1</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>].sort(compare)  <span class="comment">//返回的数组即可按升序排列</span></span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul><li><code>concat()</code>方法没有参数时只会返回复制的数组，有了参数后会返回添加参数后的数组。</li><li><code>slice()</code> 方法接受两个参数，起始位置和结束位置。第二个参数可不传。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>,<span class="string">'black'</span>,<span class="string">'brown'</span>]</span><br><span class="line"><span class="keyword">var</span> color2 = color.slice(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">alert(color2)   <span class="comment">//['blue','green','black']注意这个地方切到了4前</span></span><br></pre></td></tr></table></figure><ul><li><code>splice()</code>方法主要用来向数组中部插入项，一般是三种方式:</li><li>删除 : <code>splice(0，2)</code>要删除的位置和项数。</li><li>插入 :<code>splice(2,0,&#39;red&#39;,&#39;brown&#39;)</code>在位置2，插入两项。</li><li>替换 : <code>splice(2,1,&#39;red&#39;,&#39;brown&#39;)</code>在位置2删除一项，并插入两项。</li></ul><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><ul><li><code>indexOf()和 lastIndexOf()</code> 接受两个参数：要查找的项和起始位置(可选)。</li><li>只不过一个是从正向开始查找，另一个是从数组末尾开始，但是他们返回的<strong>都是找到的项的位置</strong>。</li></ul><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul><li><code>every()和 some()</code>返回的是布尔值，表示是否满足某个条件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> everyResult = color.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125; </span><br><span class="line">alert(everyResult) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><code>filter()</code>返回的是符合条件判断的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterResult = color.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">&#125; </span><br><span class="line">alert(filterResult) <span class="comment">//[3,5,4,6]</span></span><br></pre></td></tr></table></figure><ul><li><code>map()</code>方法返回一个对数组的对应项进行操作后的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapResult = color.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item * <span class="number">2</span>)</span><br><span class="line">&#125; </span><br><span class="line">alert(mapResult) <span class="comment">//[2,4,6,8,10]</span></span><br></pre></td></tr></table></figure><ul><li><code>forEach()</code>直接对数组进行操作，类似 for 循环。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//进行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul><li><code>reduce() 和reduceRight()</code> 迭代所有项，返回一个最终值。一个正向迭代，一个从数组末尾向前开始。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceResult = color.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,next,index,array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + next</span><br><span class="line">&#125; </span><br><span class="line">alert(reduceResult) <span class="comment">// 所有项想加的结果：15</span></span><br></pre></td></tr></table></figure><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul><li>函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。</li><li>函数声明和函数表达式是有区别的，解析器在代码执行之前，函数声明已经提升，而<strong>函数表达式只有执行到它所在的代码行，才会真正解释执行</strong>。</li></ul><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><ul><li>函数内部有两个特殊的对象<code>arguments 和 this</code>。</li><li><code>arguments</code>主要用来保存函数参数，还有一个<code>callee</code>属性，是一个指针，只想拥有这个 <code>arguments</code> 对象的函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * factorial(num <span class="number">-1</span>)</span><br><span class="line">&#125;    <span class="comment">//阶乘函数经典形式   问题在于过度紧密耦合了 factorial 函数名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num <span class="number">-1</span>)</span><br><span class="line">&#125; <span class="comment">//使用自身函数指针  arguments.callee 替代了函数名，解耦</span></span><br></pre></td></tr></table></figure><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><ul><li>每个函数都有两个属性：<code>length 和 prototype</code>。其中 length 表示函数接受的参数个数，就引用类型而言，<strong>prototype 是保存他们所有实例方法的真正所在</strong>。例如<code>toString()和 valueOf()</code>等方法实际都保存在 prototype 中，只不过是通过各自对象的实例访问罢了。</li><li>每个实例都包含两个非继承的方法<code>apply()和 call()</code>，实际上等于设置函数体内 this对象的值，真正强大的地方是能够扩充函数赖以运行的作用域。<code>call()</code>是分开接受参数，<code>apply()</code>是接受数组形式的参数。</li><li>使用 <code>apply()和 call()</code>来扩充作用域的最大好处就是，对象不需要与方法有任何耦合关系。此外<code>bind()</code>也是如此。</li></ul><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><h3 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h3><ul><li><code>encodeURI()</code>方法不会对本身属于 URI 的特殊字符进行编码，<code>：/ ? #</code>不会转义，会对空格转义。</li><li><code>encodeURIComponent()</code>会对所有非标字符转义。</li><li><strong>一般来说，<code>encodeURIComponent()</code>方法更常用，因为常见的是对查询字符串参数而不是对基础 URI 进行编码</strong>。</li><li><code>decodeURIComponent()和decodeURI()</code> 是对应的对上述两种方法解码的方法，<strong>注意是分别对应，不可交换。</strong></li><li><code>escape()</code>方法已废弃，实践中使用上述方法即可。</li></ul><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">16</span>)   <span class="comment">//只能对分别的数字参数使用</span></span><br><span class="line">alert(Max)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values)</span><br><span class="line"><span class="comment">//这种方式即可对数组进行求最大值的正确姿势</span></span><br></pre></td></tr></table></figure><ul><li><code>random()</code>方法</li></ul><p>套用下面公式，即可从某个整数范围内随机选择一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">值 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * 可能值的总数 + 第一个可能的值)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从2到10之间选一个整数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">9</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectNum</span>(<span class="params">lowerVal, upperVal</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> choiceVal = upperVal - lowerVal + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choiceVal + lowerVal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = selectNum(<span class="number">2</span>, <span class="number">10</span>)    <span class="comment">// 2到10之间选择一个整数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;ECMAScript&lt;/code&gt; 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类。有时候也被成为&lt;strong&gt;对象定义&lt;/strong&gt;，因为他们描述的是一类对象所具有的属性和方法。&lt;br&gt;如前所述，对象是某个特定引用类型的实例。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>标签样式重置</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%BD%AE/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/常用标签样式重置/</id>
    <published>2018-06-20T02:32:16.278Z</published>
    <updated>2018-04-19T01:34:08.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="美化input框"><a href="#美化input框" class="headerlink" title="美化input框"></a>美化input框</h3><pre><code>/*在IE10+浏览器中, 使用css即可隐藏input文本输入框右侧的叉号*/input[type=text]::-ms-clear,::-ms-reveal{display:none;}input::-ms-clear,::-ms-reveal{display:none;}input{    /*去除点击出现轮廓颜色*/    outline: none;    -webkit-appearance: none; /*去除系统默认的样式，苹果手机上的阴影*/    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /*点击高亮的颜色*/    /*padding已在重置样式中去除，如果没有去除，记得有padding哦*/    }</code></pre><h3 id="美化textarea文本域"><a href="#美化textarea文本域" class="headerlink" title="美化textarea文本域"></a>美化textarea文本域</h3><pre><code>textarea{    /*别忘了文本域的box-sizing属性值是border-box;所有的边框和padding都是在你固定的宽高的基础上绘制*/    /*去除点击出现轮廓颜色*/    outline: none;        /*如果有需要，去掉右下角的可拉伸变大小的图标和功能*/    resize: none;    /*padding已在重置样式中去除，如果没有去除，记得有padding哦*/}</code></pre><h3 id="改变placeholder的字体颜色大小"><a href="#改变placeholder的字体颜色大小" class="headerlink" title="改变placeholder的字体颜色大小"></a>改变placeholder的字体颜色大小</h3><pre><code>input::-webkit-input-placeholder {     /* WebKit browsers */     font-size:14px;    color: #333;} input:-moz-placeholder {     /* Mozilla Firefox 4 to 18 */     font-size:14px;    color: #333;} input::-moz-placeholder {     /* Mozilla Firefox 19+ */     font-size:14px;    color: #333;} input:-ms-input-placeholder {     /* Internet Explorer 10+ */     font-size:14px;    color: #333;}</code></pre><h3 id="美化select"><a href="#美化select" class="headerlink" title="美化select"></a>美化select</h3><pre><code>/*清除ie的默认选择框样式清除，隐藏下拉箭头*/select::-ms-expand { display: none; }select {/*Chrome和Firefox里面的边框是不一样的，所以复写了一下*/border: solid 1px #333;/*将默认的select选择框样式清除*/appearance:none;-moz-appearance:none;-webkit-appearance:none;/*在选择框的最右侧中间显示小箭头图片*/background: url(&quot;小箭头图片路径&quot;) no-repeat right center transparent;/*为下拉小箭头留出一点位置，避免被文字覆盖*/padding-right: 14px;/*去除点击出现轮廓颜色*/outline: none;}</code></pre><h3 id="美化button按钮"><a href="#美化button按钮" class="headerlink" title="美化button按钮"></a>美化button按钮</h3><pre><code>button{    /*本身有2px的边框，一般的button都不需要边框*/    border: none;    /*本身有的背景色，可以用其他颜色取代*/    background: #333;    /*padding已在重置样式中去除，如果没有去除，记得有padding哦*/}</code></pre><h3 id="css中设置table中的td内容自动换行，边框线合并为一条"><a href="#css中设置table中的td内容自动换行，边框线合并为一条" class="headerlink" title="css中设置table中的td内容自动换行，边框线合并为一条"></a>css中设置table中的td内容自动换行，边框线合并为一条</h3><pre><code>1. 把表格的sytle的table-layout: fixed;(就是表格固定宽度，就是表格既要自适应他外面的容器，也不要撑出去)2. 然后设置td的word-wrap: break-word;3. table边框线合并为一条：border-collapse: collapse;</code></pre><h3 id="浏览器滚动条样式重置"><a href="#浏览器滚动条样式重置" class="headerlink" title="浏览器滚动条样式重置"></a>浏览器滚动条样式重置</h3><pre><code>::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #bcbcbc;    height: 50px;    outline-offset: -2px;    outline: 1px solid #fff;    -webkit-border-radius: 4px;    border: 1px solid #fff;}body::-webkit-scrollbar-thumb {    background: hsla(0,0%,60%,.2)}body:hover::-webkit-scrollbar-thumb {    background: #999}::-webkit-scrollbar-track-piece {    background-color: transparent;    -webkit-border-radius: 0;}</code></pre><h3 id="清楚浮动"><a href="#清楚浮动" class="headerlink" title="清楚浮动"></a>清楚浮动</h3><pre><code>.clear {  clear: both;}.clearfix:after {  content: &apos;&apos;;  display: table;  clear: both;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;美化input框&quot;&gt;&lt;a href=&quot;#美化input框&quot; class=&quot;headerlink&quot; title=&quot;美化input框&quot;&gt;&lt;/a&gt;美化input框&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/*在IE10+浏览器中, 使用css即可隐藏input文本输入框右侧的叉号
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Vue2.0实现后台系统权限控制</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E5%9F%BA%E4%BA%8EVue2.0%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/基于Vue2.0实现后台系统权限控制/</id>
    <published>2018-06-20T02:32:16.277Z</published>
    <updated>2018-04-28T03:26:38.170Z</updated>
    
    <content type="html"><![CDATA[<p>项目背景:现有一个后台管理系统，共存在两种类型的人员</p><p>①超级管理员（称作admin），②普通用户（称作editor）</p><p>每种类型的人看到的操作栏并不一样，可以进行的操作也不尽相同，于是就需要程序处理一下各个权限问题。</p><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><p>1 创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</p><p>2 当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</p><p>3 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</p><p>4 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p><p><strong>在路由router.js里面声明权限为admin的路由(异步挂载的路由asyncRouterMap)</strong></p><pre><code>// router.jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)export const constantRouterMap = [{    path: &apos;/&apos;,    redirect: &apos;/login&apos;,    hidden: true},{    path: &apos;/login&apos;,    name: &apos;登录页面&apos;,    hidden: true,    component: resolve =&gt; require([&apos;../views/login/Login.vue&apos;], resolve)},{    path: &apos;/Readme&apos;,    // name: &apos;Readmehome&apos;,    index: &apos;Readme&apos;,    meta: {    title: &apos;Readme&apos;,    icon: &apos;el-icon-menu&apos;    },    component: resolve =&gt; require([&apos;../components/common/Home.vue&apos;], resolve),    children: [    {        name: &apos;Readme&apos;,        path: &apos;/&apos;,        meta: { title: &apos;Readme&apos;, icon: &apos;el-icon-menu&apos; },        component: resolve =&gt; require([&apos;../components/page/Readme.vue&apos;], resolve)    }    ]}]export default new Router({routes: constantRouterMap})// 异步挂载的路由// 动态需要根据权限加载的路由表export const asyncRouterMap = [{    path: &apos;/permission&apos;,    // name: &apos;permissionhome&apos;,    meta: {    title: &apos;permission&apos;,    icon: &apos;el-icon-setting&apos;,    roles: [&apos;admin&apos;]    },    component: resolve =&gt; require([&apos;../components/common/Home.vue&apos;], resolve),    children: [    {        name: &apos;permission&apos;,        path: &apos;/permission&apos;,        meta: {        title: &apos;permission&apos;, icon: &apos;el-icon-menu&apos;, roles: [&apos;admin&apos;]        },        component: resolve =&gt; require([&apos;../components/page/permission.vue&apos;], resolve)    }    ]},{ path: &apos;*&apos;, redirect: &apos;/404&apos;, hidden: true }]</code></pre><p>这里我们根据 <a href="https://router.vuejs.org/en/advanced/meta.html" target="_blank" rel="noopener">vue-router官方推荐</a> 的方法通过meta标签来标示改页面能访问的权限有哪些。如meta: { role: [‘admin’,’super_editor’] }表示该页面只有admin和超级编辑才能有资格进入。</p><p>注意事项：这里有一个需要非常注意的地方就是 404 页面一定要最后加载，如果放在constantRouterMap一同声明了404，后面的所以页面都会被拦截到404，详细的问题见<a href="https://github.com/vuejs/vue-router/issues/1176">addRoutes when you’ve got a wildcard route for 404s does not work</a></p><p><strong>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由，生成最终用户可访问的路由表。路由表存在vuex里面</strong></p><p><strong>permission.js</strong></p><pre><code>// permission.jsimport router from &apos;./router&apos;import store from &apos;./store&apos;import { Message } from &apos;element-ui&apos;import { getToken } from &apos;@/utils/auth&apos; // 验权const whiteList = [&apos;/login&apos;, &apos;/authredirect&apos;] // 不重定向白名单router.beforeEach((to, from, next) =&gt; {if (getToken()) { // 判断是否有token    if (to.path === &apos;/login&apos;) {    next({ path: &apos;/&apos; })    } else {    if (store.getters.roles.length === 0) {        console.log(&apos;roles====0&apos;)        store.dispatch(&apos;GetInfo&apos;).then(res =&gt; { // 拉取用户信息        const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;]        console.log(&apos;roles?&apos;, roles)        store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表            console.log(&apos;addrouters&apos;, store.getters.addRouters)            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record        })        }).catch(() =&gt; {        store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; {            Message.error(&apos;验证失败,请重新登录&apos;)            next({ path: &apos;/login&apos; })        })        })    } else {        console.log(&apos;====1&apos;)        next() // 当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面    }    }} else {    if (whiteList.indexOf(to.path) !== -1) {    next()    } else {    next(&apos;/login&apos;)    }}})</code></pre><p><strong>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件（菜单）。</strong></p><p><img src="/../about/vuex.png" alt="copy"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目背景:现有一个后台管理系统，共存在两种类型的人员&lt;/p&gt;
&lt;p&gt;①超级管理员（称作admin），②普通用户（称作editor）&lt;/p&gt;
&lt;p&gt;每种类型的人看到的操作栏并不一样，可以进行的操作也不尽相同，于是就需要程序处理一下各个权限问题。&lt;/p&gt;
&lt;h3 id=&quot;具体实
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于gulp的前端脚手架</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E5%9F%BA%E4%BA%8Egulp%E7%9A%84%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/基于gulp的前端脚手架/</id>
    <published>2018-06-20T02:32:16.276Z</published>
    <updated>2018-03-27T08:22:48.158Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到gulp和webpack各种脚手架，这次来入门下这二种脚手架。</p><h2 id="Gulp快速入门"><a href="#Gulp快速入门" class="headerlink" title="Gulp快速入门"></a>Gulp快速入门</h2><p>首先确保本地已安装node.js和npm<br>然后通过npm全局安装gulp</p><pre><code>$ npm install -g gulp   </code></pre><p>根据不同项目的要求，可选择适合的gulp插件进行后续开发。如果项目的要求基本相似（如小型的活动运营H5，平台页面等）可建立自己的脚手架工具以便于后续快速开发。</p><h3 id="搭建脚手架"><a href="#搭建脚手架" class="headerlink" title="搭建脚手架"></a>搭建脚手架</h3><p>1、首先在项目根目录下通过命令行安装项目依赖</p><pre><code>$ npm install --save-dev gulp</code></pre><p>2、在项目根目录下新建文件gulpfile.js。要想完成相关插件的配置，首先需要了解gulp相关方法</p><pre><code>gulp只有五个方法： task run watch src desttask 这个API用来创建任务，在命令行下可以输入 gulp test 来执行test的任务。run 这个API用来运行任务watch 这个API用来监听任务。src 这个API设置需要处理的文件的路径，可以是多个文件以数组的形式[main.scss,vender.scss]，也可以是正则表达式/*/ .scss。 dest 这个API设置生成文件的路径，一个任务可以有多个生成路径，一个可以输出未压缩的版本，另一个可以输出压缩后的版本。其实整个gulp的配置文件，基本上都是在做一些任务的配置，比如创建任务，监听任务等等。</code></pre><h3 id="基于脚手架进行开发"><a href="#基于脚手架进行开发" class="headerlink" title="基于脚手架进行开发"></a>基于脚手架进行开发</h3><p>1、拷贝package.json和gulpfile.js到相印项目根目录下，使用以下命令安装各插件</p><pre><code>$ npm install</code></pre><p>2、在根目录下键入相印命令进行所需的操作，如</p><pre><code>$ gulp</code></pre><h3 id="基本设定"><a href="#基本设定" class="headerlink" title="基本设定"></a>基本设定</h3><p>先大致地梳理一遍我们想要的功能和一些前提的设定。</p><p>1、脚手架自动化工具基于Gulp</p><p>2、基本的Task</p><pre><code>初始化目录结构初始化Index文件结构（迭代时可考虑基于Mobile OR PC）Sass自动编译CSS AutoPrefixer监听文件，自动刷新合并雪碧图</code></pre><h3 id="编写自己的Gulpfile-js"><a href="#编写自己的Gulpfile-js" class="headerlink" title="编写自己的Gulpfile.js"></a>编写自己的Gulpfile.js</h3><p>有了上面的基本约束后，现在建立自己的gulpfile文件，这里会详细记录每一个task的配置和使用。</p><p>首先把package.json和gulpfile.js建立起来</p><p>使用 npm init 初始化package.json（可一直按回车，或填写一些基本信息）。使用 npm install –save-dev gulp 使用gulp作为项目依赖</p><p>安装所需插件以及gulpfile.js的task配置</p><h4 id="初始化目录与文件"><a href="#初始化目录与文件" class="headerlink" title="初始化目录与文件"></a>初始化目录与文件</h4><p>首先需要初始化目录结构，这里使用fs-extra</p><p>使用以下命令进行安装 （后续的插件安装不再赘述，大家可从npmjs处查找相印的安装以及Api）</p><pre><code>npm install --save fs-extra</code></pre><p>先看一眼我们需要生成的目录结构</p><pre><code>├── dist # 编译后的文件    ├── html        └── index.html # home    ├── css    ├── js    └── img├── src     ├── img    ├── sprite    ├── pics    ├── js    └── sass        └── style.scss├── psd</code></pre><p>写入gulpfile.js</p><pre><code>var gulp = require(&apos;gulp&apos;);// 引入组件var path   = require(&apos;path&apos;), // node自带组件    fse    = require(&apos;fs-extra&apos;); // 通过npm下载// 获取当前文件路径var PWD = process.env.PWD || process.cwd(); // 兼容windowsgulp.task(&apos;init&apos;, function() {    var dirs = [&apos;dist&apos;,&apos;dist/html&apos;,&apos;dist/css&apos;,&apos;dist/img&apos;,&apos;dist/js&apos;,&apos;src&apos;,&apos;src/sass&apos;,&apos;src/js&apos;,&apos;src/img&apos;,&apos;src/pic&apos;,&apos;src/sprite&apos;,&apos;psd&apos;];    dirs.forEach(function (item,index) {        // 使用mkdirSync方法新建文件夹        fse.mkdirSync(path.join(PWD + &apos;/&apos;+ item));    })    // 往index里写入的基本内容    var template = &apos;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;/&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;;    fse.writeFileSync(path.join(PWD + &apos;/dist/html/index.html&apos;), template);    fse.writeFileSync(path.join(PWD + &apos;/src/sass/style.scss&apos;), &apos;@charset &quot;utf-8&quot;;&apos;);})</code></pre><p>此时运行$ gulp init发现目录已经生成完成了。再对index.html里的内容用编辑器的插件格式化一下，进入下一步。</p><h3 id="编译-sass以及为某些属性添加适当的前缀"><a href="#编译-sass以及为某些属性添加适当的前缀" class="headerlink" title="编译.sass以及为某些属性添加适当的前缀"></a>编译.sass以及为某些属性添加适当的前缀</h3><p>添加对sass编译的支持 安装插件gulp-sass。在gulpfile写入</p><pre><code>// 编译sassvar sass = require(&apos;gulp-sass&apos;);gulp.task(&apos;sass&apos;, function () {return gulp    // 在src/sass目录下匹配所有的.scss文件    .src(&apos;src/sass/**/*.scss&apos;)    // 基于一些配置项 运行sass()命令    .pipe(sass({        errLogToConsole: true,        outputStyle: &apos;expanded&apos;    }).on(&apos;error&apos;, sass.logError))    // 输出css    .pipe(gulp.dest(&apos;dist/css&apos;));});</code></pre><p>这时候在命令行敲入$ gulp sass发现已经跑起来了，但是存在两个问题</p><pre><code>每次修改完sass文件后都需要输入命令若sass有书写错误会直接退出gulp监听</code></pre><p>这两个问题我们放到最后再一起解决。</p><p>下面来为我们写的css的某些不兼容属性添加前缀。这里用到了插件gulp-autoprefixer，看一眼代码。其实都大同小异，大致的内容可在npmjs内查找到。</p><pre><code>var autoprefix = require(&apos;gulp-autoprefixer&apos;);gulp.task(&apos;autoprefixer&apos;, function () {return gulp.src(&apos;dist/css/**/*.css&apos;)    .pipe(autoprefixer({        browsers: [&apos;ios 5&apos;,&apos;android 2.3&apos;],        cascade: false    }))    .pipe(gulp.dest(&apos;dist/css&apos;));});</code></pre><p>下面测试一下，在scss写入一个css3属性</p><pre><code>perspective: 500;</code></pre><p>输入命令 $ gulp autoprefixer 发现文件没有更改。原因是sass文件还未被编译，这时候需要先敲一遍$ gulp sass编译。这时会发现css已经被添加了相印的后缀了</p><p><img src="/../about/1.png" alt="1111"></p><h4 id="开启服务器以及监听编译"><a href="#开启服务器以及监听编译" class="headerlink" title="开启服务器以及监听编译"></a>开启服务器以及监听编译</h4><p>终于到配置的最后一步了，我们的想法是当sass、js、html有所更改时都执行相印的命令。<br>如 自动压缩、合并文件、添加前缀、刷新浏览器</p><p>这里选用browser-sync同时我想当sass、sprite等文件改变时自动执行所需的task，使用watch命令对文件进行监听。话不多说，还是看源码。</p><pre><code>//=======================//     服务器 + 监听//=======================var browserSync = require(&apos;browser-sync&apos;).create();gulp.task(&apos;default&apos;, function() {    // 监听重载文件    var files = [    &apos;dist/html/**/*.html&apos;,    &apos;dist/css/**/*.css&apos;,    &apos;src/js/**/*.js&apos;,    &apos;src/sprite/**/*.png&apos;    ]    browserSync.init(files, {    server: {            baseDir: &quot;./&quot;,            directory: true        },    open: &apos;external&apos;,    startPath: &quot;dist/html/&quot;    });    // 监听编译文件    gulp.watch(&quot;dist/html/**/*.html&quot;).on(&apos;change&apos;, browserSync.reload);    gulp.watch(&quot;src/sass/**/*.scss&quot;, [&apos;sass&apos;]);    gulp.watch(&quot;src/sprite/**/*.png&quot;, [&apos;sprite&apos;]);    gulp.watch(&quot;dist/css/**/*.css&quot;, [&apos;autoprefixer&apos;]);});</code></pre><p>在命令行输入 $ gulp 这时我们的项目已经妥妥地跑起来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到gulp和webpack各种脚手架，这次来入门下这二种脚手架。&lt;/p&gt;
&lt;h2 id=&quot;Gulp快速入门&quot;&gt;&lt;a href=&quot;#Gulp快速入门&quot; class=&quot;headerlink&quot; title=&quot;Gulp快速入门&quot;&gt;&lt;/a&gt;Gulp快速入门&lt;/h2&gt;&lt;p&gt;首先确
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端自动化构建环境的搭建</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/前端自动化环境构建/</id>
    <published>2018-06-20T02:32:16.275Z</published>
    <updated>2018-04-17T14:37:21.757Z</updated>
    
    <content type="html"><![CDATA[<p>Web前端使用工程化方式构建；</p><p>   目前需要一些简单的功能：</p><pre><code>1. 版本控制6. 编译SASS2. 检查JS3. 图片合并4. 压缩CSS5. 压缩JS</code></pre><p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p><p>目前最知名的构建工具： Gulp、Grunt、NPM + Webpack；</p><pre><code>grunt是前端工程化的先驱gulp更自然基于流的方式连接任务Webpack最年轻，擅长用于依赖管理，配置稍较复杂推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件</code></pre><h3 id="Use-Gulp-to-automate-front-end-build-tasks"><a href="#Use-Gulp-to-automate-front-end-build-tasks" class="headerlink" title="Use Gulp to automate front-end build tasks"></a>Use Gulp to automate front-end build tasks</h3><p>Gulp是基于 Node.js的，需要要安装 Node.js</p><p>1、为了确保依赖环境正确，我们先执行几个简单的命令检查。</p><pre><code>node -vNode是一个基于Chrome JavaScript V8引擎建立的一个解释器检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号</code></pre><p>2、接下来看看npm，它是 node 的包管理工具，可以利用它安装 gulp 所需的包</p><pre><code>npm -v这同样能得到npm的版本号，装 Node 时已经自动安装了npm</code></pre><p>3、开始安装Gulp</p><pre><code>npm install -g gulp全局安装 gulpgulp -v得到gulp的版本号，确认安装成功</code></pre><p>基础安装结束<br>-</p><p>4、切换到你的在项目根文件夹下，运行</p><pre><code>npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下</code></pre><p>5、安装gulp功能插件依赖包</p><pre><code>npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev</code></pre><blockquote><p>gulp功能模块的文件会放在项目所在的目录的./node_modules 下</p></blockquote><p>6、我们目前先使用一些简单的功能：</p><pre><code>- 检查Javascript- 编译Sass文件- 合并Javascript- 压缩合并并重命名Javascript</code></pre><blockquote><p>新建gulpfile.js 配置文件放在项目根目录下</p></blockquote><pre><code>演示项目目录结构   testProject        (项目名称)   |–.git             通过git进行版本控制,项目自动生成这个文件   |–node_modules     组件包目录   |–dist             **发布环境**（编译自动生成的）       |–css         样式文件(style.css style.min.css)       |–images     图片文件(压缩图片\合并后的图片)       |–js         js文件(main.js main.min.js)       |–index.html  静态页面文件(压缩html)   |–src             **开发环境**       |–sass                sass文件       |–images               图片文件       |–js                  js文件       |–index.html         静态文件   |–gulpfile.js              gulp配置文件   |–package.json             依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序</code></pre><blockquote><p>现在，项目文件夹都建好，组件也安装完毕了，我们需要编写gulpfile.js文件以指定gulp需要为我们完成什么任务。</p></blockquote><pre><code>gulpfile.js内容如下：// 引入gulpvar gulp = require(&apos;gulp&apos;);// 引入组件var jshint = require(&apos;gulp-jshint&apos;);//检查jsvar sass   = require(&apos;gulp-sass&apos;);    //编译Sassvar concat = require(&apos;gulp-concat&apos;);//合并var uglify = require(&apos;gulp-uglify&apos;);//uglify 组件（用于压缩 JS）var rename = require(&apos;gulp-rename&apos;);//重命名// 检查js脚本的任务gulp.task(&apos;lint&apos;, function() {    gulp.src(&apos;./js/*.js&apos;) //可配置你需要检查脚本的具体名字。        .pipe(jshint())        .pipe(jshint.reporter(&apos;default&apos;));});// 编译Sassgulp.task(&apos;sass&apos;, function() {    gulp.src(&apos;./scss/*.scss&apos;)        .pipe(sass())        .pipe(gulp.dest(&apos;./css&apos;));//dest()写入文件});// 合并，压缩js文件// 找到 js/ 目录下的所有 js 文件，压缩，重命名，最后将处理完成的js存放在 dist/js/ 目录下gulp.task(&apos;scripts&apos;, function() {    gulp.src(&apos;./js/*.js&apos;)        .pipe(concat(&apos;all.js&apos;))        .pipe(gulp.dest(&apos;./dist&apos;))        .pipe(rename(&apos;all.min.js&apos;))        .pipe(uglify())        .pipe(gulp.dest(&apos;./dist&apos;));        console.log(&apos;gulp task is done&apos;);//自定义提醒信息});.... // 其他任务类似// 定义默认任务,执行gulp会自动执行的任务gulp.task(&apos;default&apos;, function(){    gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;);    // 监听js文件变化，当文件发生变化后会自动执行任务    gulp.watch(&apos;./js/*.js&apos;, function(){        gulp.run(&apos;lint&apos;,&apos;scripts&apos;);    });});</code></pre><p>7、现在，回到命令行窗口，可以直接运行gulp任务了。</p><pre><code>gulp这将执行定义的default任务，就和以下的命令式同一个意思gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务：gulp sass</code></pre><p>8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心</p><pre><code>常见提醒：1.禁止在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre><p>9、gulp的插件数量很多，后面还可以根据自己的需要进行添加任务</p><pre><code>常用的gulp插件参考gulp-imagemin:         压缩图片gulp-ruby-sass:     支持sass，安装此版本需要安装rubygulp-minify-css:     压缩cssgulp-jshint:          检查jsgulp-uglify:          压缩jsgulp-concat:        合并文件gulp-rename:          重命名文件gulp-htmlmin:         压缩htmlgulp-clean:          清空文件夹gulp-livereload:     服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr）</code></pre><p>补充：ZSmart UED Team 的前端开发软件环境 (Windows, Linux, Mac OS X)</p><pre><code>安装Node.Js、NPM、Ruby、Java 基础环境Sublime Text3 + 插件           用于编写前端代码Google chrome 、Mozilla Firefox + FirebugInternet Explorer             进行兼容测试和预览页面UI、动画效果和交互功能Node.js+Gulp                 进行前端自动化构建、JS语法验证、CSS压缩，图片压缩等；Koala                         实时编译Less、Sass、Compass、CoffeeScript;Github                         存储自己的代码库 、git或SVN用于版本控制和团队Code ReviewTomcat、DedeAMPZ、MAMP      进行简单运行环境演示Photoshop CC 切图 + Sprites 合并小图标XMind                         画出清晰的工作或业务逻辑思维图</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web前端使用工程化方式构建；&lt;/p&gt;
&lt;p&gt;   目前需要一些简单的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 版本控制
6. 编译SASS
2. 检查JS
3. 图片合并
4. 压缩CSS
5. 压缩JS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些都是每个Web项目在构建、开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>伪类、伪元素使用说明</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E4%BC%AA%E7%B1%BB%E3%80%81%E4%BC%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/伪类、伪元素使用说明/</id>
    <published>2018-06-20T02:32:16.274Z</published>
    <updated>2018-04-17T15:44:54.446Z</updated>
    
    <content type="html"><![CDATA[<p>伪类、伪元素配合CSS3可以完成非常多有意思的效果，为方便个人开发时候的快速查阅，记录了以下常用到的一些伪类伪元素的简要中文说明；</p><p>简单区分：</p><pre><code>:Pseudo-classes        伪类:DOM在不同状态、不同位置下的特殊效果；::Pseudo-elements    伪元素：DOM按匹配规则伪造出的元素；</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul><li>伪类添加的内容元素或伪类效果通在DOM的源代码中是看不见的，需要借助开发者工具才能看见;</li><li>使用屏幕阅读器等设备无法访问和读取伪元素生成的内容。因此不应该使用伪元素来添加正文内容等重要信息到页面上展示，应确保主体内容的完整性。</li><li>伪类添加的元素也可以使用CSS样式进行控制,具体查看下面浏览器的兼容性；</li><li>content方式可以添加的图片、unicode、字符串；其中图片不能调整大小，要选择合适的图片;</li><li>伪元素是在DOM内容生成之后添加的，它将被堆积在DOM的父元素的顶上；</li><li>伪元素由双冒号和伪元素名称组成，为了兼容使用单冒号的伪类也有效；</li><li>伪类添加的内容和元素不能使用任何Javascript的事件处理程序；</li><li>js获取伪类的值：win.getComputedStyle(doc.querySelector(‘.element’), ‘:before’).getPropertyValue(‘color’)</li></ul><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><ul><li>具体浏览器兼容性可以使用 <a href="http://caniuse.com/#search=CSS3" target="_blank" rel="noopener">Can I Use</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN CSS Browser Support</a></li></ul><h4 id="常用伪元素、伪类列表"><a href="#常用伪元素、伪类列表" class="headerlink" title="常用伪元素、伪类列表"></a>常用伪元素、伪类列表</h4><pre><code>::after         在元素的内容之后::before          在元素的内容之前::first-line     元素的第一行::first-letter     元素的第一个字母::placeholder    占位符，用于input输入框之类的提醒::selection     被选取的元素，用于改变网页被选中部分的效果:active         当元素被点击的时:blank          空白的元素:checked          被选中的元素:default         默认被选中或默认会被提交的元素:dir()             匹配特定文字书写方向的元素:disabled        处于被禁止操作状态的元素:empty             没有任何内容的元素:enabled         处于可操作状态的元素:first             用于打印文档的第一页:first-child     父级元素下的第一个子元素:first-of-type     父级元素下的第一个同类子元素:focus             当元素成为焦点:fullscreen        当元素被HTML5 API调用RequestFullscreen方式全屏时:hover             当鼠标移动到链接元素上面时:in-range        当元素属性值处于其指定的范围内时    :indeterminate    当元素属性值处于不确定状态的:invalid        当元素属性值不是指定的type属性时:lang()          匹配有正确lang 属性值的元素，如 lang(zh-Hans):last-child        元素的最后一个子元素:last-of-type     元素的最后一个同类子元素:left            选择打印文档的左侧页:link             未被访问的链接元素:not()             否定选择器（不匹配条件则生效）:nth-child()     元素的一个或多个特定的子元素:nth-last-child() 元素的一个或多个特定的子元素，从该元素的最后一个子元素开始算；:nth-of-type()     选择指定的元素:nth-last-of-type()    选择指定的元素，从元素的最后一个开始计算:only-child        元素是它的父元素的唯一子元素:only-of-type     元素是它的父级元素的唯一一个相同类型的子元素:optional        未指定required属性的表单元素:out-of-range    超出规定值范围的元素:read-only        元素设置了 &apos;readonly&apos; 属性生效:read-write        元素没有 &quot;readonly&quot; 属性生效:required        设置了 &quot;required&quot; 属性的元素    :right            选择打印文档的左侧页:root             文档的根元素:scope            作用域的伪类，默认为HTML（案例 :scope #mammma {...}）:target         当前活动的元素（匹配页面URI中对应的目标元素）:valid             表示有效的元素:visited         已被访问过的元素 content        在元素之前或之后添加的内容。</code></pre><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/DOM/Using_fullscreen_mode" target="_blank" rel="noopener">Fullscreen API </a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:scope" target="_blank" rel="noopener">:scope</a></li></ul><h1 id="md文档格式"><a href="#md文档格式" class="headerlink" title="md文档格式"></a>md文档格式</h1><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>在文本中输入的换行会从最终生成的结果中删除，  浏览器会根据可用空间自动      换行。如果想强迫换行，可以在行尾插入至少两个空格。</p><pre><code>在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入至少两个空格。</code></pre><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p><em>强调</em> 或者 _强调_  (示例：斜体)<br><strong>加重强调</strong> 或者 <strong>加重强调</strong> (示例：粗体)<br><strong><em>特别强调</em></strong> 或者 <strong><em>特别强调</em></strong> (示例：粗斜体)</p><pre><code>*强调* 或者 _强调_  (示例：斜体)**加重强调** 或者 __加重强调__ (示例：粗体)***特别强调*** 或者 ___特别强调___ (示例：粗斜体)</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序(没有编号的)列表中的一项<ul><li>一个子项，要以一个制表符或者4个空格缩进</li></ul></li><li>无序列表中的另一个项</li></ul><ol><li>有序(排好序，有编号的)列表中的一项</li><li><p>有序列表中的另一个项</p><pre><code>* 无序(没有编号的)列表中的一项    * 一个子项，要以一个制表符或者4个空格缩进* 无序列表中的另一个项1. 有序(排好序，有编号的)列表中的一项2. 有序列表中的另一个项</code></pre></li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>这一整段的内容都会作为一个HTML的引用元素。引用元素是会自动优化排版的（reflowable，可回流）。你可以任意地将引用的内容包含进来，然后所有这些都会被解析成为单独一个引用元素。</p></blockquote><pre><code>&gt; 这一整段的内容都会作为一个HTML的引用元素。引用元素是会自动优化排版的（reflowable，可回流）。你可以任意地将引用的内容包含进来，然后所有这些都会被解析成为单独一个引用元素。</code></pre><blockquote><p>这是一个引用。这是第一行<br>这是第二行。</p><blockquote><p>这是一个嵌套的引用。这是第一行。<br>这是第二行</p></blockquote><p>外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(‘&gt;’)可以有可以没有。</p></blockquote><pre><code>&gt; 这是一个引用。这是第一行这是第二行。&gt;&gt; 这是一个嵌套的引用。这是第一行。这是第二行&gt; &gt; 外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(&apos;&gt;&apos;)可以有可以没有。</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="链接地址">链接文字</a></p><pre><code>[链接文字](链接地址)</code></pre><p>例子： <a href="http://zh.wikipedia.com/wiki/Markdown" target="_blank" rel="noopener">Markdown</a></p><pre><code>[链接文字](链接地址)例子： [Markdown](http://zh.wikipedia.com/wiki/Markdown)</code></pre><p><a href="链接地址" title="链接标题">链接文字</a></p><pre><code>[链接文字][链接引用标签]</code></pre><pre><code>[链接引用标签]: 链接地址 &quot;链接标题&quot;</code></pre><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>要生成水平分割线，可以在单独一行里输入3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分割线。</p><hr><hr><hr><hr><hr><pre><code>* * *********- - ----------------------------------------</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;伪类、伪元素配合CSS3可以完成非常多有意思的效果，为方便个人开发时候的快速查阅，记录了以下常用到的一些伪类伪元素的简要中文说明；&lt;/p&gt;
&lt;p&gt;简单区分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:Pseudo-classes        伪类:DOM在不同状态、不同位置下的特殊
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS事件</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/%E4%BA%8B%E4%BB%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/事件/</id>
    <published>2018-06-20T02:32:16.273Z</published>
    <updated>2018-04-17T14:38:20.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡和捕获阶段"><a href="#冒泡和捕获阶段" class="headerlink" title="冒泡和捕获阶段"></a>冒泡和捕获阶段</h2><p><img src="http://www.admin10000.com/UploadFiles/Document/201503/21/20150321132128500929.JPG" alt=""></p><ul><li>一图流解释：IE 事件流叫做事件冒泡，从元素逐级向上传递，所有现代浏览器支持事件冒泡。</li><li>事件捕获是网景团队提出，虽然规范要求应该从 document 对象开始，但浏览器基本都从 window 对象开始。特殊需求才会使用。</li></ul><h2 id="目标阶段"><a href="#目标阶段" class="headerlink" title="目标阶段"></a>目标阶段</h2><ul><li>需要注意的是，你以为点击蚊子，事件目标节点在div上，其实实际触发会在最深的节点，比如 p 或者 span 等子节点上。</li></ul><h2 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h2><ul><li><em>DOM2级事件</em>规定的事件流包括三个阶段：事件捕获，目标事件阶段和事件冒泡阶段。</li><li>规范要求：捕获阶段不触发目标元素事件，然后目标事件处理，再进行冒泡阶段。</li><li>然而多数浏览器在捕获阶段也实现了目标元素事件，导致有两次机会可以实现目标元素事件。IE9+。</li></ul><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><h3 id="HTML-内联属性（避免使用）"><a href="#HTML-内联属性（避免使用）" class="headerlink" title="HTML 内联属性（避免使用）"></a>HTML 内联属性（避免使用）</h3><ul><li>HTML 元素里面直接填写事件有关属性，属性值为 JavaScript 代码，即可在触发该事件的时候，执行属性值的内容。</li><li>onclick 属性表示触发 click，属性值的内容（JavaScript 代码）会在单击该 HTML 节点时执行。</li><li>显而易见，使用这种方法，JavaScript 代码与 HTML 代码耦合在了一起，不便于维护和开发。所以除非在必须使用的情况（例如统计链接点击数据）下，尽量避免使用这种方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">'alert('</span>hhh<span class="string">')'</span>&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOM-属性绑定"><a href="#DOM-属性绑定" class="headerlink" title="DOM 属性绑定"></a>DOM 属性绑定</h3><ul><li>也可以直接设置 DOM 属性来指定某个事件处理的函数。</li><li>上面代码就是监听 element 节点的 click 事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面代码中再次为 element 绑定一个回调函数，会覆盖掉之前回调函数的内容。</li><li>虽然也可以用一些方法实现多个绑定，但还是推荐标准事件监听函数。</li><li>这种方式添加的事件处理程序会在事件的冒泡阶段处理，同时 this 引用当前元素。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'ddd'</span>)</span><br><span class="line">&#125;<span class="comment">//属性绑定事件</span></span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="literal">null</span>   <span class="comment">//删除事件处理程序  HTML 绑定事件也可以这样解除</span></span><br></pre></td></tr></table></figure><h3 id="事件监听函数"><a href="#事件监听函数" class="headerlink" title="事件监听函数"></a>事件监听函数</h3><ul><li>addEventListener()和 removeEventListener()两个方法，所有 DOM 节点都包括这两个方法。</li><li>接受三个参数，事件名，处理函数，一个布尔值。</li></ul><table><thead><tr><th>布尔值</th><th>说明</th></tr></thead><tbody><tr><td>true</td><td>捕获阶段</td></tr><tr><td>false</td><td>冒泡阶段  常用</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListerner(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'ddd'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">btn.addEventListerner(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>) <span class="comment">//移除监听事件，注意必须是同一引用 handler</span></span><br></pre></td></tr></table></figure><ul><li>和上面的属性绑定事件相同，this 指向绑定的元素，false 是冒泡阶段触发，这也是最常用的，因为要兼容 IE。</li><li>最后移除事件监听只可以用 removeEventListener()方法，同时<strong>必须是同一引用函数，使用匿名函数，即使完全相同也是不可以的，因为并非同一引用</strong>。</li></ul><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li>在触发 DOM 上的某个事件时，会产生一个事件对象 event, 对象中包含这所有与事件相关的信息。</li><li>在事件处理程序内部，this 始终等于 currentTarget 的值，而 target 的值则只包含实际目标。如果直接属性绑定，this、currentTarget 和 target 指向目标，三者值相同。</li><li>如果事件处理程序存在于按钮的父节点，target 指向目标，currentTarget 和 this 指向父节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">alert(e.currentTarget === e.target)  <span class="comment">//true</span></span><br><span class="line">alert(e.target === <span class="keyword">this</span>)<span class="comment">//true 属性绑定，三者相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">alert(e.currentTarget === e.target) <span class="comment">//false</span></span><br><span class="line">alert(e.currentTarget === <span class="keyword">this</span>)  <span class="comment">//true this 指向 body</span></span><br><span class="line">alert(e.target === btn) <span class="comment">//true 点击 btn 按钮，target 属性指向 btn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在需要通过一个函数处理多个事件时，可以使用 e.type 属性，定义一个函数，处理多种事件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'click'</span> :</span><br><span class="line">alert(<span class="string">'clicked'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">e.target.style.color = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">e.target.style.color = <span class="string">'black'</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler</span><br><span class="line">btn.onmouseover = handler</span><br><span class="line">btn.onmouseout = handler</span><br></pre></td></tr></table></figure><ul><li>阻止默认行为可以用 e.preventDefault()方法；只有 cancelable 属性为 true 的事件，才可以用 preventDefault()阻止默认事件。</li><li>e.stopPropagation()方法用于取消进一步的事件捕获或冒泡。例如注册在 btn 上的事件处理程序立即调用 e.stopPropagation()方法，从而避免触发注册在 document.body 上的事件。防止出现两次或者重叠的情况。</li><li>事件对象的 e.eventPhase 属性，用于确定正位于事件流的那个阶段。</li></ul><table><thead><tr><th>e.evenetPhase属性值</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>捕获阶段</td></tr><tr><td>2</td><td>事件处理程序正处于目标对象上</td></tr><tr><td>3</td><td>冒泡阶段</td></tr><tr><td>0</td><td>none</td></tr></tbody></table><ul><li>只有事件处理程序执行期间，event 对象才会存在，一旦事件处理程序执行完成，event 对象就会销毁。</li></ul><p><strong>下面列出一些 event 对象的属性值。</strong></p><table><thead><tr><th>属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>e.type   <strong>string</strong></td><td style="text-align:center">事件的名称，比如’click’</td></tr><tr><td>e.target <strong>node</strong></td><td style="text-align:center">事件要触发的目标节点</td></tr><tr><td>e.bubbles <strong>boolean</strong></td><td style="text-align:center">表明该时间是否在冒泡阶段触发</td></tr><tr><td>e.preventDefault()</td><td style="text-align:center">禁止默认事件</td></tr><tr><td>e.stopPropagation()</td><td style="text-align:center">停止进一步冒泡或捕获阶段</td></tr><tr><td>e.eventPhase <strong>number</strong></td><td style="text-align:center">见上</td></tr><tr><td>e.pageX和 e.pageY <strong>number</strong></td><td style="text-align:center">表示触发事件时，鼠标相对于页面的坐标</td></tr><tr><td>e.isTrusted <strong>boolean</strong></td><td style="text-align:center">浏览器触发（用户真实操作触发），还是 js 代码触发。</td></tr></tbody></table><h2 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h2><p>在 js 中，添加到页面上的事件处理程序数量将直接关系到页面运行性能。</p><ul><li>每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</li><li>必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul><li>事件委托利用了事件冒泡的机制，例如 click 事件会一直冒泡到 document 层次，只要给整个页面设置一个监听，就不不必分开一一设置了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>)</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = e.target</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line"><span class="keyword">case</span> btn:</span><br><span class="line">alert(<span class="string">'btn is clicked!'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> li:</span><br><span class="line">alert(<span class="string">'li is clicked!'</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码把 div 中的 btn 和 li 元素没有分开监听，给父元素设置lisener 同时根据元素的 id 进行切换，这就是初步的事件代理。</p><ul><li>如果可行的话，给 document 对象设置一个事件处理程序，泳衣处理页面上的某种特定类型的事件。</li><li>优点是，document 对象很快就可以访问，无需等待 DOMContentLoaded 或者 load 事件，只要可单击的元素成现在页面上，立即就可以具备适当的功能。</li><li>在页面中设置事件处理程序所需的事件更少，只添加一个监听事件，DOM 引用更少，花的时间也少。</li><li>整个页面占用的内存少，能够提升整体性能。</li></ul><p>最合适采用事件委托技术的事件包括 click、mousedown、mouseup、keydown、keyup和 keypress。虽然 mouseover 和 mouseout 事件也冒泡，但要适当处理很不容易，需要经常计算元素的位置。</p><h3 id="移除监听事件"><a href="#移除监听事件" class="headerlink" title="移除监听事件"></a>移除监听事件</h3><ul><li>文档中移除带有事件监听的元素时，removeChild(), replaceChild()，innerHTML 这些方法，很可能监听事件无法被当做垃圾回收。</li><li>再有就是卸载页面的时候，如果没有清理干净监听事件，就可能会只留在内存中。最好的做法是在页面卸载前，通过 onunload 事件移除所有监听事件，事件代理在此极具优势，因为监听事件很少。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>  <span class="comment">//设置为 null  移除监听事件</span></span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul><li>自定义事件可以实现更灵活的开发，用好了有很多优势。与之相关的函数有 Event 构造函数，CustomEvent 和 dispatchEvent。</li><li>直接自定义事件，使用 Event 构造函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>) <span class="comment">//new 一个Event 事件</span></span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;&#125;, <span class="literal">false</span>) <span class="comment">//设置元素build监听事件</span></span><br><span class="line"></span><br><span class="line">div.dispatchEvent(<span class="string">'event'</span>) <span class="comment">//触发事件</span></span><br></pre></td></tr></table></figure><ul><li>CustomEvent 可以创建一个更高度自定义事件，还可以附带一些数据，具体用法如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(eventname, options)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    detail: &#123;<span class="comment">//detail 里存放一些初始化信息</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    bubbles: <span class="literal">true</span>,<span class="comment">//其他属性</span></span><br><span class="line">    cancelable: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.dispatchEvent(myEvent) <span class="comment">//手动触发事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结合起来使用即为：</span></span><br><span class="line">obj.addEventListener(<span class="string">'cat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'cat'</span>, options) <span class="comment">//自定义事件，options 为上述的那个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 jQuery 磨平兼容性，调用方法如下</span></span><br><span class="line">$(<span class="string">'#div'</span>).on(<span class="string">'cat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//绑定事件</span></span><br><span class="line">$(<span class="string">'#div'</span>).trigger(<span class="string">'cat'</span>) <span class="comment">//触发事件</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.admin10000.com/document/6089.html" target="_blank" rel="noopener">最详细的 js 事件</a> </p><p>JS 高程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡和捕获阶段&quot;&gt;&lt;a href=&quot;#冒泡和捕获阶段&quot; class=&quot;headerlink&quot; title=&quot;冒泡和捕获阶段&quot;&gt;&lt;/a&gt;冒泡和捕获阶段&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://www.admin10000.com/UploadFiles/Do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue项目实现记住密码到cookie功能</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%88%B0cookie%E5%8A%9F%E8%83%BD/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/vue项目实现记住密码到cookie功能/</id>
    <published>2018-06-20T02:32:16.272Z</published>
    <updated>2018-04-17T16:25:54.703Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/1/30/161462f165cc17dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="效果图"></p><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h3><p>1.记住密码勾选，点登陆时，将账号和密码保存到cookie，下次登陆自动显示到表单内 2.不勾选，点登陆时候则清空之前保存到cookie的值，下次登陆需要手动输入</p><blockquote><p>大体思路就是通过存/取/删cookie实现的；每次进入登录页，先去读取cookie，如果浏览器的cookie中有账号信息，就自动填充到登录框中，存cookie是在登录成功之后，判断当前用户是否勾选了记住密码，如果勾选了，则把账号信息存到cookie当中，效果图如上：</p></blockquote><p>html代码</p><pre><code>&lt;div class=&quot;ms-login&quot;&gt;        &lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;0px&quot; class=&quot;demo-ruleForm&quot;&gt;            &lt;el-form-item prop=&quot;username&quot;&gt;                &lt;el-input v-model=&quot;ruleForm.username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;password&quot;&gt;                &lt;el-input type=&quot;password&quot; placeholder=&quot;密码&quot; v-model=&quot;ruleForm.password&quot; @keyup.enter.native=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;!-- `checked` 为 true 或 false --&gt;            &lt;el-checkbox v-model=&quot;checked&quot;&gt;记住密码&lt;/el-checkbox&gt;            &lt;br&gt;            &lt;br&gt;            &lt;div class=&quot;login-btn&quot;&gt;                &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;登录&lt;/el-button&gt;            &lt;/div&gt;        &lt;/el-form&gt;&lt;/div&gt;</code></pre><p>js代码</p><pre><code>//页面加载调用获取cookie值    mounted() {        this.getCookie();    },    methods: {        submitForm(formName) {             const self = this;            //判断复选框是否被勾选 勾选则调用配置cookie方法            if (self.checked == true) {                console.log(&quot;checked == true&quot;);                //传入账号名，密码，和保存天数3个参数                self.setCookie(self.ruleForm.username, self.ruleForm.password, 7);            }else {              console.log(&quot;清空Cookie&quot;);              //清空Cookie              self.clearCookie();            }            //与后端请求代码，本功能不需要与后台交互所以省略            console.log(&quot;登陆成功&quot;);    });},//设置cookiesetCookie(c_name, c_pwd, exdays) {    var exdate = new Date(); //获取时间    exdate.setTime(exdate.getTime() + 24 * 60 * 60 * 1000 * exdays); //保存的天数    //字符串拼接cookie    window.document.cookie = &quot;userName&quot; + &quot;=&quot; + c_name + &quot;;path=/;expires=&quot; + exdate.toGMTString();    window.document.cookie = &quot;userPwd&quot; + &quot;=&quot; + c_pwd + &quot;;path=/;expires=&quot; + exdate.toGMTString();},//读取cookiegetCookie: function() {    if (document.cookie.length &gt; 0) {        var arr = document.cookie.split(&apos;; &apos;); //这里显示的格式需要切割一下自己可输出看下        for (var i = 0; i &lt; arr.length; i++) {            var arr2 = arr[i].split(&apos;=&apos;); //再次切割            //判断查找相对应的值            if (arr2[0] == &apos;userName&apos;) {                this.ruleForm.username = arr2[1]; //保存到保存数据的地方            } else if (arr2[0] == &apos;userPwd&apos;) {                this.ruleForm.password = arr2[1];            }        }    }},//清除cookieclearCookie: function() {    this.setCookie(&quot;&quot;, &quot;&quot;, -1); //修改2值都为空，天数为负1天就好了}</code></pre><blockquote><p>浏览器中的cookie信息如下图，注意这里cookie的expire/Max-Age过期时间，这个时间是格林尼治标准时间GMT，世界统一的时间，GMT+8小时就是北京时间。(这里不做加密功能)</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/1/30/161462f165b73ac8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ok"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/30/161462f165cc17dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue组件之间的数据传递及共享</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/vue组件之间的数据传递/</id>
    <published>2018-06-20T02:32:16.270Z</published>
    <updated>2018-04-21T06:05:45.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理项目中代码，在组件之间数据传递遇到了问题，所以做了这次总结，如有不对的地方，望指正。</p><h3 id="父组件如何将数据传到子组件中"><a href="#父组件如何将数据传到子组件中" class="headerlink" title="父组件如何将数据传到子组件中"></a>父组件如何将数据传到子组件中</h3><p>父组件可以通过Prop传递数据到子组件中。</p><p>这里需要注意的是：</p><pre><code>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。每次父组件更新时，子组件的所有 Prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</code></pre><p> 在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><p>1、Prop 作为初始值传入后，子组件想把它当作局部数据来用；</p><p>解决方法：定义一个局部变量，并用 prop 的值初始化它：</p><pre><code>props: [&apos;initialCounter&apos;],data: function () {return { counter: this.initialCounter }}    </code></pre><p>2、Prop 作为原始数据传入，由子组件处理成其它数据输出。</p><p>解决方法： 定义一个计算属性，处理 prop 的值并返回：</p><pre><code>props: [&apos;size&apos;],computed: {normalizedSize: function () {    return this.size.trim().toLowerCase()}}</code></pre><p>PS：上边的内容是vue文档里边有说的，我只是把自己在项目中遇到的问题抽出来了。</p><pre><code>// 父组件 index.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;child :lists=&quot;lists&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import child from &apos;./child.vue&apos;;    export default {        components: {            child        },        data() {            return {                lists: []            };        },        mounted() {            this.lists = [{                name: &apos;01&apos;,                content: &apos;hi,&apos;            }, {                name: &apos;02&apos;,                content: &apos;my name is Ellyliang&apos;            }];        }    };&lt;/script&gt;// 子组件 child.vue&lt;template&gt;    &lt;ul class=&quot;content&quot;&gt;    &lt;li v-for=&quot;(list, index) in getLists&quot; :key=&quot;index&quot; v-html=&quot;list.name + list.content&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&apos;lists&apos;],        data() {            return {                getLists: this.lists            };        },        mounted() {            this.getLists.push({                name: &apos;03&apos;,                content: &apos;不要在乎内容，我就是测试&apos;            });        }    };&lt;/script&gt;</code></pre><h3 id="子组件如何将数据传到父组件中"><a href="#子组件如何将数据传到父组件中" class="headerlink" title="子组件如何将数据传到父组件中"></a>子组件如何将数据传到父组件中</h3><p>子组件可通过vm.$emit将数据传递给父组件</p><p> <strong>vm.$emit是啥</strong></p><p>触发当前实例上的事件。附加参数都会传给监听器回调</p><pre><code>// 父组件 index.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;child :lists=&quot;lists&quot; @listenToChild=&quot;getChildMsg&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import child from &apos;./child.vue&apos;;    export default {        components: {            child        },        data() {            return {                lists: []            };        },        mounted() {            this.lists = [{                name: &apos;01&apos;,                content: &apos;hi,&apos;            }, {                name: &apos;02&apos;,                content: &apos;my name is Ellyliang&apos;            }];        },        methods: {            getChildMsg(val) {                alert(val);  // &apos;hello&apos;            }        }    };&lt;/script&gt;// 子组件 child.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;ul class=&quot;lists&quot;&gt;            &lt;li v-for=&quot;(list, index) in getLists&quot; :key=&quot;index&quot; v-html=&quot;list.name + list.content&quot;&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&apos;lists&apos;],        data() {            return {                getLists: this.lists            };        },        mounted() {            this.getLists.push({                name: &apos;03&apos;,                content: &apos;不要在乎内容，我就是测试&apos;            });            setTimeout(() =&gt; {                this.$emit(&apos;listenToChild&apos;, &apos;hello&apos;);            }, 15000);        }    };&lt;/script&gt;</code></pre><p>子组件给父组件传数据是不是也很方便。实现方法是就是在子组件中$emit数据，然后在父组件中通过事件@事件名接收值。</p><h3 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h3><p>事件巴士这种方法，不仅能处理父子组件传递，子父组件传递，还是处理平级组件之间的数值传递。其实现方法就是在全局new一个vue实例，然后传值给bus, 就是let bus = new vue();。通过这个全局的bus中的$emit, $on等等去实现数据的传递。这样处理有个问题，由于event bus处理数据传递很方便，不管在哪里都可以传递，这样导致滥用，从而导致代码很难去理解。</p><p> Event Bus实现</p><pre><code>let bus = new Vue();// 触发组件 A 中的事件bus.$emit(&apos;id-selected&apos;, 1);// 在组件 B 创建的钩子中监听事件bus.$on(&apos;id-selected&apos;, function (id) {// ...});</code></pre><p>具体组件的封装和使用，可参考vue-bus。</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex官网的专业术语，让有些人还是感觉，摸不着头脑，做一些实用场景给大家看</p><pre><code>state 用来数据共享数据存储mutation 用来注册改变数据状态getters 用来对共享数据进行过滤操作action 解决异步改变共享数据</code></pre><p>此时采用的演示方式还是用官方提供的vue-cli webpack版本</p><p>在src目录下我们创一个vuex文件夹，分别创建index.js,mutations.js,state.js,getters.js,actions.js</p><p>这样我们可对四种特性进行分文件，这样可以更加明确，清楚</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/74a488ee6821acb7e263.png" alt="目录"></p><p>我们分别把这四个特性放入index.js中进行store的实列化</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/df4e0b9aed60a84d45ef.png" alt="state主目录"></p><p>再把实列化的store引入就是所谓的index.js文件夹引入到main.js中，也可以同时把store注册到每一个组件中</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/60c0bddd7c2b31df2879.png" alt="state实例化"></p><h4 id="state如何用？"><a href="#state如何用？" class="headerlink" title="state如何用？"></a>state如何用？</h4><p>在页面中，title肯定是必备，那每个组件页面的title都肯定不一样，那我们如何去拿到title,title适合放在那里，根据每个页面切换，而改变title,这个牵扯的就是组件与组件中的通信</p><p>我们可以在state.js中先声明一数据值</p><pre><code>export default{    title : &quot;首页&quot;}</code></pre><p><strong>那我们如何在首页中拿到这个title值</strong></p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/a6dfd2f072b4b9a012e9.jpg" alt=""></p><p>那我们在mian.js中再加入new Vue,绑定title作用域的实例代码</p><p>我们在computed里进行数据监听，</p><p>此时我们就可以从store里拿到state.title</p><p>最后一步，我们在index.html中我们再进行vue组件之间的数据传递及共享绑定</p><p><strong>index.html</strong></p><pre><code>&lt;title&gt;{{title}}&lt;/title&gt;</code></pre><p>此时我们运行一下，打开dev-tools你会发现</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/46eded6760bba9be1619.jpg" alt=""></p><p>title这个数据已经在全局被共享了</p><h4 id="matutions如何使用"><a href="#matutions如何使用" class="headerlink" title="matutions如何使用"></a>matutions如何使用</h4><p>应用场景：</p><p>如果我们要改变顶层的共享数据，我们应该要用matutions来进行改变，如果你做公众号，后台一般会在连接的上给你一些参数，比方说sid,ck,tm,或者一些其它东西，你想把他存在state中，如果去做，那我们就通过matutions来进行注册事件，为了演示，我才这么做</p><p>注意：<br>对于vuex，我只推荐state状态存储只在一个页面中组件与组件之间的通信，不适合跨页面， 放一些状态</p><p><strong>state.js</strong></p><pre><code>export default{    START_PARMA : {},    title : &quot;首页&quot;}</code></pre><p>START_PARMA用来存放我以上连接参数的数据，我们先前一定要定意好</p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    state.START_PARMA = Object    }}</code></pre><p>我们对改变state数据进行一个事件注册，第一个参数是拿到state对象，第二个是传入的参数</p><ul><li>getParam官方说是type，其实就是注册的事件名</li><li>可以是单个参数</li><li><p>如果是多个参数，我们则用对象放入，如果你写两个参数，会报错</p><pre><code>export default {        name : &apos;advertisement&apos;,        created () {            const keyCode = sessionStorage.keyCode = getQueryString(&apos;keyCode&apos;)            const keyWord = sessionStorage.keyWord =  keyCode.split(&quot;_&quot;)[0]            const hunterCode = sessionStorage.hunterCode = keyCode.split(&quot;_&quot;)[1]            const sid = sessionStorage.sid= getQueryString(&apos;sid&apos;)            const ck = sessionStorage.ck = getQueryString(&apos;ck&apos;)            const tm = sessionStorage.tm = getQueryString(&apos;tm&apos;)            this.$store.commit(&apos;getParam&apos;,{                keyCode,                keyWord,                hunterCode,                sid,                ck,                tm            })        }    }</code></pre></li></ul><p>我们自己创建一个视图，然后在created里进行截取参数，因为store是注册到每个组件中的，所以我们要用this.$store来访问，那commit就是一个触发器，第一个是type类形名，第二个参我们用对象的方式传入，里面用的是es6的语法</p><p>此时你会发现</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/f0aa5d0df0fbe76c49f3.png" alt=""></p><p>此时的截取的状态放到了一个对象里，我们就可以使用了</p><h4 id="getters如何使用"><a href="#getters如何使用" class="headerlink" title="getters如何使用"></a>getters如何使用</h4><p>如果说getter就是对state里的数据进行一些过滤，改造等等</p><p>那比方说State里有一些这样的数据</p><p><strong>state.js</strong></p><pre><code>people : [        {name : &apos;ziksang1&apos;,age:21},        {name : &apos;ziksang2&apos;,age:10},        {name : &apos;ziksang3&apos;,age:30},        {name : &apos;ziksang4&apos;,age:40},        {name : &apos;ziksang5&apos;,age:50},        {name : &apos;ziksang6&apos;,age:30},        {name : &apos;ziksang7&apos;,age:80}    ]</code></pre><p>如果我们定义这些数据，然后我们要从，这些数据中筛选出年纪大于30的人，再进行返回，我们就可以用到getter,这里的getter的意思就是对vuex顶层数据进行过滤，而不改动state里原本的数据</p><p><strong>getters.js</strong></p><pre><code>export default{    changePeople: (state) =&gt;{        return state.people.filter(item=&gt;{            if(item.age&gt;30){                return true            }        })    }}</code></pre><p>好我们如何应用呢，我们在组件中里只要写入</p><pre><code>created () {        console.log(this.changePeople)},computed : {            changePeople () {                return this.$store.getters.changePeople            }},</code></pre><p>那我们可以打开命台看一下，看回的数据，</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/6dca03740c0b56087763.jpg" alt=""><br>接下来你如何想对数据进行操作那就看你自己的了</p><h4 id="action-如何使用？"><a href="#action-如何使用？" class="headerlink" title="action 如何使用？"></a>action 如何使用？</h4><p>action.是用来解决异步流程来改变state数据的，有想人说，那我直接在matution里面进行写进不就行了麻，那你可以试一下，因为matution是直接进行同步操作的</p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    setTimeout(()=&gt;{            state.START_PARMA = Object    },1000)    }}</code></pre><p>还是拿上面例子，如果你在mutations里进行异步操作，你会发现没用，并不会起任何效果，那怎么办，只有通过action-&gt;mutations-&gt;states,这个流程进行操作</p><p><strong>action.js</strong></p><pre><code>export default {    getParamSync (context,Object) {        setTimeout(()=&gt;{            context.commit(&apos;getParam&apos;,Object)        },3000)    }}</code></pre><p>写一个getParamSync函灵敏，第一个参数就是上下文，context是一个store对象，你也可以用解构的方式写出来,第二个参数还是我们要写入的接收到的参数，来改变触发mutations事件,再通过mutation来改变state,很好理解不难</p><p>然后我们就在组件里这么调用就可以了</p><pre><code>this.$store.dispatch(&apos;getParamSync&apos;,{    keyCode,    keyWord,    hunterCode,    sid,    ck,    tm})</code></pre><p>那组合action又是怎么玩呢？我们有时候向后台请求时，要通过第一个AJAX返回值来进行下一个action分发</p><p>我们可以用promise来进行异步处理</p><p><strong>actions.js</strong></p><pre><code>export default {    getParamSync (context,Object) {        return new Promise((reslove,reject)=&gt;{            setTimeout(()=&gt;{                context.commit(&apos;getParam&apos;,Object)                return reslove(&apos;成功&apos;)            },3000)        })    },    changetitleSync ({commit},title){        setTimeout(()=&gt;{            commit(&apos;changetitle&apos;,title)        },3000)    }}</code></pre><p>在getParamSync使用new promise之后，在resolve里返回‘成功’，再分发一个changetitleSync改变title的action方法</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/4a3b12a68fd64e5aa0ea.png" alt=""></p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    state.START_PARMA = Object    },    changetitle (state,title){        state.title = title    }}</code></pre><p>再在注册一个改变title的changetitle的type类型</p><p><strong>组中间调用</strong></p><pre><code>created(){this.$store.dispatch(&apos;getParamSync&apos;,{                keyCode,                keyWord,                hunterCode,                sid,                ck,                tm            }).then((res)=&gt;{                this.$store.dispatch(&apos;changetitleSync&apos;,res)            })}</code></pre><p>我们就可以在组件中进行一种链式调用，解决异步回调，来action套action,就成了一个组合action</p><p><strong>关于其它辅助用法</strong></p><ul><li>mapState 辅助函数</li><li>mapGetters 辅助函数</li><li>mapMutations 辅助函数</li><li>mapActions 辅助函数</li></ul><p>尤大神已经写的很全面了，大家可以参考vuex的官网，进行阅读一下。我在这里就没有必要再进行重新讲解了</p><p><strong>在vuex中，我认为vuex用在那里比较好？</strong></p><p>只适合运用于一个视图内组件与组件之间的组合传递，不适用于跨页面，但是可以共用，为了不因用户刷新页面，要进行初始化再次调用。</p><p><strong>不适合运用在那里</strong></p><p>在自己写一些Ui组件给大家或者开源用的话，不适用于写在vuex中，应该暴露所接收的Props,通过$emit来进行触发事件，一些关键性全局状态，不也适合存vuex中，你可以选择localStorage,sessionStorage</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理项目中代码，在组件之间数据传递遇到了问题，所以做了这次总结，如有不对的地方，望指正。&lt;/p&gt;
&lt;h3 id=&quot;父组件如何将数据传到子组件中&quot;&gt;&lt;a href=&quot;#父组件如何将数据传到子组件中&quot; class=&quot;headerlink&quot; title=&quot;父组件如何将数据传
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongodb常用操作指令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/mongodb%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/mongodb使用方法/</id>
    <published>2018-06-20T02:32:16.269Z</published>
    <updated>2018-03-26T04:24:27.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建简单mongodb服务器"><a href="#1-创建简单mongodb服务器" class="headerlink" title="1.创建简单mongodb服务器"></a>1.创建简单mongodb服务器</h3><ul><li><p><code>mongod --dbpath E:\MongoDB\db</code></p></li><li><p><code>mongo.exe</code></p></li></ul><h3 id="2-数据库操作-CRUD"><a href="#2-数据库操作-CRUD" class="headerlink" title="2.数据库操作(CRUD)"></a>2.数据库操作(CRUD)</h3><ul><li><p>显示数据库名称：<code>show dbs</code></p></li><li><p>切换数据库：<code>use &lt;dbname&gt;</code></p></li><li><p>删除当前数据库：<code>db.dropDatabase()</code></p></li><li><p>想要新建数据库，直接使用<code>use &lt;dbname&gt;</code>,在需要的时候会自动创建</p></li><li><p>新建表<code>db.&lt;表名&gt;.insert({})</code>;数据以json的格式</p></li><li><p>显示表名 ：<code>show collections</code></p></li></ul><blockquote><p>例子</p></blockquote><pre><code>&gt; use exapmledb&gt; db.ex_collection1.insert({x:1}) //在表ex_collection1中插入数据{x:1}&gt; show collections输出：ex_collection1system.indexes</code></pre><h4 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h4><ul><li><p>查询 ：<code>db.&lt;表名&gt;.find()</code> 默认返回所有数据</p><p>  <code>&gt; db.ex_collection1.find()</code> </p></li><li><p>查询表中数据，默认返回所有</p><p>  <code>{ &quot;_id&quot; : ObjectId(&quot;58e9e1c6d6ffabd315a4f74a&quot;), &quot;x&quot; : 1 }</code></p><p>  数据库会自动生成一个<code>_id</code>，也可以自己添加，但不能重复</p></li><li><p>条件查询：db.ex_collection1.find({x:1})</p></li><li><p>循环插入</p><p>  <code>&gt; for(i=2;i&lt;50;i++)db.ex_collection1.insert({x:i})</code></p></li><li><p>计算查询出来的总数</p><p>  <code>&gt; db.ex_collection1.find().count()</code>  </p></li><li><p>增加查询条件,下面表示，过滤前3条，返回两条，并且以x排序</p><p>  <code>db.ex_collection1.find().skip(3).limit(2).sort({x:1})</code></p><h4 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2 更新"></a>2.2 更新</h4></li><li><p>更新数据，比如将<code>x：1</code>的数据改为<code>x：999</code></p><p>  <code>db.ex_collection1.update({x:1},{x:999})</code> </p></li><li><p>部分更新，比如有数据{x:100, y:100, z:100},想要以z:100为条件，更新里面的y为99；</p><p>  <code>db.ex_collection1.update({z:100},{$set:{y:99}})</code></p></li><li><p>更新一条不存在的数据，如果查找y为100的数据，改为y：999，如果不存在的话就直接写入y：999数据,增加第三个参数true即可。</p><p>  <code>db.ex_collection1.update({y:100},{y:999},true)</code></p></li><li><p>更新多条数据，mongodb默认更新一条数据，比如有三条c为1的数据，使用前面方式更新只会修改第一条。</p><p>  <code>db.immoc_collection.update({c:1},{$set:{c:2}},false,true)</code></p></li></ul><h4 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h4><ul><li><p>删除数据</p><p>  <code>db.immoc_collection.remove({c:2})</code></p></li><li><p>删除表</p><p>  <code>db.ex_collection1.drop()</code></p></li></ul><h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h3><h4 id="3-1-查询创建索引"><a href="#3-1-查询创建索引" class="headerlink" title="3.1 查询创建索引"></a>3.1 查询创建索引</h4><ul><li><p>查询索引</p><p>  <code>db.ex_collection1.getIndexes()</code></p></li><li><p>创建索引(这里的1代表为正向，-1为负向索引)</p><p>  <code>db.imooc_collection.ensureIndex({x:1})</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-创建简单mongodb服务器&quot;&gt;&lt;a href=&quot;#1-创建简单mongodb服务器&quot; class=&quot;headerlink&quot; title=&quot;1.创建简单mongodb服务器&quot;&gt;&lt;/a&gt;1.创建简单mongodb服务器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 基础命令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/Linux%20%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/Linux 基础命令/</id>
    <published>2018-06-20T02:32:16.267Z</published>
    <updated>2018-03-28T04:07:24.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><pre><code>创建目录 mkdir &lt;目录名称&gt;删除目录 rm &lt;目录名称&gt;定位目录 cd &lt;目录名称&gt;查看目录文件 ls ll修改目录名 mv &lt;目录名称&gt; &lt;新目录名称&gt;拷贝目录 cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>创建文件 touch &lt;文件名称&gt; vi &lt;文件名称&gt;删除文件 rm &lt;文件名称&gt;修改文件名 mv &lt;文件名称&gt; &lt;新文件名称&gt;拷贝文件 cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></pre><h2 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h2><pre><code>查看文件 cat &lt;文件名称&gt; head &lt;文件名称&gt; tail &lt;文件名称&gt;编辑文件内容 vi &lt;文件名称&gt;查找文件内容 grep &apos;关键字&apos; &lt;文件名称&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;创建目录 mkdir &amp;lt;目录名称&amp;gt;
删除目录 rm &amp;lt;目录名称&amp;gt;
定位目录 cd &amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从头实现一个koa框架</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/koa%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/koa框架/</id>
    <published>2018-06-20T02:32:16.266Z</published>
    <updated>2018-04-17T15:12:52.097Z</updated>
    
    <content type="html"><![CDATA[<p>看完之后甚是膜拜，决定收藏记录下，引用地址<a href="https://zhuanlan.zhihu.com/p/35040744" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35040744</a></p><p>笔者认为，理解koa，主要需要搞懂四条主线，其实也是实现koa的四个步骤，</p><p>   分别是：</p><pre><code>1. 封装node http Server2. 构造resquest, response, context对象3. 中间件机制4. 错误处理</code></pre><h4 id="主线一：封装node-http-Server-从hello-world说起"><a href="#主线一：封装node-http-Server-从hello-world说起" class="headerlink" title="主线一：封装node http Server: 从hello world说起"></a>主线一：封装node http Server: 从hello world说起</h4><p>首先，不考虑框架，如果使用原生http模块来实现一个返回hello world的后端app，代码如下：</p><pre><code>let http = require(&apos;http&apos;);let server = http.createServer((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});server.listen(3000, () =&gt; {    console.log(&apos;listenning on 3000&apos;);});</code></pre><p>实现koa的第一步，就是对这个原生的过程进行封装，为此，我们首先创建application.js实现一个Application对象：</p><pre><code>// application.jslet http = require(&apos;http&apos;);class Application {    /**    * 构造函数    */    constructor() {        this.callbackFunc;    }    /**    * 开启http server并传入callback    */    listen(...args) {        let server = http.createServer(this.callback());        server.listen(...args);    }    /**    * 挂载回调函数    * @param {Function} fn 回调处理函数    */    use(fn) {        this.callbackFunc = fn;    }    /**    * 获取http server所需的callback函数    * @return {Function} fn    */    callback() {        return (req, res) =&gt; {            this.callbackFunc(req, res);        };    }}module.exports = Application;</code></pre><p>然后创建example.js:</p><pre><code>let simpleKoa = require(&apos;./application&apos;);let app = new simpleKoa();app.use((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});app.listen(3000, () =&gt; {    console.log(&apos;listening on 3000&apos;);});</code></pre><p>可以看到，我们已经初步完成了对于http server的封装，主要实现了app.use注册回调函数，app.listen语法糖开启server并传入回调函数了，典型的koa风格。</p><p>但是美中不足的是，我们传入的回调函数，参数依然使用的是req和res，也就是node原生的request和response对象，这些原生对象和api提供的方法不够便捷，不符合一个框架需要提供的易用性。因此，我们需要进入第二条主线了。</p><h4 id="主线二：构造request-response-context对象"><a href="#主线二：构造request-response-context对象" class="headerlink" title="主线二：构造request, response, context对象"></a>主线二：构造request, response, context对象</h4><p>如果阅读koa文档，会发现koa有三个重要的对象，分别是request, response, context。其中request是对node原生的request的封装，response是对node原生response对象的封装，context对象则是回调函数上下文对象，挂载了koa request和response对象。下面我们一一来说明。</p><p>首先要明确的是，对于koa的request和response对象，只是提供了对node原生request和response对象的一些方法的封装，明确了这一点，我们的思路是，使用js的getter和setter属性，基于node的对象req/res对象封装koa的request/response对象。</p><p>规划一下我们要封装哪些易用的方法。这里在文章中为了易懂，姑且只实现以下方法：</p><p>对于simpleKoa request对象，实现query读取方法，能够读取到url中的参数，返回一个对象。</p><p>对于simpleKoa response对象，实现status读写方法，分别是读取和设置http response的状态码，以及body方法，用于构造返回信息。</p><p>而simpleKoa context对象，则挂载了request和response对象，并对一些常用方法进行了代理。</p><p>首先创建request.js:</p><pre><code>// request.jslet url = require(&apos;url&apos;);module.exports = {    get query() {        return url.parse(this.req.url, true).query;    }};</code></pre><p>很简单，就是导出了一个对象，其中包含了一个query的读取方法，通过url.parse方法解析url中的参数，并以对象的形式返回。需要注意的是，代码中的this.req代表的是node的原生request对象，this.req.url就是node原生request中获取url的方法。稍后我们修改application.js的时候，会为koa的request对象挂载这个req。</p><p>然后创建response.js:</p><pre><code>// response.jsmodule.exports = {    get body() {        return this._body;    },    /**    * 设置返回给客户端的body内容    *    * @param {mixed} data body内容    */    set body(data) {        this._body = data;    },    get status() {        return this.res.statusCode;    },    /**    * 设置返回给客户端的stausCode    *    * @param {number} statusCode 状态码    */    set status(statusCode) {        if (typeof statusCode !== &apos;number&apos;) {            throw new Error(&apos;statusCode must be a number!&apos;);        }        this.res.statusCode = statusCode;    }};</code></pre><p>status读写方法分别设置或读取this.res.statusCode。同样的，这个this.res是挂载的node原生response对象。而body读写方法分别设置、读取一个名为this._body的属性。这里设置body的时候并没有直接调用this.res.end来返回信息，这是考虑到koa当中我们可能会多次调用response的body方法覆盖性设置数据。真正的返回消息操作会在application.js中存在。</p><p>然后我们创建context.js文件，构造context对象的原型：</p><pre><code>// context.jsmodule.exports = {    get query() {        return this.request.query;    },    get body() {        return this.response.body;    },    set body(data) {        this.response.body = data;    },    get status() {        return this.response.status;    },    set status(statusCode) {        this.response.status = statusCode;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完之后甚是膜拜，决定收藏记录下，引用地址&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35040744&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/35040744
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSON格式详解</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/JSON%E6%A0%BC%E5%BC%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/JSON格式/</id>
    <published>2018-06-20T02:32:16.265Z</published>
    <updated>2018-04-17T14:39:23.180Z</updated>
    
    <content type="html"><![CDATA[<p>JSON是一种数据格式，又是 JS 的一个严格的子集，但并不从属于JavaScript.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>简单值：字符串、数值、布尔值、null.<strong>不支持 js 中的特殊值 undefined。</strong></li><li>对象：一种复杂数据类型，无序键值对儿。其中的值可以为简单值，也可以是复杂数据类型值。</li><li>数组，一种复杂数据类型，有序的值的列表，可以通过数值索引访问，数组的值也可以是任意类型。</li></ol><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><ul><li>js 字符串与 JSON 字符串最大的不同，在于 JSON 字符串必须为双引号，单引号可能导致语法错误。</li><li>布尔值和 null 也是有效的 JSON 格式，但通常是会用复杂的数据结构表示 JSON 对象。</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>js 对象字面量和 JSON 格式大体相同，但 JSON 对象有两点不同，首先没有变量声明，也没有末尾的分号，另外值得注意的是，<strong>属性必须加双引号</strong>！忘了给属性加双引号，或者写成单引号都是常见错误。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span>: <span class="number">29</span>,</span><br><span class="line"><span class="string">"school"</span>: &#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"BUPT"</span>,</span><br><span class="line"><span class="string">"location"</span>: <span class="string">"beijing"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>JSON 数组也没有变量和分号，对象和数组通常是 JSON 数据结构的最外层形式。但并不强制。</li></ul><h2 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h2><p>JSON之所以流行，主要的是可以把 JSON 数据结构解析为有用的 js 对象。简单清晰明了。</p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><h4 id="JSON-stringify-方法序列化的内部顺序："><a href="#JSON-stringify-方法序列化的内部顺序：" class="headerlink" title="JSON.stringify()方法序列化的内部顺序："></a>JSON.stringify()方法序列化的内部顺序：</h4><ol><li>如果存在 toJSON()方法，首先调用该方法，否则返回对象本身。</li><li>如果提供第二个参数，应用这个函数过滤器，第一个参数值为第一步传入的值。</li><li>对第二步返回的每个值进行相应的序列化。</li><li>如果提供了第三个参数，执行相应的序列化。</li></ol><ul><li>JSON.stringify()用于把 js 对象序列化为 JSON 字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">title: <span class="string">'professional js'</span>,</span><br><span class="line">authors: [</span><br><span class="line"><span class="string">'Nicholas'</span></span><br><span class="line">],</span><br><span class="line">edition: <span class="number">3</span>,</span><br><span class="line">year: <span class="number">2001</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book)  <span class="comment">//jsonText 即为转换好的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;"title":"professional js","authors":["Nicholas"],"edition":3,"year":2001&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonText)</span><br></pre></td></tr></table></figure><ul><li>JSON.stringify()其实还可以接受另外两个参数，用于以不同的方式进行序列化。</li><li>第一个参数是个过滤器，可以是数组也可以是函数，第二个参数表示是否保留缩进。这两个参数可以单独或配合使用。</li><li>如果第一个传入的参数是数组，那么返回的结果只会包含数组列出的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到的JSON 字符串只有 title 和 edition 两个属性</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">"title"</span>, <span class="string">"edition"</span>])</span><br></pre></td></tr></table></figure><ul><li>如果第一个传入参数是函数，函数接受(key, value)两个参数，根据属性名分别处理属性，属性名只能是字符串。如果返回值是 undefined，那么相应的属性就不会出现在返回的 JSON 字符串中了。相当于删除该属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123;  <span class="comment">//传入一个函数处理 key value</span></span><br><span class="line"><span class="keyword">switch</span>(key)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line"><span class="keyword">return</span> value.join(<span class="string">','</span>)<span class="comment">//没有 break 注意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'year'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">'edition'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span>  <span class="comment">//相当于删掉这个属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>第三个参数用于处理缩进和空白符。如果是数值，那么代表缩进的空格数。如果是字符串，代表空白符。</li><li>无论是数值还是字符串，都只会保留10位，超出的会被忽略，结果中只会出现10个空格或前十个字符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>) <span class="comment">//缩进4个字符</span></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="string">'----'</span>) <span class="comment">//缩进4个制表符</span></span><br></pre></td></tr></table></figure><ul><li>toJSON()方法。任何对象都可以添加 toJSON 方法，通过设置返回值使 JSON.stringify()生效。如果返回值为 undefined，如果是顶级对象，结果是 undefined，如果是包含在其他对象中，它的值为 null。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   title: <span class="string">'professional js'</span>,</span><br><span class="line">   authors: [</span><br><span class="line">     <span class="string">'Nicholas'</span></span><br><span class="line">   ],</span><br><span class="line">   edition: <span class="number">3</span>,</span><br><span class="line">   year: <span class="number">2001</span>,</span><br><span class="line">   toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//自定义 toJSON()方法</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.title</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book)</span><br><span class="line"> <span class="built_in">console</span>.log(jsonText)  <span class="comment">// 返回的JSON 对象为"professional js"</span></span><br></pre></td></tr></table></figure><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><ul><li>JSON.parse()用于把 JSON 字符串解析为原生 js 值。</li><li>和 JSON.stringify()方法类似，parse()也可以接受第二个参数，是一个函数，将在每一个键值对上调用。参数也是 key、value 的形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key === <span class="string">"releaseDate"</span>) &#123;<span class="comment">//通过判断 key，来进行相应 value 的操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSON是一种数据格式，又是 JS 的一个严格的子集，但并不从属于JavaScript.&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简单值：字符串、数值、布
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript创建对象和实现继承</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/JAVASCRIPT%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/JAVASCRIPT对象/</id>
    <published>2018-06-20T02:32:16.264Z</published>
    <updated>2018-04-17T14:39:49.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript创建对象"><a href="#JavaScript创建对象" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h2><h3 id="构造函数模式创建对象"><a href="#构造函数模式创建对象" class="headerlink" title="构造函数模式创建对象"></a>构造函数模式创建对象</h3><pre><code>function Person(name, job) {    this.name = name    this.job = job    this.sayName = function() {        console.log(this.name)    }}var person1 = new Person(‘Jiang’, ‘student’)var person2 = new Person(‘X’, ‘Doctor’)</code></pre><p>没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作</p><pre><code>创建一个新对象这个新对象会被执行[[prototype]]链接这个新对象会绑定到函数调用的this返回这个对象</code></pre><p>使用这个方式创建对象可以检测对象类型</p><pre><code>person1 instanceof Object // trueperson1 instanceof Person //true</code></pre><p>但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次</p><h3 id="原型模式创建对象"><a href="#原型模式创建对象" class="headerlink" title="原型模式创建对象"></a>原型模式创建对象</h3><pre><code>function Person() {}Person.prototype.name = ‘Jiang’Person.prototype.job = ‘student’Person.prototype.sayName = function() {console.log(this.name)}var person1 = new Person()</code></pre><p>将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。</p><p>原型是一个非常重要的概念，在一篇文章看懂proto和prototype的关系及区别中讲的非常详细</p><p>更简单的写法</p><pre><code>function Person() {}Person.prototype = {name: ‘jiang’,job: ‘student’,sayName: function() {    console.log(this.name)}}var person1 = new Person()</code></pre><p>将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。</p><p>使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里</p><p>Person.prototype.constructor === Person  // false<br>如果需要这个属性的话，可以手动添加</p><pre><code>function Person() {}Person.prototype = {    constructor：Person    name: ‘jiang’,    job: ‘student’,    sayName: function() {        console.log(this.name)    }}</code></pre><p>不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法</p><pre><code>Object.defineProperty(Person.prototype, ‘constructor’, {enumerable: false,value: Person})</code></pre><p>缺点使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点</p><p>原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了</p><pre><code>function Person() {}Person.prototype = {    name: ‘jiang’,    friends: [‘Shelby’, ‘Court’]}var person1 = new Person()var person2 = new Person()person1.friends.push(‘Van’)console.log(person1.friends) //[“Shelby”, “Court”, “Van”]console.log(person2.friends) //[“Shelby”, “Court”, “Van”]console.log(person1.friends === person2.friends) // true</code></pre><p>friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript创建对象&quot;&gt;&lt;a href=&quot;#JavaScript创建对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript创建对象&quot;&gt;&lt;/a&gt;JavaScript创建对象&lt;/h2&gt;&lt;h3 id=&quot;构造函数模式创建对象&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript之闭包</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/Javascript%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/Javascript之闭包/</id>
    <published>2018-06-20T02:32:16.263Z</published>
    <updated>2018-04-21T06:47:57.368Z</updated>
    
    <content type="html"><![CDATA[<p>面试当中总觉得自己也不是特别明白，今天过来总结一下。</p><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>JavaScript的闭包是一个特色。官方解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。这句话相信有许多人看不懂。我来表述一下我对JavaScript闭包的理解：</p><p>闭包的例子：</p><pre><code>var count=10;//全局作用域 标记为flag1function add(){    var count=0;//函数全局作用域 标记为flag2    return function(){        count+=1;//函数的内部作用域        alert(count);    }}var s=add()s();//输出1s();//输出2</code></pre><p>add()的返回值是一个函数，首先第一次调用s()的时候，是执行add()的返回的函数，也就是下面这个函数：</p><pre><code>function(){        count+=1;//函数的内部作用域        alert(count);}</code></pre><p>也就是将count+1，在输出，那count是从哪儿来的的呢，根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count ，</p><pre><code>var count=10;//全局作用域function add(){    //var count=0;注释掉了    return function(){        count+=1;//函数的内部作用域        alert(count);    }}var s=add()s();//输出11s();//输出12</code></pre><p>自然这是体现不出闭包的性质，只为了说明函数作用域链 继续说明：第一次执行，是没有疑问的输出1，那第二次的过程是怎样的呢？ 继续执行那个函数的返回的方法，还是count+=1;然后再输出count ，这里问题就来了，不应该继续向上寻找，找到count=0；然后输出1吗？不知道有没有注意一个问题，那就是s()执行的是下面这个函数</p><pre><code>function(){        count+=1;//函数的内部作用域        alert(count);}</code></pre><p>也就是说add()，只被执行了一次。然后执行两次s()，那count的值就是只声明了一次。</p><p>var s=add()，函数add 只在这里执行了一次。</p><p>下面执行的都是s()，那第二次的count的值是从哪儿来的，没错它还是第一次执行add时，留下来的那个变量。</p><p>（这怎么可能，函数变量执行完就会被释放啊，为什么还在？这里就是一个垃圾回收机制的引用计数问题）。</p><blockquote><p>如果一个变量的引用不为0，那么他不会被垃圾回收机制回收，引用，就是被调用</p></blockquote><p>由于再次执行s()的时候，再次引用了第一次add()产生的变量count ，所以count没有被释放，第一次s(),count 的值为1,第二次执行s()，count的值再加1，自然就是2了。</p><p>让我们返回来再看看，根据以上所说，如果执行两次add() ，那就应该输出 都是1，来改一下这个函数</p><pre><code>function add(){    var count=0;//函数全局作用域    return function(){        count+=1;//函数的内部作用域        alert(count);    }}add()();//输出1add()();//输出1</code></pre><p>果真如此。输出的两次都是1.</p><p>另外，我觉得阮一峰说的闭包也是很简洁的：“我的理解是，闭包就是能够读取其他函数内部变量的函数。”</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p><p>变量的作用域无非就是两种：全局变量和局部变量。</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><p>Js代码</p><pre><code>　　var n=999;　　function f1(){　　　　alert(n);　　}　　f1(); // 999</code></pre><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p><pre><code>　  function f1(){　　　　var n=999;　　}　　alert(n); // error</code></pre><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p><pre><code>　　function f1(){　　　　n=999;　　}　　f1();　　alert(n); // 999   </code></pre><p>有时候需要得到函数内的局部变量，在函数的内部，再定义一个函数。</p><pre><code>function f1(){    　　　　n=999;    　　　　function f2(){    　　　　　　alert(n); // 999    　　　　}    　　}</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值就可以在f1外部读取它的内部变量了</p><pre><code>    　function f1(){    　　　　n=999;    　　　　function f2(){    　　　　　　alert(n);    　　　　}    　　　　return f2;    　　}    　　var result=f1();    　　result(); // 999</code></pre><h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><ul><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p></li><li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便<strong>改变父函数内部变量的值。</strong></p></li></ul><p>###闭包的用途</p><p>1、前面提到的可以读取函数内部的变量</p><p>2、让这些变量的值始终保持在内存中。</p><p>怎么来理解这句话呢？请看下面的代码。</p><pre><code>    　function f1(){    　　　　var n=999;    　　　　nAdd=function(){n+=1}    　　　　function f2(){    　　　　　　alert(n);    　　　　}    　　　　return f2;    　　}    　　var result=f1();    　　result(); // 999    　　nAdd();    　　result(); // 1000</code></pre><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试当中总觉得自己也不是特别明白，今天过来总结一下。&lt;/p&gt;
&lt;h3 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h3&gt;&lt;p&gt;JavaScript的闭包是一个特色。官
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iconfont图片使用技巧</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/20/iconfont%E5%AD%97%E4%BD%93%E5%9B%BE%E7%89%87/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/20/iconfont字体图片/</id>
    <published>2018-06-20T02:32:16.262Z</published>
    <updated>2018-04-17T15:21:54.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="font-class引用"><a href="#font-class引用" class="headerlink" title="font-class引用"></a>font-class引用</h3><hr><p>font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题。</p><p>与unicode使用方式相比，具有如下特点：</p><h5 id="1-兼容性良好，支持ie8-，及所有现代浏览器。"><a href="#1-兼容性良好，支持ie8-，及所有现代浏览器。" class="headerlink" title="1.兼容性良好，支持ie8+，及所有现代浏览器。"></a>1.兼容性良好，支持ie8+，及所有现代浏览器。</h5><h5 id="2-相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。"><a href="#2-相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。" class="headerlink" title="2.相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。"></a>2.相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。</h5><h5 id="3-因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。"><a href="#3-因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。" class="headerlink" title="3.因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。"></a>3.因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。</h5><h5 id="4-不过因为本质上还是使用的字体，所以多色图标还是不支持的。"><a href="#4-不过因为本质上还是使用的字体，所以多色图标还是不支持的。" class="headerlink" title="4.不过因为本质上还是使用的字体，所以多色图标还是不支持的。"></a>4.不过因为本质上还是使用的字体，所以多色图标还是不支持的。</h5><p>使用步骤如下：</p><h4 id="第一步：引入项目下面生成的fontclass代码："><a href="#第一步：引入项目下面生成的fontclass代码：" class="headerlink" title="第一步：引入项目下面生成的fontclass代码："></a>第一步：引入项目下面生成的fontclass代码：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./iconfont.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="第二步：挑选相应图标并获取类名，应用于页面："><a href="#第二步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第二步：挑选相应图标并获取类名，应用于页面："></a>第二步：挑选相应图标并获取类名，应用于页面：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont icon-nav-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>“iconfont”是你项目下的font-family。可以通过编辑项目查看，默认是”iconfont”。</em></p><h2 id="symbol引用"><a href="#symbol引用" class="headerlink" title="symbol引用"></a>symbol引用</h2><hr><p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点：</p><h5 id="1-支持多色图标了，不再受单色限制。"><a href="#1-支持多色图标了，不再受单色限制。" class="headerlink" title="1.支持多色图标了，不再受单色限制。"></a>1.支持多色图标了，不再受单色限制。</h5><h5 id="2-通过一些技巧，支持像字体那样，通过font-size-color来调整样式。"><a href="#2-通过一些技巧，支持像字体那样，通过font-size-color来调整样式。" class="headerlink" title="2.通过一些技巧，支持像字体那样，通过font-size,color来调整样式。"></a>2.通过一些技巧，支持像字体那样，通过font-size,color来调整样式。</h5><h5 id="3-兼容性较差，支持-ie9-及现代浏览器。"><a href="#3-兼容性较差，支持-ie9-及现代浏览器。" class="headerlink" title="3.兼容性较差，支持 ie9+,及现代浏览器。"></a>3.兼容性较差，支持 ie9+,及现代浏览器。</h5><h5 id="4-浏览器渲染svg的性能一般，还不如png。"><a href="#4-浏览器渲染svg的性能一般，还不如png。" class="headerlink" title="4.浏览器渲染svg的性能一般，还不如png。"></a>4.浏览器渲染svg的性能一般，还不如png。</h5><h5 id="使用步骤如下："><a href="#使用步骤如下：" class="headerlink" title="使用步骤如下："></a>使用步骤如下：</h5><h4 id="第一步：引入项目下面生成的symbol代码："><a href="#第一步：引入项目下面生成的symbol代码：" class="headerlink" title="第一步：引入项目下面生成的symbol代码："></a>第一步：引入项目下面生成的symbol代码：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./iconfont.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="第二步：加入通用css代码（引入一次就行）："><a href="#第二步：加入通用css代码（引入一次就行）：" class="headerlink" title="第二步：加入通用css代码（引入一次就行）："></a>第二步：加入通用css代码（引入一次就行）：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .icon &#123;</span></span><br><span class="line"><span class="undefined">     width: 1em; height: 1em;</span></span><br><span class="line"><span class="undefined">     vertical-align: -0.15em;</span></span><br><span class="line"><span class="undefined">     fill: currentColor;</span></span><br><span class="line"><span class="undefined">     overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="第三步：挑选相应图标并获取类名，应用于页面："><a href="#第三步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第三步：挑选相应图标并获取类名，应用于页面："></a>第三步：挑选相应图标并获取类名，应用于页面：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-nav-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="unicode引用"><a href="#unicode引用" class="headerlink" title="unicode引用"></a>unicode引用</h2><hr><p>unicode是字体在网页端最原始的应用方式，特点是：</p><h5 id="1-兼容性最好，支持ie6-，及所有现代浏览器。"><a href="#1-兼容性最好，支持ie6-，及所有现代浏览器。" class="headerlink" title="1.兼容性最好，支持ie6+，及所有现代浏览器。"></a>1.兼容性最好，支持ie6+，及所有现代浏览器。</h5><h5 id="2-支持按字体的方式去动态调整图标大小，颜色等等。"><a href="#2-支持按字体的方式去动态调整图标大小，颜色等等。" class="headerlink" title="2.支持按字体的方式去动态调整图标大小，颜色等等。"></a>2.支持按字体的方式去动态调整图标大小，颜色等等。</h5><h5 id="3-但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。"><a href="#3-但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。" class="headerlink" title="3.但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。"></a>3.但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。</h5><p><em>注意：新版iconfont支持多色图标，这些多色图标在unicode模式下将不能使用，如果有需求建议使用symbol的引用方式</em></p><h5 id="unicode使用步骤如下："><a href="#unicode使用步骤如下：" class="headerlink" title="unicode使用步骤如下："></a>unicode使用步骤如下：</h5><h4 id="第一步：拷贝项目下面生成的font-face"><a href="#第一步：拷贝项目下面生成的font-face" class="headerlink" title="第一步：拷贝项目下面生成的font-face"></a>第一步：拷贝项目下面生成的font-face</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: 'iconfont';</span><br><span class="line">    src: url('iconfont.eot');</span><br><span class="line">    src: url('iconfont.eot?#iefix') format('embedded-opentype'),</span><br><span class="line">    url('iconfont.woff') format('woff'),</span><br><span class="line">    url('iconfont.ttf') format('truetype'),</span><br><span class="line">    url('iconfont.svg#iconfont') format('svg');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二步：定义使用iconfont的样式"><a href="#第二步：定义使用iconfont的样式" class="headerlink" title="第二步：定义使用iconfont的样式"></a>第二步：定义使用iconfont的样式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.iconfont&#123;</span><br><span class="line">    font-family:"iconfont" !important;</span><br><span class="line">    font-size:16px;font-style:normal;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    -webkit-text-stroke-width: 0.2px;</span><br><span class="line">    -moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三步：挑选相应图标并获取字体编码，应用于页面"><a href="#第三步：挑选相应图标并获取字体编码，应用于页面" class="headerlink" title="第三步：挑选相应图标并获取字体编码，应用于页面"></a>第三步：挑选相应图标并获取字体编码，应用于页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont"</span>&gt;</span>&amp;#x33;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>“iconfont”是你项目下的font-family。可以通过编辑项目查看，默认是”iconfont”。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;font-class引用&quot;&gt;&lt;a href=&quot;#font-class引用&quot; class=&quot;headerlink&quot; title=&quot;font-class引用&quot;&gt;&lt;/a&gt;font-class引用&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;font-class是unicode使用方式的一种
      
    
    </summary>
    
    
  </entry>
  
</feed>
