<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BigDeal@blogs</title>
  
  <subtitle>记录学习中的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/luwenchun/luwenchun.github.io/"/>
  <updated>2019-02-12T14:07:13.005Z</updated>
  <id>https://github.com/luwenchun/luwenchun.github.io/</id>
  
  <author>
    <name>卢文春</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS想关汇总</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2019/01/15/48JS%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2019/01/15/48JS总结/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-02-12T14:07:13.005Z</updated>
    
    <content type="html"><![CDATA[<!-- # 内置类型JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。基本类型有六种： `null`，`undefined`，`boolean`，`number`，`string`，`symbol`。其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 [Bug](#%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03)。`NaN` 也属于 `number` 类型，并且 `NaN` 不等于自身。对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span> <span class="comment">// 这只是字面量，不是 number 类型</span></span><br><span class="line">a.toString() <span class="comment">// 使用时候才会转换为对象类型</span></span><br></pre></td></tr></table></figure><p>对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">'FE'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.name = <span class="string">'EF'</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// EF</span></span><br></pre></td></tr></table></figure><h1 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h1><p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure><p><code>typeof</code> 对于对象，除了函数都会显示 <code>object</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p>对于 <code>null</code> 来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 Bug</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><p>PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p><p>如果我们想获得一个变量的正确类型，可以通过 <code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[object Type]</code> 的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="comment">// 我们也可以这样判断 undefined</span></span><br><span class="line">a === <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样判断就会出错</span></span><br><span class="line"><span class="comment">// 所以可以用下面的方式来判断，并且代码量更少</span></span><br><span class="line"><span class="comment">// 因为 void 后面随便跟上一个组成表达式</span></span><br><span class="line"><span class="comment">// 返回就是 undefined</span></span><br><span class="line">a === <span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h2><p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象。</p><h2 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h2><p>对象在转换基本类型时，首先会调用 <code>valueOf</code> 然后调用 <code>toString</code>。并且这两个方法你是可以重写的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以重写 <code>Symbol.toPrimitive</code> ，该方法在转基本类型时调用优先级最高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="string">'1'</span> + a <span class="comment">// =&gt; '12'</span></span><br></pre></td></tr></table></figure><h2 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h2><p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"><span class="number">2</span> * <span class="string">'2'</span> <span class="comment">// 4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] + [<span class="number">2</span>, <span class="number">1</span>] <span class="comment">// '1,22,1'</span></span><br><span class="line"><span class="comment">// [1, 2].toString() -&gt; '1,2'</span></span><br><span class="line"><span class="comment">// [2, 1].toString() -&gt; '2,1'</span></span><br><span class="line"><span class="comment">// '1,2' + '2,1' = '1,22,1'</span></span><br></pre></td></tr></table></figure><p>对于加号需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> <span class="comment">// -&gt; "aNaN"</span></span><br><span class="line"><span class="comment">// 因为 + 'b' -&gt; NaN</span></span><br><span class="line"><span class="comment">// 你也许在一些代码中看到过 + '1' -&gt; 1</span></span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a><code>==</code> 操作符</h2><p><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275f89ebf931e9" alt=""></p><p>上图中的 <code>toPrimitive</code> 就是对象转基本类型。</p><p>这里来解析一道题目 <code>[] == ![] // -&gt; true</code> ，下面是这个表达式为何为 <code>true</code> 的步骤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [] 转成 true，然后取反变成 false</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line"><span class="comment">// 根据第 8 条得出</span></span><br><span class="line">[] == ToNumber(<span class="literal">false</span>)</span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第 10 条得出</span></span><br><span class="line">ToPrimitive([]) == <span class="number">0</span></span><br><span class="line"><span class="comment">// [].toString() -&gt; ''</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第 6 条得出</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ol><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li><li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li></ol><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p><img src="https://camo.githubusercontent.com/71cab2efcf6fb8401a2f0ef49443dd94bffc1373/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f31332f313632316538613962636230383732643f773d34383826683d35393026663d706e6726733d313531373232" alt="prototype"></p><p>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</p><p>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</p><p>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</p><p>如果你想更进一步的了解原型，可以仔细阅读 <a href="https://github.com/KieSun/Blog/issues/2">深度解析原型中的各个难点</a>。</p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><ol><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象</li></ol><p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    <span class="comment">// 获得构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 链接到原型</span></span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="comment">// 绑定 this，执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p><p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure><p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo.getName();   <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// -&gt; 2</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a9c56c838aa88?w=2100&amp;h=540&amp;f=png&amp;s=127506" alt=""></p><p>从上图可以看出，<code>new Foo()</code> 的优先级大于 <code>new Foo</code> ，所以对于上述代码来说可以这样划分执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName());   </span><br><span class="line">(<span class="keyword">new</span> Foo()).getName();</span><br></pre></td></tr></table></figure><p>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ，所以结果为 1；对于后者来说，先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 <code>Foo</code> 上的 <code>getName</code> 函数，所以结果为 2。</p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p><p>我们也可以试着实现一下 <code>instanceof</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p><code>this</code> 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> foo()</span><br><span class="line">c.a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(c.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure><p>以上几种情况明白了，很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br></pre></td></tr></table></figure><p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code>。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是 <code>window</code>。并且 <code>this</code> 一旦绑定了上下文，就不会被任何代码改变。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>当执行 JS 代码时，会产生三种执行上下文</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ul><p>每个执行上下文中都有三个重要的属性</p><ul><li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li><li>作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）</li><li>this</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 <code>foo</code> 上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对于全局上下文来说，VO 大概是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === globe</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">foo: <span class="xml"><span class="tag">&lt;<span class="name">Function</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>对于函数 <code>foo</code> 来说，VO 不能访问，只能访问到活动对象（AO）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    i: <span class="literal">undefined</span>,</span><br><span class="line">b: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="built_in">arguments</span>: <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数独有的对象(箭头函数没有)</span></span><br><span class="line"><span class="xml">// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span></span><br><span class="line"><span class="xml">// 该对象中的 `callee` 属性代表函数本身</span></span><br><span class="line"><span class="xml">// `caller` 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure><p>对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 <code>[[Scope]]</code> 属性查找上级变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fooContext.[[Scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">]</span><br><span class="line">fooContext.Scope = fooContext.[[Scope]] + fooContext.VO</span><br><span class="line">fooContext.Scope = [</span><br><span class="line">    fooContext.VO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来让我们看一个老生常谈的例子，<code>var</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'call b'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</p><p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'call b fist'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'call b second'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure><p><code>var</code> 会产生很多错误，所以在 ES6中引入了 <code>let</code>。<code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。</p><p>对于非匿名的立即执行函数需要注意以下一点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) <span class="comment">// -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure><p>因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code>，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">specialObject = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">Scope = specialObject + Scope;</span><br><span class="line">  </span><br><span class="line">foo = <span class="keyword">new</span> FunctionExpression;</span><br><span class="line">foo.[[Scope]] = Scope;</span><br><span class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// remove specialObject from the front of scope chain</span></span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p><p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。</p><p>解决办法两种，第一种使用闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种就是使用 <code>setTimeout</code>  的第三个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, i*<span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是使用 <code>let</code> 定义  <code>i</code> 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// 形成块级作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( ii );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p><p>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>首先可以通过 <code>Object.assign</code> 来解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>当然我们也可以通过展开运算符（…）来解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><p>但是该方法也是有局限性的：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure><p>如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1ec2d3f9e41?w=840&amp;h=100&amp;f=png&amp;s=30123" alt=""></p><p>在遇到函数、 <code>undefined</code> 或者 <code>symbol</code> 的时候，该对象也不能正常的序列化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    sex: <span class="built_in">Symbol</span>(<span class="string">'male'</span>),</span><br><span class="line">    jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    name: <span class="string">'yck'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "yck"&#125;</span></span><br></pre></td></tr></table></figure><p>你会发现在上述情况中，该方法会忽略掉函数和 <code>undefined</code> 。</p><p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs#cloneDeep">lodash 的深拷贝函数</a>。</p><p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;</span><br><span class="line">    c: b</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="comment">// 注意该方法是异步的</span></span><br><span class="line"><span class="comment">// 可以处理 undefined 和循环引用对象</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>在有 Babel 的情况下，我们可以直接使用 ES6 的模块化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// file b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a, b&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> XXX <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br></pre></td></tr></table></figure><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p><code>CommonJs</code> 是 Node 独有的规范，浏览器中使用就需要用到 <code>Browserify</code> 解析了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">exports.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.a</span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class="line"><span class="comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  exports: &#123;&#125; <span class="comment">// exports 就是个空对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br><span class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 导出的东西</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="built_in">module</span>.exports = a</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来说说 <code>module.exports</code> 和 <code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p><p>对于 <code>CommonJS</code> 和 ES6 中的模块化的两者区别是：</p><ul><li>前者支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li><li><p>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</p></li><li><p>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</p></li><li>后者会编译成 <code>require/exports</code> 来执行的</li></ul><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 是由 <code>RequireJS</code> 提出的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a.do()</span><br><span class="line">    b.do()</span><br><span class="line">&#125;)</span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)  </span><br><span class="line">    a.doSomething()   </span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line">    b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p><p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p><p>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p><p>我们先来看一个袖珍版的防抖理解一下防抖的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">  <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">  <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数</span></span><br></pre></td></tr></table></figure><p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说：</p><ul><li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用<code>延迟执行</code>的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。</li><li>例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用<code>立即执行</code>的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。</li></ul><p>下面我们来实现一个带有立即执行选项的防抖函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是用来获取当前时间戳的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟函数执行完毕，清空缓存的定时器序号</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 延迟执行的情况下，函数会在延迟函数中执行</span></span><br><span class="line">    <span class="comment">// 使用到之前缓存的参数和上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有创建延迟执行函数（later），就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      <span class="comment">// 如果是立即执行，调用函数</span></span><br><span class="line">      <span class="comment">// 否则缓存参数和调用上下文</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="keyword">this</span></span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span></span><br><span class="line">    <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体函数实现的不难，总结一下。</p><ul><li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 <code>null</code>，就可以再次点击了。</li><li>对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数</li></ul><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125;   func      回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span></span><br><span class="line"><span class="comment"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span></span><br><span class="line"><span class="comment"> *                                两者不能共存，否则函数不能执行</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 之前的时间戳</span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 options 没传则设为空对象</span></span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时器回调函数</span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果设置了 leading，就将 previous 设为 0</span></span><br><span class="line">      <span class="comment">// 用于下面函数的第一个 if 判断</span></span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      <span class="comment">// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span></span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得当前时间戳</span></span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="comment">// 首次进入前者肯定为 true</span></span><br><span class="line">  <span class="comment">// 如果需要第一次不执行函数</span></span><br><span class="line">  <span class="comment">// 就将上次时间戳设为当前的</span></span><br><span class="line">      <span class="comment">// 这样在接下来计算 remaining 的值时会大于0</span></span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="comment">// 计算剩余时间</span></span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="comment">// 如果当前调用已经大于上次调用时间 + wait</span></span><br><span class="line">      <span class="comment">// 或者用户手动调了时间</span></span><br><span class="line">   <span class="comment">// 如果设置了 trailing，只会进入这个条件</span></span><br><span class="line">  <span class="comment">// 如果没有设置 leading，那么第一次会进入这个条件</span></span><br><span class="line">  <span class="comment">// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span></span><br><span class="line">  <span class="comment">// 其实还是会进入的，因为定时器的延时</span></span><br><span class="line">  <span class="comment">// 并不是准确的时间，很可能你设置了2秒</span></span><br><span class="line">  <span class="comment">// 但是他需要2.2秒才触发，这时候就会进入这个条件</span></span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="comment">// 如果存在定时器就清理掉否则会调用二次回调</span></span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否设置了定时器和 trailing</span></span><br><span class="line">    <span class="comment">// 没有的话就开启一个定时器</span></span><br><span class="line">        <span class="comment">// 并且不能不能同时设置 leading 和 trailing</span></span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在 ES5 中，我们可以使用如下方式解决继承的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub()</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Sub,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上继承实现思路就是将子类的原型设置为父类的原型</p><p>在 ES6 中，我们可以通过 <code>class</code> 语法轻松解决这个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDate = <span class="keyword">new</span> MyDate()</span><br><span class="line">myDate.test()</span><br></pre></td></tr></table></figure><p>但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。</p><p>如果你使用编译过得代码调用 <code>myDate.test()</code> 你会惊奇地发现出现了报错</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1ecb39ab20d?w=678&amp;h=120&amp;f=png&amp;s=32812" alt=""></p><p>因为在 JS 底层有限制，如果不是由 <code>Date</code> 构造出来的实例的话，是不能调用 <code>Date</code> 里的函数的。所以这也侧面的说明了：<strong>ES6 中的 <code>class</code> 继承与 ES5 中的一般继承写法是不同的</strong>。</p><p>既然底层限制了实例必须由 <code>Date</code> 构造出来，那么我们可以改变下思路实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MyData.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(d, MyData.prototype)</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(MyData.prototype, <span class="built_in">Date</span>.prototype)</span><br></pre></td></tr></table></figure><p>以上继承实现思路：<strong>先创建父类实例</strong> =&gt; 改变实例原先的 <code>_proto__</code> 转而连接到子类的 <code>prototype</code> =&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</p><p>通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。</p><h1 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call, apply, bind 区别"></a>call, apply, bind 区别</h1><p>首先说下前两者的区别。</p><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</span><br></pre></td></tr></table></figure><h2 id="模拟实现-call-和-apply"><a href="#模拟实现-call-和-apply" class="headerlink" title="模拟实现 call 和 apply"></a>模拟实现 call 和 apply</h2><p>可以从以下几点来考虑如何实现</p><ul><li>不传入第一个参数，那么默认为 <code>window</code></li><li>改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args)</span><br><span class="line">  <span class="comment">// 删除 fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上就是 <code>call</code> 的思路，<code>apply</code> 的实现也类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></span><br><span class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化。</p><p>同样的，也来模拟实现下 <code>bind</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h1><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p><p>可以把 Promise 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</p><p><code>then</code> 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。</p><p>对于 <code>then</code> 来说，本质上可以把它看成是 <code>flatMap</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"><span class="comment">// promise 接收一个函数参数，该函数会立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  _this.currentState = PENDING;</span><br><span class="line">  _this.value = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 用于保存 then 中的回调，只有当 promise</span></span><br><span class="line">  <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">  _this.resolvedCallbacks = [];</span><br><span class="line">  _this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">// 如果 value 是个 Promise，递归执行</span></span><br><span class="line">      <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = RESOLVED;</span><br><span class="line">        _this.value = value;</span><br><span class="line">        _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = REJECTED;</span><br><span class="line">        _this.value = reason;</span><br><span class="line">        _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于解决以下问题</span></span><br><span class="line">  <span class="comment">// new Promise(() =&gt; throw Error('error))</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(_this.resolve, _this.reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    _this.reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line">  <span class="comment">// 规范 2.2.onResolved 和 onRejected 都为可选参数</span></span><br><span class="line">  <span class="comment">// 如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line">  <span class="comment">// Promise.resolve(4).then().then((value) =&gt; console.log(value))</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> <span class="keyword">throw</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line">      <span class="comment">// 所以用了 setTimeout 包裹下</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异步执行onRejected</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑到可能会有报错，所以使用 try/catch 包裹</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 规范 2.3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规范 2.3.2</span></span><br><span class="line">  <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">        <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">        <span class="comment">// 把值传给下个 then</span></span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">  <span class="comment">// reject 或者 resolve 其中一个执行过得话，忽略其他的</span></span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 规范 2.3.3，判断 x 是否为对象或者函数</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 规范 2.3.3.1</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// 如果 then 是函数，调用 x.then</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          e =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是根据 Promise / A+ 规范来实现的代码，可以通过 <code>promises-aplus-tests</code> 的完整测试</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/29/162715e8e37e689d?w=1164&amp;h=636&amp;f=png&amp;s=300285" alt=""></p><h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h1><p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></span><br><span class="line"><span class="comment">// 内部可以通过 yield 暂停代码</span></span><br><span class="line"><span class="comment">// 通过调用 next 恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h1><p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// -&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>Map</code> 有三个参数，分别是当前索引元素，索引，原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">//  parseInt('1', 0) -&gt; 1</span></span><br><span class="line"><span class="comment">//  parseInt('2', 1) -&gt; NaN</span></span><br><span class="line"><span class="comment">//  parseInt('3', 2) -&gt; NaN</span></span><br></pre></td></tr></table></figure><p><code>FlatMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlatMap</code> 看成是 <code>map</code> + <code>flatten</code> ，目前该函数在浏览器中还不支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>].flatMap(<span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// -&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>如果想将一个多维数组彻底的降维，可以这样实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDeep = <span class="function">(<span class="params">arr</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(arr)</span><br><span class="line">  ? arr.reduce( <span class="function">(<span class="params">a, b</span>) =&gt;</span> [...a, ...flattenDeep(b)] , [])</span><br><span class="line">  : [arr]</span><br><span class="line"></span><br><span class="line">flattenDeep([<span class="number">1</span>, [[<span class="number">2</span>], [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]])</span><br></pre></td></tr></table></figure><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[a, b].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a(b()))</span><br><span class="line"><span class="comment">// -&gt; 2 1</span></span><br></pre></td></tr></table></figure><h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></span><br></pre></td></tr></table></figure><p>可以把 <code>async</code> 看成将函数返回值使用 <code>Promise.resolve()</code> 包裹了下。</p><p><code>await</code> 只能在 <code>async</code> 函数中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'finish'</span>)</span><br><span class="line">      resolve(<span class="string">"sleep"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"object"</span>);</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p><p><code>async 和 await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><p>下面来看一个使用 <code>await</code> 的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, a) <span class="comment">// -&gt; '3' 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure><p>对于以上代码你可能会有疑惑，这里说明下原理</p><ul><li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，遇到<code>await</code>就会立即返回一个<code>pending</code>状态的<code>Promise</code>对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li><li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li><li>然后后面就是常规执行代码了</li></ul><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// `target` 代表需要添加代理的对象</span></span><br><span class="line"><span class="comment">// `handler` 用来自定义对象中的操作</span></span><br></pre></td></tr></table></figure><p>可以很方便的使用 Proxy 来实现一个数据绑定和监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = onWatch(obj, (v) =&gt; &#123;</span><br><span class="line">  value = v</span><br><span class="line">&#125;, (target, property) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.a <span class="comment">// -&gt; Get 'a' = 2</span></span><br></pre></td></tr></table></figure><h1 id="为什么-0-1-0-2-0-3"><a href="#为什么-0-1-0-2-0-3" class="headerlink" title="为什么 0.1 + 0.2 != 0.3"></a>为什么 0.1 + 0.2 != 0.3</h1><p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。</p><p>我们都知道计算机表示十进制是采用二进制表示的，所以 <code>0.1</code> 在二进制表示为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (0011) 表示循环</span></span><br><span class="line"><span class="number">0.1</span> = <span class="number">2</span>^<span class="number">-4</span> * <span class="number">1.10011</span>(<span class="number">0011</span>)</span><br></pre></td></tr></table></figure><p>那么如何得到这个二进制的呢，我们可以来演算下</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/26/162ffcb7fc1ca5a9?w=800&amp;h=1300&amp;f=png&amp;s=83139" alt=""></p><p>小数算二进制和整数不同。乘法计算时，只计算小数位，整数位用作每一位的二进制，并且得到的第一位为最高位。所以我们得出 <code>0.1 = 2^-4 * 1.10011(0011)</code>，那么 <code>0.2</code> 的演算也基本如上所示，只需要去掉第一步乘法，所以得出 <code>0.2 = 2^-3 * 1.10011(0011)</code>。</p><p>回来继续说 IEEE 754 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为 <code>0.1</code> 和 <code>0.2</code> 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。</p><p>所以 <code>2^-4 * 1.10011...001</code> 进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code> 。那么把这两个二进制加起来会得出 <code>2^-2 * 1.0011(0011 * 11次)0100</code> , 这个值算成十进制就是 <code>0.30000000000000004</code></p><p>下面说一下原生解决办法，如下代码所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配任意字符除了换行符和回车符</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">^9，这样使用代表匹配以 9 开头。[<code>^</code>9]，这样使用代表不匹配方括号内除了 9 的字符</td></tr><tr><td style="text-align:center">{1, 2}</td><td style="text-align:center">匹配 1 到 2 位字符</td></tr><tr><td style="text-align:center">(yck)</td><td style="text-align:center">只匹配和 yck 相同字符串</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center"></td><td>匹配 \</td><td>前后任意字符</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">只匹配出现 0 次及以上 * 前的字符</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">只匹配出现 1 次及以上 + 前的字符</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">? 之前字符可选</td></tr></tbody></table><h2 id="修饰语"><a href="#修饰语" class="headerlink" title="修饰语"></a>修饰语</h2><table><thead><tr><th style="text-align:center">修饰语</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">忽略大小写</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">全局搜索</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">多行</td></tr></tbody></table><h2 id="字符简写"><a href="#字符简写" class="headerlink" title="字符简写"></a>字符简写</h2><table><thead><tr><th style="text-align:center">简写</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母数字或下划线</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">和上面相反</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意的空白符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">和上面相反</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">和上面相反</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">和上面相反</td></tr></tbody></table><h1 id="V8-下的垃圾回收机制"><a href="#V8-下的垃圾回收机制" class="headerlink" title="V8 下的垃圾回收机制"></a>V8 下的垃圾回收机制</h1><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p><h2 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h2><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p><h2 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h2><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>在讲算法前，先来说下什么情况下对象会出现在老生代空间中：</p><ul><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li></ul><p>老生代中的空间很复杂，有如下几个空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AllocationSpace &#123;</span><br><span class="line">  <span class="comment">// TODO(v8:7464): Actually map this space's memory as read-only.</span></span><br><span class="line">  RO_SPACE,    <span class="comment">// 不变的对象空间</span></span><br><span class="line">  NEW_SPACE,   <span class="comment">// 新生代用于 GC 复制算法的空间</span></span><br><span class="line">  OLD_SPACE,   <span class="comment">// 老生代常驻对象空间</span></span><br><span class="line">  CODE_SPACE,  <span class="comment">// 老生代代码对象空间</span></span><br><span class="line">  MAP_SPACE,   <span class="comment">// 老生代 map 对象</span></span><br><span class="line">  LO_SPACE,    <span class="comment">// 老生代大空间对象</span></span><br><span class="line">  NEW_LO_SPACE,  <span class="comment">// 新生代大空间对象</span></span><br><span class="line"></span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在老生代中，以下情况会先启动标记清除算法：</p><ul><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ul><p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html">该博客</a> 详细阅读。</p><p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。 –&gt;</p>-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 
# 内置类型

JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。

基本类型有六种： `null`，`undefined`，`boolean`，`number`，`string`，`symbol`。

其中 JS 的数字类型是浮点
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React v16.3之后的生命周期</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2019/01/10/47React%20v16.3%E4%B9%8B%E5%90%8E%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2019/01/10/47React v16.3之后的生命周期/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-23T06:53:15.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-v16-4-的生命周期"><a href="#React-v16-4-的生命周期" class="headerlink" title="React v16.4 的生命周期"></a>React v16.4 的生命周期</h2><blockquote><p>React v16.4 的生命周期图</p></blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/5287253-82f6af8e0cc9012b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>React v16.4 的生命周期</p><h3 id="变更缘由"><a href="#变更缘由" class="headerlink" title="变更缘由"></a>变更缘由</h3><p>原来（React v16.0前）的生命周期在React v16推出的<a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">Fiber</a>之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。</p><p>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。</p><p>禁止不能用比劝导开发者不要这样用的效果更好，所以除了shouldComponentUpdate，其他在render函数之前的所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被getDerivedStateFromProps替代。</p><p>也就是用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state</p><p>React v16.0刚推出的时候，是增加了一个componentDidCatch生命周期函数，这只是一个增量式修改，完全不影响原有生命周期函数；但是，到了React v16.3，大改动来了，引入了两个新的生命周期函数。</p><h3 id="新引入了两个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate"><a href="#新引入了两个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate" class="headerlink" title="新引入了两个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate"></a>新引入了两个新的生命周期函数：<code>getDerivedStateFromProps</code>，<code>getSnapshotBeforeUpdate</code></h3><h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><p><code>getDerivedStateFromProps</code>本来（React v16.3中）是只在创建和更新（由父组件引发部分），如果不是由父组件引发，那么getDerivedStateFromProps也不会被调用，如自身setState引发或者forceUpdate引发。</p><blockquote><p>React v16.3 的生命周期图</p></blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/5287253-ccb5d35ca1defefc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>React v16.3</p><p>这样的话理解起来有点乱，在React v16.4中改正了这一点，让getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用，具体可看React v16.4 的生命周期图。</p><blockquote><p>React v16.4后的getDerivedStateFromProps</p></blockquote><p><strong>static getDerivedStateFromProps(props, state)</strong> 在组件创建时和更新时的render方法之前调用，它应该返回一个对象来更新状态，或者返回null来不更新任何内容。</p><h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h4><p><strong>getSnapshotBeforeUpdate()</strong> 被调用于render之后，可以读取但无法使用DOM。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。</p><p>官网给的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    //我们是否要添加新的 items 到列表?</span><br><span class="line">    // 捕捉滚动位置，以便我们可以稍后调整滚动.</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    //如果我们有snapshot值, 我们已经添加了 新的items.</span><br><span class="line">    // 调整滚动以至于这些新的items 不会将旧items推出视图。</span><br><span class="line">    // (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值)</span><br><span class="line">    if (snapshot !== null) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-v16-4-的生命周期&quot;&gt;&lt;a href=&quot;#React-v16-4-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;React v16.4 的生命周期&quot;&gt;&lt;/a&gt;React v16.4 的生命周期&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解前端流</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/12/30/46%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%B5%81/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/12/30/46深入理解前端流/</id>
    <published>2018-12-29T16:00:00.000Z</published>
    <updated>2019-01-23T07:45:26.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS核心指南必看"><a href="#JS核心指南必看" class="headerlink" title="JS核心指南必看"></a>JS核心指南必看</h2><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/JS/JS-ch.md">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/JS/JS-ch.md</a></p><h2 id="Promise实现原理（附源码）"><a href="#Promise实现原理（附源码）" class="headerlink" title="Promise实现原理（附源码）"></a>Promise实现原理（附源码）</h2><p><a href="https://www.jianshu.com/p/43de678e918a" target="_blank" rel="noopener">https://www.jianshu.com/p/43de678e918a</a></p><h2 id="Callback-Promise-Generator-Async-Await-和异常处理的演进"><a href="#Callback-Promise-Generator-Async-Await-和异常处理的演进" class="headerlink" title="Callback Promise Generator Async-Await 和异常处理的演进"></a>Callback Promise Generator Async-Await 和异常处理的演进</h2><p><a href="https://juejin.im/entry/589b1b862f301e0069990557" target="_blank" rel="noopener">https://juejin.im/entry/589b1b862f301e0069990557</a></p><h2 id="Callback、Promise、Generator、async-await对比"><a href="#Callback、Promise、Generator、async-await对比" class="headerlink" title="Callback、Promise、Generator、async/await对比"></a>Callback、Promise、Generator、async/await对比</h2><p><a href="https://www.lazycoffee.com/articles/view?id=58ab09eea072b332753d9774" target="_blank" rel="noopener">https://www.lazycoffee.com/articles/view?id=58ab09eea072b332753d9774</a></p><h2 id="docker学习笔记"><a href="#docker学习笔记" class="headerlink" title="docker学习笔记"></a>docker学习笔记</h2><p><a href="https://miaopei.github.io/2016/12/23/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://miaopei.github.io/2016/12/23/Docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><h2 id="HTTP思维导图"><a href="#HTTP思维导图" class="headerlink" title="HTTP思维导图"></a>HTTP思维导图</h2><p><a href="https://miaopei.github.io/2017/04/12/HTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" target="_blank" rel="noopener">https://miaopei.github.io/2017/04/12/HTTP%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</a></p><h2 id="算法问题"><a href="#算法问题" class="headerlink" title="算法问题"></a>算法问题</h2><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Algorithm/algorithm-ch.md">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Algorithm/algorithm-ch.md</a></p><p>[<a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/DataStruct/dataStruct-zh.md]">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/DataStruct/dataStruct-zh.md]</a><br>(<a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/DataStruct/dataStruct-zh.md">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/DataStruct/dataStruct-zh.md</a>)</p><h2 id="MVVM响应式原理"><a href="#MVVM响应式原理" class="headerlink" title="MVVM响应式原理"></a>MVVM响应式原理</h2><p>[<a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Framework/framework-zh.md]">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Framework/framework-zh.md]</a><br>(<a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Framework/framework-zh.md">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Framework/framework-zh.md</a>)</p><h2 id="Vue底层"><a href="#Vue底层" class="headerlink" title="Vue底层"></a>Vue底层</h2><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Framework/vue-zh.md">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/Framework/vue-zh.md</a></p><h2 id="小程序权威指南"><a href="#小程序权威指南" class="headerlink" title="小程序权威指南"></a>小程序权威指南</h2><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/MP/mp-ch.md">https://github.com/InterviewMap/CS-Interview-Knowledge-Map/blob/master/MP/mp-ch.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS核心指南必看&quot;&gt;&lt;a href=&quot;#JS核心指南必看&quot; class=&quot;headerlink&quot; title=&quot;JS核心指南必看&quot;&gt;&lt;/a&gt;JS核心指南必看&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/InterviewMap/CS-In
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端进阶之路</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/12/10/45%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/12/10/45前端进阶之路/</id>
    <published>2018-12-09T16:00:00.000Z</published>
    <updated>2019-01-22T03:13:24.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue官方脚手架Vue-cli3脚手架使用"><a href="#Vue官方脚手架Vue-cli3脚手架使用" class="headerlink" title="Vue官方脚手架Vue-cli3脚手架使用"></a>Vue官方脚手架Vue-cli3脚手架使用</h3><p><a href="http://www.cnblogs.com/hongdiandian/p/8311645.html" target="_blank" rel="noopener">http://www.cnblogs.com/hongdiandian/p/8311645.html</a></p><h3 id="Vue模板语法"><a href="#Vue模板语法" class="headerlink" title="Vue模板语法"></a>Vue模板语法</h3><p><a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/render-function.html</a></p><h3 id="Vue组件化"><a href="#Vue组件化" class="headerlink" title="Vue组件化"></a>Vue组件化</h3><p>1.如何编写单文件组件<br><a href="https://cn.vuejs.org/v2/guide/single-file-components.html#%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%EF%BC%9F" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/single-file-components.html#%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%EF%BC%9F</a><br>2。如何编写高阶组件<br><a href="https://segmentfault.com/a/1190000010371752" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010371752</a><br>3.如何编写高质量的UI组件<br><a href="https://www.cnblogs.com/kingboy2008/p/9236226.html" target="_blank" rel="noopener">https://www.cnblogs.com/kingboy2008/p/9236226.html</a></p><h3 id="前端模块系统"><a href="#前端模块系统" class="headerlink" title="前端模块系统"></a>前端模块系统</h3><p>1.ES6 Module模块化<br><a href="https://www.jianshu.com/p/29f89e8b9cb6" target="_blank" rel="noopener">https://www.jianshu.com/p/29f89e8b9cb6</a><br>2.AMD CMD Commonjs区别<br><a href="https://www.jianshu.com/p/3576ccc68cb7" target="_blank" rel="noopener">https://www.jianshu.com/p/3576ccc68cb7</a></p><h3 id="Vue-devtools开发调试插件"><a href="#Vue-devtools开发调试插件" class="headerlink" title="Vue-devtools开发调试插件"></a>Vue-devtools开发调试插件</h3><h3 id="计算属性-表单处理-事件处理"><a href="#计算属性-表单处理-事件处理" class="headerlink" title="计算属性 表单处理 事件处理"></a>计算属性 表单处理 事件处理</h3><h3 id="ES6-Promise处理异步"><a href="#ES6-Promise处理异步" class="headerlink" title="ES6 Promise处理异步"></a>ES6 Promise处理异步</h3><p><a href="https://www.cnblogs.com/guoyeqiang/p/8243838.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyeqiang/p/8243838.html</a></p><h3 id="ES7-异步终极解决方案-Async-await"><a href="#ES7-异步终极解决方案-Async-await" class="headerlink" title="ES7 异步终极解决方案 Async+await"></a>ES7 异步终极解决方案 Async+await</h3><p><a href="https://blog.csdn.net/tongshuo_11/article/details/68491434" target="_blank" rel="noopener">https://blog.csdn.net/tongshuo_11/article/details/68491434</a></p><h3 id="Vue的UI组件选型"><a href="#Vue的UI组件选型" class="headerlink" title="Vue的UI组件选型"></a>Vue的UI组件选型</h3><h3 id="组件布局"><a href="#组件布局" class="headerlink" title="组件布局"></a>组件布局</h3><h3 id="Vuex状态管理"><a href="#Vuex状态管理" class="headerlink" title="Vuex状态管理"></a>Vuex状态管理</h3><p>1.Vuex数据管理<br>2.核心组件State<br>3.核心组件Getter<br>4.核心组件Mutation<br>5。核心组件Module<br>6。核心组件Action<br>7.复杂项目中的数据流设计<br>8.数据持久化</p><h3 id="Vue-router在单页面SPA应用"><a href="#Vue-router在单页面SPA应用" class="headerlink" title="Vue-router在单页面SPA应用"></a>Vue-router在单页面SPA应用</h3><p>1.多页面到单页面（SPA）发展<br>2.路由管理<br>3.路由重定向<br>4.路由嵌套<br>5.路由守卫<br>6.路由懒加载</p><h3 id="Vuejs核心原理剖析"><a href="#Vuejs核心原理剖析" class="headerlink" title="Vuejs核心原理剖析"></a>Vuejs核心原理剖析</h3><h3 id="react16-7"><a href="#react16-7" class="headerlink" title="react16.7"></a>react16.7</h3><p>1.React官方脚手架Creat-react-app<br>2.ES6面向对象Class语法<br>3.JSX使用<br>vue中jsx的使用<br><a href="https://juejin.im/post/5b221e2951882574aa5f4c5a" target="_blank" rel="noopener">https://juejin.im/post/5b221e2951882574aa5f4c5a</a><br>4.虚拟DOM原理剖析<br><a href="https://cloud.tencent.com/developer/article/1006029" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1006029</a><br>5.setState数据管理<br><a href="https://www.cnblogs.com/feiyu6/p/9202873.html" target="_blank" rel="noopener">https://www.cnblogs.com/feiyu6/p/9202873.html</a><br>6.react组件化思想<br><a href="https://code.mforever78.com/front-end/2015/08/24/thinking-in-react-component/" target="_blank" rel="noopener">https://code.mforever78.com/front-end/2015/08/24/thinking-in-react-component/</a><br>7.react组件参数传递和校验<br><!-- 校验 --><br><a href="https://blog.csdn.net/gxf_ming/article/details/62891760" target="_blank" rel="noopener">https://blog.csdn.net/gxf_ming/article/details/62891760</a><br>组件传值，父子，全局bus，发布订阅<br><a href="https://www.oecom.cn/communication-between-react-components/" target="_blank" rel="noopener">https://www.oecom.cn/communication-between-react-components/</a></p><p>8.不可变数据结构Immutablejs</p><p>浅拷贝深拷贝动态控制拷贝<br><a href="https://github.com/sunyongjian/blog/issues/33">https://github.com/sunyongjian/blog/issues/33</a><br>Immutablejs使用说明<br><a href="https://juejin.im/post/5ae91f1e6fb9a07a9d702255" target="_blank" rel="noopener">https://juejin.im/post/5ae91f1e6fb9a07a9d702255</a><br>创建新的数据对象并不会触发state从新渲染<br><a href="https://www.zhihu.com/question/297323663/answer/504587178" target="_blank" rel="noopener">https://www.zhihu.com/question/297323663/answer/504587178</a></p><p>9.react表单处理<br><a href="https://segmentfault.com/a/1190000004696515" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004696515</a><br>10.EA6箭头函数<br><a href="https://github.com/youngwind/blog/issues/14">https://github.com/youngwind/blog/issues/14</a><br>11.ES6数组<br><a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/array</a><br>12.ES6数据表格<br><a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/array</a><br>13.react动画<br><a href="https://segmentfault.com/a/1190000007388260" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007388260</a><br><a href="https://zhuanlan.zhihu.com/p/28536964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28536964</a><br>14.react生命周期<br><a href="https://juejin.im/post/5a062fb551882535cd4a4ce3" target="_blank" rel="noopener">https://juejin.im/post/5a062fb551882535cd4a4ce3</a><br>15.react错误处理周期<br><a href="https://www.zcfy.cc/article/error-handling-in-react-16-react-blog" target="_blank" rel="noopener">https://www.zcfy.cc/article/error-handling-in-react-16-react-blog</a><br><a href="http://blog.codingplayboy.com/2017/11/10/react-error-handle/" target="_blank" rel="noopener">http://blog.codingplayboy.com/2017/11/10/react-error-handle/</a><br><a href="https://zhuanlan.zhihu.com/p/28156587" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28156587</a><br>16.react fiber架构剖析<br>解决的问题<br><a href="https://juejin.im/entry/5b0245486fb9a07ac23b08ab" target="_blank" rel="noopener">https://juejin.im/entry/5b0245486fb9a07ac23b08ab</a><br>原理解析<br><a href="https://juejin.im/post/5b7016606fb9a0099406f8de" target="_blank" rel="noopener">https://juejin.im/post/5b7016606fb9a0099406f8de</a><br>17.react新功能之Hooks<br><a href="https://juejin.im/post/5bebd46251882527796a95cc" target="_blank" rel="noopener">https://juejin.im/post/5bebd46251882527796a95cc</a></p><h3 id="ant-design组件使用经验"><a href="#ant-design组件使用经验" class="headerlink" title="ant-design组件使用经验"></a>ant-design组件使用经验</h3><h3 id="Redux状态管理"><a href="#Redux状态管理" class="headerlink" title="Redux状态管理"></a>Redux状态管理</h3><p>1.setState和属性传递管理数据的不足</p><p>2.单向数据量VS双向数据流<br>3.Redux核心组件之Action<br>4.redux核心组件之reducer<br>5.redux核心组件之dispatch<br>6.react-redux连接redux和react<br>7.react-redux核心组件Provider和connect<br>8.redux之中间件剖析<br>9.redux-thunk中间件处理异步任务</p><h3 id="react-router4单页面SPA应用"><a href="#react-router4单页面SPA应用" class="headerlink" title="react-router4单页面SPA应用"></a>react-router4单页面SPA应用</h3><p>1.路由管理<br>2.路由和组件<br>3.路由重定向<br>4.生命周期<br>5.react路由懒加载</p><h3 id="redux解决方案dva"><a href="#redux解决方案dva" class="headerlink" title="redux解决方案dva"></a>redux解决方案dva</h3><p>1.dva是什么<br>2.ES6之generator<br>3.redux-saga中间件</p><h3 id="react虚拟DOM原理"><a href="#react虚拟DOM原理" class="headerlink" title="react虚拟DOM原理"></a>react虚拟DOM原理</h3><h3 id="react和vue差异比较"><a href="#react和vue差异比较" class="headerlink" title="react和vue差异比较"></a>react和vue差异比较</h3><h3 id="Nodejs核心模块"><a href="#Nodejs核心模块" class="headerlink" title="Nodejs核心模块"></a>Nodejs核心模块</h3><p>1.nodejs模块化VS ES6模块化<br>2.Node流<br>3.Buffer</p><h3 id="Nodejs异步"><a href="#Nodejs异步" class="headerlink" title="Nodejs异步"></a>Nodejs异步</h3><p>1.Events<br>2.Timer<br>3.Event-loop</p><h3 id="Nodejs进程"><a href="#Nodejs进程" class="headerlink" title="Nodejs进程"></a>Nodejs进程</h3><p>1.进程与线程<br>2.cluster</p><h3 id="Nodejs-io网络"><a href="#Nodejs-io网络" class="headerlink" title="Nodejs io网络"></a>Nodejs io网络</h3><p>1.nodejs IO（fs、net、stream模块）<br>2.TCP/IP协议<br>3.Http2.0<br>4.https<br>5.前端跨域问题解决方案<br><a href="https://juejin.im/post/5c35f6286fb9a049be5dad82" target="_blank" rel="noopener">https://juejin.im/post/5c35f6286fb9a049be5dad82</a></p><h3 id="常见数据库缓存解决方案"><a href="#常见数据库缓存解决方案" class="headerlink" title="常见数据库缓存解决方案"></a>常见数据库缓存解决方案</h3><p>1.选型策略<br>2.爬虫项目数据持久化<br>mysql<br>mongodb<br>redis</p><h3 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h3><p>1、传统MIS 包含用户状态管理、信息查询录入<br>2、ant-design-pro开发企业级管理后台<br>3、web框架选型策略<br>4、基于Express、Koa进行比较，以及他们的衍生品egg.js</p><h3 id="同构应用"><a href="#同构应用" class="headerlink" title="同构应用"></a>同构应用</h3><p>1、传统渲染模式与新时期的服务端渲染和同构开发</p><h3 id="部署运维"><a href="#部署运维" class="headerlink" title="部署运维"></a>部署运维</h3><p>1、node.js部署和运维<br>2、nginx + pm2部署web应用实战</p><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><p>1、小程序开发模式VS传统Web开发模式<br>2、flex布局<br>3、扫码<br>4、下拉刷新<br>5、轮播图<br>6、图片<br>7、支付API</p><h3 id="小程序生态"><a href="#小程序生态" class="headerlink" title="小程序生态"></a>小程序生态</h3><p>1、小程序适用场景<br>2、快应用、百度小程序、支付宝小程序<br>3、一套代码编译各大厂商小程序：taro、mpvue</p><h3 id="微信开发"><a href="#微信开发" class="headerlink" title="微信开发"></a>微信开发</h3><p>1、服务器如何介入微信后台<br>2、node.js后台接入<br>3、微信消息管理</p><h3 id="微信网页开发"><a href="#微信网页开发" class="headerlink" title="微信网页开发"></a>微信网页开发</h3><p>1、依赖微信JSSDK开发业务<br>2、录音、地理位置、扫一扫</p><h3 id="公众号客服机器人"><a href="#公众号客服机器人" class="headerlink" title="公众号客服机器人"></a>公众号客服机器人</h3><h3 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h3><p>1、react-nativeVS传统ios和安卓开发模式<br>2、react-native核心api和组件实战<br>3、react-native网络请求</p><h3 id="react-native组件库和第三方UI组件库"><a href="#react-native组件库和第三方UI组件库" class="headerlink" title="react-native组件库和第三方UI组件库"></a>react-native组件库和第三方UI组件库</h3><p>1、ant-design-mobile的react-native版本<br>2、react-navagation导航</p><h3 id="react-native数据路由管理"><a href="#react-native数据路由管理" class="headerlink" title="react-native数据路由管理"></a>react-native数据路由管理</h3><p>1、单页面应用<br>2、redux管理数据<br>3、react-router路由</p><h3 id="移动App版实战和发布"><a href="#移动App版实战和发布" class="headerlink" title="移动App版实战和发布"></a>移动App版实战和发布</h3><h3 id="Wbe安全实战"><a href="#Wbe安全实战" class="headerlink" title="Wbe安全实战"></a>Wbe安全实战</h3><p>1、安全意义与常见web项目相关的漏洞原理解析与防御<br>2、Xss漏洞<br>3、CSRF漏洞<br>4、SQL注入<br>5、cookie安全策略<br>6、点击劫持<br>7、传输安全和HTTPS加密</p><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>1、前端工程化发展历史<br>2、前端生态工具：webpack、babel、eslint、webpack进阶<br>3、webpack常见优化<br>4、定制自己的loader<br>5、定制自己的plugin<br>6、babel进阶和编译优化处理<br>7、代码审查进阶</p><h3 id="错误监控📱📱收集"><a href="#错误监控📱📱收集" class="headerlink" title="错误监控📱📱收集"></a>错误监控📱📱收集</h3><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>1、单元测试<br>2、业务驱动开发&amp;&amp;测试驱动开发<br>3、黑盒测试和白盒测试<br>4、测试覆盖率<br>5、前端项目的单测集成<br>6、node项目的单测集成</p><h3 id="前端e2e测试"><a href="#前端e2e测试" class="headerlink" title="前端e2e测试"></a>前端e2e测试</h3><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><p>1、性能指标<br>2、业务场景<br>3、基于项目获取性能报告和报告背后的分析<br>4、浏览器重绘和回流<br>5、节流设计<br>6、资源加载与利用（懒加载、高效缓存、CDN）<br>7、浏览器缓存<br>8、移动端网络性能优化<br>9、nginx调优</p><h3 id="更快的代码"><a href="#更快的代码" class="headerlink" title="更快的代码"></a>更快的代码</h3><p>1、BOM/DOM交互优化<br>2、常见写法优化</p><h3 id="react性能优化"><a href="#react性能优化" class="headerlink" title="react性能优化"></a>react性能优化</h3><p>1、react常用性能优化策略<br>2、purecomponent</p><h3 id="Vue常用性能优化策略"><a href="#Vue常用性能优化策略" class="headerlink" title="Vue常用性能优化策略"></a>Vue常用性能优化策略</h3><h3 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h3><p>1、webkit缓存加载机制<br>2、cookie和session实现原理<br>3、DOM模型<br>4、css解释器<br>5、构建渲染树</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue官方脚手架Vue-cli3脚手架使用&quot;&gt;&lt;a href=&quot;#Vue官方脚手架Vue-cli3脚手架使用&quot; class=&quot;headerlink&quot; title=&quot;Vue官方脚手架Vue-cli3脚手架使用&quot;&gt;&lt;/a&gt;Vue官方脚手架Vue-cli3脚手架使用&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vuex原理探索</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/11/23/40Vuex%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/11/23/40Vuex原理/</id>
    <published>2018-11-22T16:00:00.000Z</published>
    <updated>2019-01-13T03:15:23.874Z</updated>
    
    <content type="html"><![CDATA[<p>路由Router</p><ol><li>配置 {path:’/login’,component:Login}</li><li>路由出口 router-view</li><li>传参 <ul><li>{path:’/login/:id’,component:Login}   $route.params.id</li><li>?foo=aaa                    $route.query.foo</li></ul></li><li>守卫<ul><li>全局 router.beforeEach</li><li>路由beforeEnter</li><li>组件beforeRouteEnter</li></ul></li><li>嵌套 {children:[]}</li></ol><p>状态管理Vuex</p><ol><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        cart: localStorage.getItem(&apos;cart&apos;)||&quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        addCart:(state,new)=&gt;&#123;</span><br><span class="line">            state.cart=new</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getter:&#123;</span><br><span class="line">         cartnum=state.cart+1</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        htttp.get(&quot;/api/get&quot;,&#123;&#125;,res=&gt;&#123;</span><br><span class="line">            res.code==1&amp;&amp; commit(&quot;addCart&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li>commit()//直接修改state</li><li>dispatch()//通过后台接口响应状态判断是否要修改state</li><li>$store.state.cart//直接取state</li><li>$store.getter.cartnum//直接取加工后的state</li></ul></li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz0jxbys94j30jh0fbwef.jpg" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KVuex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = options.state</span><br><span class="line">        <span class="keyword">this</span>.mutations = options.mutations</span><br><span class="line">        <span class="keyword">this</span>.actions = options.actions</span><br><span class="line">        <span class="comment">// 借用vue本身的响应式的通知机制</span></span><br><span class="line">        <span class="comment">// state 会将需要的依赖收集在 Dep 中</span></span><br><span class="line">        <span class="keyword">this</span>._vm = <span class="keyword">new</span> KVue(&#123;</span><br><span class="line">            data: &#123;</span><br><span class="line">                $state: <span class="keyword">this</span>.state</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commit (type, payload, _options) &#123;</span><br><span class="line">        <span class="keyword">const</span> entry = <span class="keyword">this</span>.mutations[type]</span><br><span class="line">        entry.forEach(<span class="function"><span class="params">handler</span>=&gt;</span>handler(payload))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch (type, payload) &#123;</span><br><span class="line">        <span class="keyword">const</span> entry = <span class="keyword">this</span>.actions[type]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entry(payload)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/vuejs/vuex">https://github.com/vuejs/vuex</a></p><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/book'</span>, <span class="attr">component</span>: Book &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/movie'</span>, <span class="attr">component</span>: Movie &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(Vue, &#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(Vue, options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$options = options</span><br><span class="line">        <span class="keyword">this</span>.routeMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            data: &#123;</span><br><span class="line">                current: <span class="string">'#/'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.init()</span><br><span class="line">        <span class="keyword">this</span>.createRouteMap(<span class="keyword">this</span>.$options)</span><br><span class="line">        <span class="keyword">this</span>.initComponent(Vue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 hashchange</span></span><br><span class="line">    init() &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.onHashChange.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.onHashChange.bind(<span class="keyword">this</span>), <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createRouteMap(options) &#123;</span><br><span class="line">        options.routes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.routeMap[item.path] = item.component</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册组件</span></span><br><span class="line">    initComponent(Vue) &#123;</span><br><span class="line">        Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                to: <span class="built_in">String</span></span><br><span class="line">            &#125;,</span><br><span class="line">            template: <span class="string">'&lt;a :href="to"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;'</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">        Vue.component(<span class="string">'router-view'</span>, &#123;</span><br><span class="line">            render(h) &#123;</span><br><span class="line">                <span class="keyword">var</span> component = _this.routeMap[_this.app.current]</span><br><span class="line">                <span class="keyword">return</span> h(component)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前 hash 串</span></span><br><span class="line">    getHash() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前路径</span></span><br><span class="line">    onHashChange() &#123;</span><br><span class="line">        <span class="keyword">this</span>.app.current = <span class="keyword">this</span>.getHash()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;路由Router&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置 {path:’/login’,component:Login}&lt;/li&gt;
&lt;li&gt;路由出口 router-view&lt;/li&gt;
&lt;li&gt;传参 &lt;ul&gt;
&lt;li&gt;{path:’/login/:id’,component:Logi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新公司常见功能函数封装</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/11/22/39%E6%96%B0%E5%85%AC%E5%8F%B8%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/11/22/39新公司常见功能函数封装/</id>
    <published>2018-11-21T16:00:00.000Z</published>
    <updated>2019-01-10T08:01:30.897Z</updated>
    
    <content type="html"><![CDATA[<p>这些函数包括常见的业务函数和通用函数</p><h4 id="日期过滤函数"><a href="#日期过滤函数" class="headerlink" title="日期过滤函数"></a>日期过滤函数</h4><pre><code>formatDate(date) {//data毫秒   date = new Date(date); //data格式化成国际标准时间   const pad = n =&gt; n &lt; 10 ? `0${n}` : n;   const dateStr1 = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;  //转化成2018-10-08 16:20   const dateStr = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;   const timeStr = `${pad(date.getHours())}:${pad(date.getMinutes())}`;   const weekDay = [&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;];   const myDate = new Date(Date.parse(dateStr.replace(/-/g, &quot;/&quot;)));   const weekday=weekDay[myDate.getDay()];   return `${dateStr}  ${weekday}  ${timeStr}`;//转化成2018-10-08  星期四 16:20},</code></pre><h4 id="后台返回数据格式化函数，返回指定的value-label类型"><a href="#后台返回数据格式化函数，返回指定的value-label类型" class="headerlink" title="后台返回数据格式化函数，返回指定的value label类型"></a>后台返回数据格式化函数，返回指定的value label类型</h4><pre><code> filterdata(data){    return new Promise((resolve, reject)=&gt;{        var arraytime=[];        data.forEach((item,index)=&gt;{            var obj={};            obj[&apos;value&apos;]=item[&apos;counselorCode&apos;];            obj[&apos;label&apos;]=item[&apos;counselorName&apos;];            arraytime.push(obj)        });        this.optis=arraytime;        resolve();    })}array=this.filterdata(array)array=[{&apos;counselorCode&apos;:&apos;www.baidu.com&apos;},{&apos;counselorName&apos;:&apos;百度&apos;}]=&gt;[{&apos;value&apos;:&apos;www.baidu.com&apos;},{&apos;label&apos;:&apos;百度&apos;}];</code></pre><h4 id="模拟表单提交"><a href="#模拟表单提交" class="headerlink" title="模拟表单提交"></a>模拟表单提交</h4><pre><code>//url提交表单url parmas动态选择的表单dom target虚拟dom，form表单挂载的位置postcall(url, params, target) {    var tempform = document.createElement(&quot;form&quot;);    tempform.action = url;    tempform.method = &quot;post&quot;;    tempform.style.display = &quot;none&quot;    if (target) {        tempform.target = target;    }    for (var x in params) {        var opt = document.createElement(&quot;input&quot;);        opt.name = x;        opt.value = params[x];        tempform.appendChild(opt);    }    var opt = document.createElement(&quot;input&quot;);    opt.type = &quot;submit&quot;;    tempform.appendChild(opt);    document.body.appendChild(tempform);    tempform.submit();    document.body.removeChild(tempform);}</code></pre><h4 id="调用高德地图线路最优规划"><a href="#调用高德地图线路最优规划" class="headerlink" title="调用高德地图线路最优规划"></a>调用高德地图线路最优规划</h4><pre><code>//根据起点终点的地名的市和详细地址获取经纬度//根据起点终点经纬度跳转到高德第三方页面规划最优路线，可以调用原生高德APPasync openLocation(ip) {    var ss=_this.state.dealerInfoData    //console.log(ss)    //出发地地址（经销商经纬度,或详细地址）后台没字段，暂时用经销商名字    //目的地地址 （客户经纬度）    const fromAddressStr = ss.dealerName    const toAddressStr = ss.driveAddressDels + ss.driveAddressDel    const from = await getLoc(fromAddressStr)    const to = await getLoc(toAddressStr)    const url = `https://uri.amap.com/navigation?from=${from}&amp;to=${to}`    console.log(url)    document.location.href = url    //获取地址经纬度    function getLoc(address) {        return new Promise((resolve,reject)=&gt;{        $.get(`https://restapi.amap.com/v3/geocode/geo?key=7a095ac801cf2ab21bb9d7370ab6add2&amp;address=${address}`,(data)=&gt;{            //console.log(&apos;位置查询&apos;,data)            if (data.infocode == 10000 &amp;&amp; data.status==1){            const [geocodes] = data.geocodes            if (geocodes){                console.log(geocodes)                const to = `${geocodes.location},${geocodes.formatted_address}`                resolve(to)            } else {                alert(&apos;您的试驾地址有误&apos;)            }            }else {            throw data.infocode            alert (&apos;接口异常&apos;)            }        })        })    }    return;}</code></pre><h4 id="微信分享函数"><a href="#微信分享函数" class="headerlink" title="微信分享函数"></a>微信分享函数</h4><pre><code> //封装差价 import $ from &apos;jquery&apos;; import Helper from &apos;./helper&apos;; /** * 微信相关接口方法调用 */ class WxJSHandler {     constructor() {         this.init();         this.earth_radius = 6378.137;     }     init() {         // Add weixin plugin         if (document.getElementById(&apos;scr_weixin&apos;) == null) {             let script = document.createElement(&apos;script&apos;);             script.src = &apos;https://res.wx.qq.com/open/js/jweixin-1.2.0.js&apos;;             script.id  = &quot;scr_weixin&quot;;             document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);         }     }     createNonceStr($len) {//加密方法         let chars = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;,             str = &quot;&quot;, i;         $len = $len || 16;         for (i = 0; i &lt; $len; i++) {             str += chars.substr((Math.random() * Math.floor(chars.length - 1)), 1);         }         return str;     }     wxReady(callback) {         let  nonceStr,             timestamp,             // url = url[0] ? url[0] + &apos;/wx/sharepage/getTicket&apos; : &apos;&apos;;             // url = &apos;http://lincoln-mp-dev.yonyouauto.com/wx/sharepage/getTicket&apos;;             // url = &apos;http://carowner.yonyouauto.com/wx/sharepage/getTicket&apos;             url = location.origin+&apos;/wx/sharepage/getTicket&apos;;             nonceStr = this.createNonceStr();//此处用了一个加密方法             timestamp = Math.floor(new Date().getTime() / 1000);             $.get(url, {}, function(ticket) {                 let params = {                     jsapi_ticket: ticket,                     noncestr: nonceStr,                     timestamp: timestamp,                     url: location.href.split(&apos;#&apos;)[0]                 }, str = &apos;&apos;,                 signature = &apos;&apos;;                 for (let v in params) {                     str += v + &apos;=&apos; + params[v] + &apos;&amp;&apos;;                 }                 str = str.substring(0, str.length - 1);                 signature = Helper.hexCode(str);//hexo加密，更多查考help.js                 wx.config({                     debug: true,                     // appId: &apos;wxb85ed633e428bafc&apos;, // Required, the only identification of Official account.//测试                     appId: &apos;wx235b2abcc8c160dc&apos;, //UAT                     // appId: &apos;wx77d29b0a35fdcb33&apos;,//生产                     timestamp: timestamp, // Required, generate a signed timestamp                     nonceStr: nonceStr, // Required, generate a signed nonceStr                     signature: signature,// Required, signature. See Appendix 1                     jsApiList: [&apos;chooseImage&apos;, &apos;uploadImage&apos;] // Required, required JA interface list, all JS interface list, see Appendix 2                 });                 wx.ready(function() {                         if (typeof callback === &apos;function&apos;) {                             callback &amp;&amp; callback()                         }                 })                 wx.error(function(res) {                     console.log(res);                 });             });     }     /**     * 选择上传图片     * @return     */     selectImage() {         return new Promise((resolve, reject) =&gt; {             wx.chooseImage({                 count: 1, // 默认9                 sizeType: [&apos;original&apos;, &apos;compressed&apos;], // 可以指定是原图还是压缩图，默认二者都有                 sourceType: [&apos;album&apos;, &apos;camera&apos;], // 可以指定来源是相册还是相机，默认二者都有                 success: function (res) {                     // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片                     resolve(res.localIds);                 }             });         });     }     /**     * 上传图片     * @param {String} id     * @return     */     uploadImage(id) {         return new Promise((resolve, reject) =&gt; {             wx.uploadImage({                 localId: id, // 需要上传的图片的本地ID，由chooseImage接口获得                 isShowProgressTips: 1, // 默认为1，显示进度提示                 success: function (res) {                     // 返回图片的服务器端ID                     resolve(res.serverId);                 }             });         });     } } export default new WxJSHandler //上传功能调用demo JSSDK.wxReady( ()=&gt;{     JSSDK.selectImage().then((value)=&gt;{         // 返回照片在手机系统的id             Toast({                         message: value,             });          JSSDK.uploadImage(value).then((url)=&gt;{             //  返回服务器给的图片URL             Toast({                         message: url,             });          })     })})</code></pre><h4 id="解决移动端300MS的点击延时，依赖fastClick"><a href="#解决移动端300MS的点击延时，依赖fastClick" class="headerlink" title="解决移动端300MS的点击延时，依赖fastClick"></a>解决移动端300MS的点击延时，依赖fastClick</h4><p><a href="https://github.com/ftlabs/fastclick">更多查看：https://github.com/ftlabs/fastclick</a></p><pre><code>import FastClick from &apos;fastclick&apos;;(function(doc) {    if (&apos;addEventListener&apos; in doc) {    doc.addEventListener(&apos;DOMContentLoaded&apos;, function() {        FastClick.attach(doc.body);    }, false);    }})(document);</code></pre><h4 id="移动端使用rem适配"><a href="#移动端使用rem适配" class="headerlink" title="移动端使用rem适配"></a>移动端使用rem适配</h4><pre><code>(function(doc, win) {var docEl = doc.documentElement,    resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,    recalc = function() {    var clientWidth = docEl.clientWidth;    if (!clientWidth) return;    docEl.style.fontSize = 20 * (clientWidth / 320) + &apos;px&apos;;    };if (!doc.addEventListener) return;win.addEventListener(resizeEvt, recalc, false);doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);})(document, window);</code></pre><h4 id="后台响应状态码容错处理"><a href="#后台响应状态码容错处理" class="headerlink" title="后台响应状态码容错处理"></a>后台响应状态码容错处理</h4><pre><code>export const message =  [    { code: 400, msg: &apos;1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。&apos;},    { code: 404, msg: &apos;请求失败，请求所希望得到的资源未被在服务器上发现。&apos;},    { code: 405, msg: &apos;请求行中指定的请求方法不能被用于请求相应的资源。&apos;},    { code: 413, msg: &apos;服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&apos;},    { code: 414, msg: &apos;请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。&apos;},    { code: 500, msg: &apos;服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。&apos;},    { code: 501, msg: &apos;服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&apos;},    { code: 502, msg: &apos;作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&apos;},    { code: 503, msg: &apos;由于临时的服务器维护或者过载，服务器当前无法处理请求。&apos;},    { code: 504, msg: &apos;作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。&apos;},    { code: 505, msg: &apos;服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&apos;},    { code: 600, msg: &apos;&apos;},]</code></pre><h4 id="全局自定义过滤器，业务场景式过滤器在需要的实例处添加"><a href="#全局自定义过滤器，业务场景式过滤器在需要的实例处添加" class="headerlink" title="全局自定义过滤器，业务场景式过滤器在需要的实例处添加"></a>全局自定义过滤器，业务场景式过滤器在需要的实例处添加</h4><pre><code>import Vue from &apos;vue&apos;import * as path from &apos;../config/path&apos;;let filters = {prefixImagePath:function (value,level) {    if(!value||typeof value ==&apos;undefined&apos;||value==0){    return &apos;./images/noPicture.png&apos;;    }    return path[&apos;http://img13.360buyimg.com/&apos;+level]+value.toString();},dotReplace:function (value,maxNum) {    //todo计算字节    if(!value||typeof(value)==&apos;undefined&apos;||value==0){    return &apos;&apos;;    }    if(maxNum&gt;(value.length-1)){    return value;    }    return value.toString().substr(0,maxNum)+&apos;...&apos;},//.....priceFormat:function(value){    var valueSplit = [];    value=value.replace(/^(\d*)$/,&quot;$1.&quot;);    value=(value+&quot;00&quot;).replace(/(\d*\.\d\d)\d*/,&quot;$1&quot;);    value=value.replace(&quot;.&quot;,&quot;,&quot;);    var re=/(\d)(\d{3},)/;    while(re.test(value))    value=value.replace(re,&quot;$1,$2&quot;);    value=value.replace(/,(\d\d)$/,&quot;.$1&quot;);    valueSplit = value.split(&apos;.&apos;);    if(valueSplit[1]&gt;0){    return  value.replace(/^\./,&quot;0.&quot;)    }else {    return valueSplit[0];    }}};export default ((vue)=&gt; {for(let fid in filters){    vue.filter(fid,filters[fid]);}})(Vue)</code></pre><h4 id="简单封装本地存储及cookie操作"><a href="#简单封装本地存储及cookie操作" class="headerlink" title="简单封装本地存储及cookie操作"></a>简单封装本地存储及cookie操作</h4><pre><code>**只实例化一次，同域下跨页面数据共享****https://github.com/marcuswestin/store.js****https://github.com/js-cookie/js-cookie**        import iStore from &apos;store&apos;;        import jsCookie from &apos;js-cookie&apos;;        class Store {        constructor(){        }        getLocal(key){            return iStore.get(key);        }        setLocal(key,value){            iStore.set(key,value);        }        removeLocal(key){            iStore.remove(key);        }        setCookie(key,value){            jsCookie.set(key,value);        }        setCookies(_object={}){            for(let key in _object){            this.setCookie(key,_object[key]);            }        }        getCookie(key){            return jsCookie.get(key);        }        removeCookie(key){            jsCookie.remove(key);        }        getCookies(){            return jsCookie.get();        }        }        function install(){            let instance;            if(!window.hasOwnProperty(&apos;store&apos;)){            window.store = instance = new Store();            }else {            instance = window[&apos;store&apos;];            }            return instance;        }        export default install();</code></pre><h4 id="截取url参数值"><a href="#截取url参数值" class="headerlink" title="截取url参数值"></a>截取url参数值</h4><pre><code>getQueryValue(name){    let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    let subString = location.href.split(&apos;?&apos;)[1]||&apos;&apos;;    let r = subString.match(reg);    if(r!=null)return  decodeURI(r[2]); return null;}  getMutiQueryValue(_arr = []) {    let resultObj = {};    _arr.forEach((item, index) =&gt; {    resultObj[item] = this.getQueryValue(item);    })    return resultObj;}</code></pre><h4 id="浏览量"><a href="#浏览量" class="headerlink" title="浏览量"></a>浏览量</h4><pre><code>@param {Number} n @return String        browseCunt(n) {            n = typeof n == &apos;string&apos; ? Number(n) : n;            if (n &gt;= 10000) {            n = Math.round(Math.round(n / 100) / 10) /10+ &apos;W&apos;;            }            return n;        }</code></pre><h4 id="日期格式转换"><a href="#日期格式转换" class="headerlink" title="日期格式转换"></a>日期格式转换</h4><pre><code>@param {String|Number} date @return String        dateName(date) {            if (!date) return !1;            const curTime = (new Date()).getTime()            let old = new Date(date)            if (isNaN(old)) {   // IOS 兼容            old = new Date(date.replace(/\-/g, &apos;/&apos;));            }            let cur = curTime - old.getTime();            cur = Math.abs(cur);            let msg = &apos;&apos;;            if (cur &gt; 259200000) { // 大于三天,显示日期            // msg = ((old.getMonth()) &lt; 9 ? &apos;0&apos; + (old.getMonth() + 1) : (old.getMonth())) + &apos;-&apos; + (old.getDate() &lt; 9 ? &apos;0&apos; + old.getDate() : old.getDate());            msg = moment(old).format(&apos;YYYY-MM-DD&apos;);            } else if (cur &gt;= 86400000) {  // 大于等于24小时,显示X天前            msg = Math.floor(cur / 86400000) + &apos;天前&apos;;            } else if (cur &gt;= 3600000) {  // 大于等于1小时,显示X小时前            msg = Math.floor(cur / 3600000) + &apos;小时前&apos;;            } else if (cur &gt;= 60000) {  // 大于等于1分钟,显示X分钟前            msg = Math.floor(cur / 60000) + &apos;分钟前&apos;;            } else {  // 小于60S, 显示刚刚            msg = &apos;刚刚&apos;            }            return msg;        };</code></pre><p>###/* 封装ajax函数</p><pre><code>* @param {string}obj.type http连接的方式，包括POST和GET两种方式* @param {string}obj.url 发送请求的url* @param {boolean}obj.async 是否为异步请求，true为异步的，false为同步的* @param {object}obj.data 发送的参数，格式为对象类型* @param {function}obj.success ajax发送并接收成功调用的回调函数* @param {function}obj.error ajax发送失败或者接收失败调用的回调函数*///  ecDo.ajax({//      type:&apos;get&apos;,//      url:&apos;xxx&apos;,//      data:{//          id:&apos;111&apos;//      },//      success:function(res){//          console.log(res)//      }//  })ajax: function (obj) {    obj = obj || {};    obj.type = obj.type.toUpperCase() || &apos;POST&apos;;    obj.url = obj.url || &apos;&apos;;    obj.async = obj.async || true;    obj.data = obj.data || null;    obj.success = obj.success || function () {        };    obj.error = obj.error || function () {        };    var xmlHttp = null;    if (XMLHttpRequest) {        xmlHttp = new XMLHttpRequest();    } else {        xmlHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    }    var params = [];    for (var key in obj.data) {        params.push(key + &apos;=&apos; + obj.data[key]);    }    var postData = params.join(&apos;&amp;&apos;);    if (obj.type.toUpperCase() === &apos;POST&apos;) {        xmlHttp.open(obj.type, obj.url, obj.async);        xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;);        xmlHttp.send(postData);    } else if (obj.type.toUpperCase() === &apos;GET&apos;) {        xmlHttp.open(obj.type, obj.url + &apos;?&apos; + postData, obj.async);        xmlHttp.send(null);    }    xmlHttp.onreadystatechange = function () {        if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {            obj.success(xmlHttp.responseText);        } else {            obj.error(xmlHttp.responseText);        }    };}</code></pre><h3 id="图片没加载出来时用一张图片代替"><a href="#图片没加载出来时用一张图片代替" class="headerlink" title="//图片没加载出来时用一张图片代替"></a>//图片没加载出来时用一张图片代替</h3><pre><code>//图片没加载出来时用一张图片代替aftLoadImg: function (obj, url, errorUrl,cb) {    var oImg = new Image(), _this = this;    oImg.src = url;    oImg.onload = function () {        obj.src = oImg.src;        if (cb &amp;&amp; _this.istype(cb, &apos;function&apos;)) {            cb(obj);        }    }    oImg.onerror=function () {        obj.src=errorUrl;        if (cb &amp;&amp; _this.istype(cb, &apos;function&apos;)) {            cb(obj);        }    }},//图片滚动懒加载//@className {string} 要遍历图片的类名//@num {number} 距离多少的时候开始加载 默认 0//比如，一张图片距离文档顶部3000，num参数设置200，那么在页面滚动到2800的时候，图片加载。不传num参数就滚动，num默认是0，页面滚动到3000就加载//html代码//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;....//data-src储存src的数据，到需要加载的时候把data-src的值赋值给src属性，图片就会加载。//详细可以查看testLoadImg.html//window.onload = function() {//    loadImg(&apos;load-img&apos;,100);//    window.onscroll = function() {//        ecDo.loadImg(&apos;load-img&apos;,100);//        }//}loadImg: function (className, num, errorUrl) {    var _className = className || &apos;ec-load-img&apos;, _num = num || 0, _this = this,_errorUrl=errorUrl||null;    var oImgLoad = document.getElementsByClassName(_className);    for (var i = 0, len = oImgLoad.length; i &lt; len; i++) {        //如果图片已经滚动到指定的高度        if (document.documentElement.clientHeight + document.documentElement.scrollTop &gt; oImgLoad[i].offsetTop - _num &amp;&amp; !oImgLoad[i].isLoad) {            //记录图片是否已经加载            oImgLoad[i].isLoad = true;            //设置过渡，当图片下来的时候有一个图片透明度变化            oImgLoad[i].style.cssText = &quot;transition: &apos;&apos;; opacity: 0;&quot;            if (oImgLoad[i].dataset) {                this.aftLoadImg(oImgLoad[i], oImgLoad[i].dataset.src, _errorUrl, function (o) {                    //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑                    setTimeout(function () {                        if (o.isLoad) {                            _this.removeClass(o, _className);                            o.style.cssText = &quot;&quot;;                        }                    }, 1000)                });            } else {                this.aftLoadImg(oImgLoad[i], oImgLoad[i].getAttribute(&quot;data-src&quot;), _errorUrl, function (o) {                    //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑                    setTimeout(function () {                        if (o.isLoad) {                            _this.removeClass(o, _className);                            o.style.cssText = &quot;&quot;;                        }                    }, 1000)                });            }            (function (i) {                setTimeout(function () {                    oImgLoad[i].style.cssText = &quot;transition:all 1s; opacity: 1;&quot;;                }, 16)            })(i);        }    }}</code></pre><h3 id="获取，设置url参数"><a href="#获取，设置url参数" class="headerlink" title="获取，设置url参数"></a>获取，设置url参数</h3><pre><code>//设置url参数//ecDo.setUrlPrmt({&apos;a&apos;:1,&apos;b&apos;:2})//result：a=1&amp;b=2setUrlPrmt: function (obj) {    var _rs = [];    for (var p in obj) {        if (obj[p] != null &amp;&amp; obj[p] != &apos;&apos;) {            _rs.push(p + &apos;=&apos; + obj[p])        }    }    return _rs.join(&apos;&amp;&apos;);},//获取url参数//ecDo.getUrlPrmt(&apos;test.com/write?draftId=122000011938&apos;)//result：Object{draftId: &quot;122000011938&quot;}getUrlPrmt: function (url) {    url = url ? url : window.location.href;    var _pa = url.substring(url.indexOf(&apos;?&apos;) + 1),        _arrS = _pa.split(&apos;&amp;&apos;),        _rs = {};    for (var i = 0, _len = _arrS.length; i &lt; _len; i++) {        var pos = _arrS[i].indexOf(&apos;=&apos;);        if (pos == -1) {            continue;        }        var name = _arrS[i].substring(0, pos),            value = window.decodeURIComponent(_arrS[i].substring(pos + 1));        _rs[name] = value;    }    return _rs;}</code></pre><h3 id="Date日期时间部分"><a href="#Date日期时间部分" class="headerlink" title="Date日期时间部分"></a>Date日期时间部分</h3><pre><code>//到某一个时间的倒计时//ecDo.getEndTime(&apos;2017/7/22 16:0:0&apos;)//result：&quot;剩余时间6天 2小时 28 分钟20 秒&quot;getEndTime: function (endTime) {    var startDate = new Date(); //开始时间，当前时间    var endDate = new Date(endTime); //结束时间，需传入时间参数    var t = endDate.getTime() - startDate.getTime(); //时间差的毫秒数    var d = 0,        h = 0,        m = 0,        s = 0;    if (t &gt;= 0) {        d = Math.floor(t / 1000 / 3600 / 24);        h = Math.floor(t / 1000 / 60 / 60 % 24);        m = Math.floor(t / 1000 / 60 % 60);        s = Math.floor(t / 1000 % 60);    }    return &quot;剩余时间&quot; + d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot; 分钟&quot; + s + &quot; 秒&quot;;}</code></pre><h3 id="适配rem"><a href="#适配rem" class="headerlink" title="适配rem"></a>适配rem</h3><pre><code>getFontSize: function (_client) {    var doc = document,        win = window;    var docEl = doc.documentElement,        resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,        recalc = function () {            var clientWidth = docEl.clientWidth;            if (!clientWidth) return;            //如果屏幕大于750（750是根据我效果图设置的，具体数值参考效果图），就设置clientWidth=750，防止font-size会超过100px            if (clientWidth &gt; _client) {                clientWidth = _client            }            //设置根元素font-size大小            docEl.style.fontSize = 100 * (clientWidth / _client) + &apos;px&apos;;        };    //屏幕大小改变，或者横竖屏切换时，触发函数    win.addEventListener(resizeEvt, recalc, false);    //文档加载完成时，触发函数    doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);}//ecDo.getFontSize(750)//使用方式很简单，比如效果图上，有张图片。宽高都是100px;//750是设计图的宽度//样式写法就是img{    width:1rem;    height:1rem;}//这样的设置，比如在屏幕宽度大于等于750px设备上，1rem=100px；图片显示就是宽高都是100px//比如在iphone6(屏幕宽度：375)上，375/750*100=50px;就是1rem=50px;图片显示就是宽高都是50px;</code></pre><h3 id="手机类型判断"><a href="#手机类型判断" class="headerlink" title="手机类型判断"></a>手机类型判断</h3><pre><code>browserInfo: function (type) {    switch (type) {        case &apos;android&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;android&apos;) !== -1        case &apos;iphone&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;iphone&apos;) !== -1        case &apos;ipad&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;ipad&apos;) !== -1        case &apos;weixin&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;micromessenger&apos;) !== -1        default:            return navigator.userAgent.toLowerCase()    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些函数包括常见的业务函数和通用函数&lt;/p&gt;
&lt;h4 id=&quot;日期过滤函数&quot;&gt;&lt;a href=&quot;#日期过滤函数&quot; class=&quot;headerlink&quot; title=&quot;日期过滤函数&quot;&gt;&lt;/a&gt;日期过滤函数&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;formatDate(date) {//
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>call、apply、bind 的理解与实例</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/09/15/32call%E3%80%81apply%E3%80%81bind%20%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E4%BE%8B/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/09/15/32call、apply、bind 的理解与实例/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2019-01-10T08:08:04.950Z</updated>
    
    <content type="html"><![CDATA[<p>call/apply 可以改变函数的this指向。 除了传递参数时有所差别，call和apply作用完全一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tim = &#123; </span><br><span class="line">    name: <span class="string">'tim'</span>, </span><br><span class="line">    age: <span class="number">20</span>, </span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jake = &#123; <span class="attr">name</span>: <span class="string">'jake'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"></span><br><span class="line">tim.getName(); <span class="comment">// tim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jake对象没有getName方法，但是可以通过call/apply去使用tim对象的getName方法</span></span><br><span class="line">tim.getName.call(jake);  <span class="comment">// jake </span></span><br><span class="line">tim.getName.apply(jake); <span class="comment">// jake</span></span><br></pre></td></tr></table></figure><p>tim.getName.call(jake)的意思是执行getName方法，但是通过call/apply将getName方法中的this指向强行设置为jake对象。因此最终的返回结果会是jake。</p><p>call apply的不同之处在于传递参数的形式。其中apply传递的参数为数组形式, call传递的参数为按顺序依次排列。一个简单的实例说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当参数个数不确定或者你觉得用apply比较爽时, 就直接使用apply</span></span><br><span class="line"><span class="comment">// 字面解释就是obj夺舍fn，obj拥有了执行fn函数的能力，并且this指向obj.</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = &#123; <span class="number">0</span>:<span class="string">'name'</span>, <span class="number">1</span>:<span class="string">'age'</span>, <span class="number">2</span>:<span class="string">'gender'</span> &#125;;</span><br><span class="line"></span><br><span class="line">fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">fn.call(obj, name, age, gender);</span><br></pre></td></tr></table></figure><ul><li>将类数组形式转换为数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments</span></span><br><span class="line"><span class="comment">// 返回值为数组，arguments保持不变</span></span><br><span class="line"><span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// nodeList</span></span><br><span class="line"><span class="keyword">var</span> nList = [].slice.call(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>));</span><br></pre></td></tr></table></figure><ul><li>方法借用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'joker'</span>,</span><br><span class="line">    showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    name: <span class="string">'rose'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.showName.call(bar); <span class="comment">// rose</span></span><br></pre></td></tr></table></figure><ul><li>在继承中的应用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inherit</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name:'</span>+<span class="keyword">this</span>.name+<span class="string">', age:'</span>+<span class="keyword">this</span>.age+<span class="string">', gender:.'</span>+<span class="keyword">this</span>.gender[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xm = <span class="keyword">new</span> Student(<span class="string">'xiaom'</span>, <span class="number">12</span>);</span><br><span class="line">xm.message(); <span class="comment">//name:undefined, age:undefined, gender:.man</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call/apply 可以改变函数的this指向。 除了传递参数时有所差别，call和apply作用完全一样。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解async/await</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/08/29/37async%20%E3%80%81await%E7%90%86%E8%A7%A3/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/08/29/37async 、await理解/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2019-01-10T08:01:59.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CallBacks"><a href="#CallBacks" class="headerlink" title="CallBacks"></a>CallBacks</h3><p>回调函数就是函数A作为参数传递给函数B，并且在未来某一个时间被调用。callback的异步模式最大的问题就是，理解困难加回调地狱（callback hell），看下面的代码的执行顺序：</p><pre><code>A();ajax(&apos;url1&apos;, function(){    B();    ajax(&apos;url2&apos;, function(){        C();    }    D();});E();</code></pre><p>其执行顺序为：A =&gt; E =&gt; B =&gt; D =&gt; C，这种执行顺序的确会让人头脑发昏，另外由于由于多个异步操作之间往往会耦合，只要中间一个操作需要修改，那么它的上层回调函数和下层回调函数都可能要修改，这就陷入了回调地狱。而 Promise 对象就很好的解决了异步操作之间的耦合问题，让我们可以用同步编程的方式去写异步操作。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 对象是一个构造函数，用来生成promise实例。Promise 代表一个异步操作，有三种状态：pending，resolved（异步操作成功由 pending 变为 resolved ），rejected（异步操作失败由 pending 变为 rejected ），一旦变为后两种状态将不会再改变。Promise 对象作为构造函数接受一个函数作为参数，而这个函数又接受 resolve 和 reject 两个函数做为参数，这两个函数是JS内置的，无需配置。resolve 函数在异步操作成功后调用，将pending状态变为resolved，并将它的参数传递给回调函数；reject 函数在异步操作失败时调用，将pending状态变为rejected，并将参数传递给回调函数。</p><ul><li>Promise.prototype.then()</li></ul><p>Promise构造函数的原型上有一个then方法，它接受两个函数作为参数，分别是 resolved 状态和 rejected 状态的回调函数，而这两个回调函数接受的参数分别是Promise实例中resolve函数和reject函数中的参数。 另外rejected状态的回调函数是可省略的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 一些异步操作</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">instance.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意Promise实例在生成后会立即执行，而 then 方法只有在所有同步任务执行完后才会执行，看看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async task begins!'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'done, pending -&gt; resolved!'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1.please wait'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2.please wait'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3.please wait'</span>);</span><br><span class="line"><span class="comment">// async task begins!</span></span><br><span class="line"><span class="comment">// 1.please wait</span></span><br><span class="line"><span class="comment">// 2.please wait</span></span><br><span class="line"><span class="comment">// 3.please wait</span></span><br><span class="line"><span class="comment">// done, pending -&gt; resolved!</span></span><br></pre></td></tr></table></figure><ul><li>链式调用 then 方法</li></ul><p>用 then 的链式写法，按顺序实现一系列的异步操作，这样就可以用同步编程的形式去实现异步操作，来看下面的例子，实现隔两秒打一次招呼：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(name);</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi(<span class="string">'张三'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好， <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> sayHi(<span class="string">'李四'</span>);    <span class="comment">// 最终 resolved 函数中的参数将作为值传递给下一个then</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// name 是上一个then传递出来的参数</span></span><br><span class="line">  .then(<span class="function"><span class="params">name</span> =&gt;</span> &#123;                </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好， <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> sayHi(<span class="string">'王二麻子'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好， <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 你好， 张三</span></span><br><span class="line"><span class="comment">// 你好， 李四</span></span><br><span class="line"><span class="comment">// 你好， 王二麻子</span></span><br></pre></td></tr></table></figure><p>可以看到使用链式then的写法，将异步操作变成了同步的形式，但是也带来了新的问题，就是异步操作变成了很长的then链，新的解决方法就是Generator，这里跨过它直接说它的语法糖：async/await。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><ul><li>async</li></ul><p>async/await实际上是Generator的语法糖。顾名思义，async关键字代表后面的函数中有异步操作，await表示等待一个异步方法执行完成。声明异步函数只需在普通函数前面加一个关键字async即可，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>async 函数返回一个Promise对象（如果指定的返回值不是Promise对象，也返回一个Promise，只不过立即 resolve ，处理方式同 then 方法），因此 async 函数通过 return 返回的值，会成为 then 方法中回调函数的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcA().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// hello!</span></span><br></pre></td></tr></table></figure><p>单独一个 async 函数，其实与Promise执行的功能是一样的，来看看 await 都干了些啥。</p><ul><li>await</li></ul><p>顾名思义， await 就是异步等待，它等待的是一个Promise，因此 await 后面应该写一个Promise对象，如果不是Promise对象，那么会被转成一个立即 resolve 的Promise。 async 函数被调用后就立即执行，但是一旦遇到 await 就会先返回，等到异步操作执行完成，再接着执行函数体内后面的语句。总结一下就是：async函数调用不会造成代码的阻塞，但是await会引起async函数内部代码的阻塞。看看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async function is running!'</span>);</span><br><span class="line">  <span class="keyword">const</span> num1 = <span class="keyword">await</span> <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`num1 is <span class="subst">$&#123;num1&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> num2 = <span class="keyword">await</span> num1+ <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`num2 is <span class="subst">$&#123;num2&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> num3 = <span class="keyword">await</span> num2 + <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`num3 is <span class="subst">$&#123;num3&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'run me before await!'</span>);</span><br><span class="line"><span class="comment">// async function is running!</span></span><br><span class="line"><span class="comment">// run me before await!</span></span><br><span class="line"><span class="comment">// num1 is 200</span></span><br><span class="line"><span class="comment">// num2 is 300</span></span><br><span class="line"><span class="comment">// num3 is 400</span></span><br></pre></td></tr></table></figure><p><strong> 值得注意的是， await 后面的 Promise 对象不总是返回 resolved 状态，只要一个 await 后面的Promise状态变为 rejected ，整个 async 函数都会中断执行，为了保存错误的位置和错误信息，我们需要用 try…catch 语句来封装多个 await 过程，如下： </strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num1 = <span class="keyword">await</span> <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`num1 is <span class="subst">$&#123;num1&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> num2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'num2 is wrong!'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`num2 is <span class="subst">$&#123;num2&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> num3 = <span class="keyword">await</span> num2 + <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`num3 is <span class="subst">$&#123;num3&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"><span class="comment">// num1 is 200</span></span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// num2 is wrong!</span></span><br></pre></td></tr></table></figure><p>如上所示，在 num2 处 await 得到了一个状态为 rejected 的Promise对象，该错误会被传递到 catch 语句中，这样我们就可以定位错误发生的位置。</p><ul><li>async/await比Promise强在哪儿？</li></ul><p>接下来我们用async/await改写一下Promise章节中关于sayHi的一个例子，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolved(name);</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHi_async</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sayHi_1 = <span class="keyword">await</span> sayHi(name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`你好， <span class="subst">$&#123;sayHi_1&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> sayHi_2 = <span class="keyword">await</span> sayHi(<span class="string">'李四'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`你好， <span class="subst">$&#123;sayHi_2&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> sayHi_3 = <span class="keyword">await</span> sayHi(<span class="string">'王二麻子'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`你好， <span class="subst">$&#123;sayHi_3&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi_async(<span class="string">'张三'</span>)</span><br><span class="line"><span class="comment">// 你好， 张三</span></span><br><span class="line"><span class="comment">// 你好， 李四</span></span><br><span class="line"><span class="comment">// 你好， 王二麻子</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CallBacks&quot;&gt;&lt;a href=&quot;#CallBacks&quot; class=&quot;headerlink&quot; title=&quot;CallBacks&quot;&gt;&lt;/a&gt;CallBacks&lt;/h3&gt;&lt;p&gt;回调函数就是函数A作为参数传递给函数B，并且在未来某一个时间被调用。callback
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VUE动态绑定audio/video的src不能播放</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/08/08/20video%E7%9A%84src%E4%B8%8D%E8%83%BD%E6%92%AD%E6%94%BE/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/08/08/20video的src不能播放/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-01-10T08:11:20.147Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写个项目，要求要本地上传音视频至服务器，再回显可播放。心想这简单啊，直接vue双向绑定不就轻松解决，没想到遇到个大坑~</p><pre><code>&lt;audio controls&gt;&lt;source :src=&quot;audio_url&quot;&gt;您的浏览器不支持 audio 元素。&lt;/audio&gt;this.audio_url = res.data.audio_url</code></pre><p>结果音频并不能播放，于是就找度娘，很多说赋值完成后要重新用js控制播放器播放，像这样。。</p><pre><code>let dom = document.getElementById(&apos;audio&apos;);dom.play();</code></pre><p>亲自尝试，并没有效果</p><p>最终想到了VUE的$refs特性，不了解的同学自己去VUE看文档</p><p>给audio绑定个ref值</p><pre><code>&lt;audio ref=&apos;audio&apos; controls&gt;    您的浏览器不支持 audio 元素。&lt;/audio&gt;</code></pre><p>在需要动态绑定的方法里用$refs动态设置src</p><pre><code>this.$refs.audio.src = res.data.audio_url</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天写个项目，要求要本地上传音视频至服务器，再回显可播放。心想这简单啊，直接vue双向绑定不就轻松解决，没想到遇到个大坑~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;audio controls&amp;gt;
&amp;lt;source :src=&amp;quot;audio_url&amp;quot
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/23/41%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/23/41性能优化方式/</id>
    <published>2018-06-22T16:00:00.000Z</published>
    <updated>2019-01-10T08:02:58.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从服务渲染过程谈性能优化"><a href="#从服务渲染过程谈性能优化" class="headerlink" title="从服务渲染过程谈性能优化"></a>从服务渲染过程谈性能优化</h1><p>本文将结合从在浏览器输入url，到展示最终页面的过程来对其进行一步步分析，并将在web 中的实际应用实践进行总结。</p><h3 id="模式-1-前后分离"><a href="#模式-1-前后分离" class="headerlink" title="模式 1 - 前后分离"></a>模式 1 - 前后分离</h3><p>从用户输入 url　到展示最终页面的过程，这种模式可简单的分为以下 5 部分</p><p>1、用户输入 url，开始拉取静态页面<br>2、静态页面加载完成后，解析文档标签，并开始拉取 CSS （一般 CSS 放于头部）<br>3、接着拉取 JS 文件（一般 JS 文件放于尾部）<br>4、当 JS 加载完成，便开始执行 JS 内容，发出请求并拿到数据<br>5、将数据与资源渲染到页面上，得到最终展示效果</p><p>具体流程图如下</p><p><img src="/../about/qg6ngypp8w.png" alt=""></p><p>这种处理形式应该占据大多数，然而也很容易发现一个问题就是<strong>请求数多，前后依赖大</strong>，如必须等待 JS 加载完成后执行时才会发起 数据请求，等待数据回来用户才可以展示最终页面，这种强依赖的关系使得整个应用的首屏渲染耗时增加不少。</p><h3 id="模式-2-数据直出"><a href="#模式-2-数据直出" class="headerlink" title="模式 2 - 数据直出"></a>模式 2 - 数据直出</h3><blockquote><p>数据请求在server端上提前获取，并和html一同返回，页面模板和数据的渲染在浏览器端上执行</p></blockquote><p>在模式 1 中，第 1 点用户输入 url 时 server 端不做其他处理直接返回 html ，在第 4 点向 server 请求获取数据。那么，同样都是向 server 请求获取，如果在第 1 点中将请求数据放在 server 上，将拿到的数据拼接到 HTML 上一并返回，那么可减少在前端页面上的一次数据请求时间。 这就是模式 2 - 数据直出所做的事，处理方式也很简单</p><p>1、用户输入 url ，在 server 返回 HTML 前去请求获取页面需要的数据<br>2、将数据拼接到 HTML 上 并 一起返回给前端（可以插入 script 标签将数据添加到全局变量上，或放到某个标签的 data 属性中，如 ）<br>3、在前端的JS代码中判断是否已在服务端拿到数据，直接拿该数据进行渲染页面，不再做数据请求</p><p>具体可下面的流程图看出这种模式下</p><p><img src="/../about/xingneng2.png" alt=""></p><p>这种模式与模式1 相比，减少了这两种模式请求数据的耗时差距。这块差距有多少呢？</p><h4 id="发起一个-HTTP-的网络请求过程"><a href="#发起一个-HTTP-的网络请求过程" class="headerlink" title="发起一个 HTTP 的网络请求过程"></a>发起一个 HTTP 的网络请求过程</h4><pre><code>DNS解析（100~200ms可以缓存）        |        |        建立TCP链接 (三次握手100~200ms )                |                |            HTTP Request( 半个RTT )                 |                |            HTTP Response( RTT 不确定优化空间 )</code></pre><p>注: RTT 为 Round-trip time 缩写，表示一个数据包从发出到返回所用的时间。</p><h4 id="HTTP-请求在前后端发出，差距有多少？"><a href="#HTTP-请求在前后端发出，差距有多少？" class="headerlink" title="HTTP 请求在前后端发出，差距有多少？"></a>HTTP 请求在前后端发出，差距有多少？</h4><p>由上面对 HTTP 的网络请求过程可看到建立一次完整的请求返回在耗时上明显的，特别是外网用户在进行 HTTP 请求时，由于网络等因素的影响，在网络连接及传输上将花费很多时间。而在服务端进行数据拉取，即使同样是 HTTP 请求，由于后端之间是处于同一个内网上的，所以传输十分高效，这是差距来源的大头，是优化的刚需。</p><h3 id="模式-3-直出-服务端渲染"><a href="#模式-3-直出-服务端渲染" class="headerlink" title="模式 3 - 直出 (服务端渲染)"></a>模式 3 - 直出 (服务端渲染)</h3><blockquote><p>数据请求在server端上提前获取，页面模板结合数据的渲染处理也在server上完成，输出最终 HTML</p></blockquote><p>模式 2 中将依赖于JS文件加载回来才能去发起的数据请求挪到 server 中，数据随着 HTML 一并返回。然后等待 JS 文件加载完成，JS 将服务端已给到的数据与HTML结合处理，生成最终的页面文档。</p><p>数据请求能放到 server 上，对于数据与HTML结合处理也可以在server上做，从而减少等待 JS 文件的加载时间。 这就是模式3 - 直出 (服务端渲染)，主要处理如下</p><p>1、server 上获取数据并将数据与页面模板结合，在服务端渲染成最终的 HTML<br>2、返回最终的 HTML 展示</p><p>可以从下图看出，页面的首屏展示不再需要等待 JS 文件回来，优化减少了这块时间</p><p><img src="/../about/1c5f64bc-29a7-11e6-800a-bd8b4af30b0f.png" alt=""></p><p>通过以上模式，将模式 1 - 常用模式中的第 3 和 4 点耗时进行了优化，那么可以再继续优化吗？在页面文档不大情况下，可将CSS内联到HTML中，这是优化请求量的做法。直出稍微不同的是需要考虑的是服务端最终渲染出来的文档的大小，在范围内也可将 CSS 文件内联到 HTML 中。这样的话，便优化了 CSS 的获取时间，如下图</p><p><img src="/../about/2b09bc10-29a7-11e6-8fa9-6dc12579b1aa.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>直出能够将常用模式优化到剩下了一次 HTML 请求，加快首屏渲染时间，使用服务端渲染，还能够优化前端渲染难以克服的 SEO 问题。而不管是简单的 数据直出 或是 服务端渲染直出 都能使页面的性能优化得到较大提高，以下将从实际应用中进行说明。</p><h1 id="从输入URL过程谈性能优化"><a href="#从输入URL过程谈性能优化" class="headerlink" title="从输入URL过程谈性能优化"></a>从输入URL过程谈性能优化</h1><pre><code>  1、用户输入网址（假设是个 HTML 页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回 HTML 文件； （善用缓存，减少HTTP请求，减轻服务器压力） 2. 浏览器载入 HTML 代码，发现 &lt;head&gt; 内有一个 &lt;link&gt; 引用外部 CSS 文件,则浏览器立即发送CSS文件请求，获取浏览器返回的CSS文件；  （CSS文件合并，减少HTTP请求） 3. 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； （CSS文件需要放置最上面，避免网页重新渲染） 4. 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； （图片文件合并，减少HTTP请求） 5. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；（最好图片都设置尺寸，避免重新渲染） 6. 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，会立即运行该js代码；（script最好放置页面最下面）                    7. js脚本执行了语句，它令浏览器隐藏掉代码中的某个 &lt;div&gt;,突然就少了一个元素，浏览器不得不重新渲染这部分代码； （页面初始化样式不要使用js控制）    8. 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面…… 9. 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 &lt;link&gt; 标签的 CSS 路径；10. 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</code></pre><h1 id="从渲染DOM树过程谈性能优化"><a href="#从渲染DOM树过程谈性能优化" class="headerlink" title="从渲染DOM树过程谈性能优化"></a>从渲染DOM树过程谈性能优化</h1><p><strong>reflow(回流)</strong></p><p> 说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染， 该过程称为reflow（回流）。</p><p>  reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p><p><strong>repaint(重绘)</strong></p><p>如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow（在IE下需要换一下说法，reflow 要比 repaint 更缓慢）。尽量避免reflow(回流)  ，reflow(回流)是导致DOM脚本执行低效的关键因素之一。页面上任何一个结点触发reflow，都会导致它的子结点及祖先结点重新渲染。</p><blockquote><p>在哪些情况下会导致reflow发生：</p></blockquote><pre><code> 改变窗囗大小 改变文字大小 添加/删除样式表内容的改变，如用户在输入框中敲字激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活)操作class属性脚本操作DOM计算offsetWidth和offsetHeight设置style属性性</code></pre><p> 那么为了减少回流要注意哪些方式呢？      </p><p>1.不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸</p><p>2.尽量通过class来设计元素样式，切忌用style</p><pre><code>var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; //  再一次的 reflow 和 repaintbstyle.color = &quot;blue&quot;; // repaintbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint// new DOM element - reflow, repaintdocument.body.appendChild(document.createTextNode(&apos;dude!&apos;));</code></pre><p>对上面代码优化：</p><pre><code>.b-class{　　padding:20px;　　color:blue;　　border:10px solid red;　　background-color:#fad;　　font-size:2em;}$div.addClass(&quot;b-class&quot;);</code></pre><p>3.实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute</p><p>4.权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。</p><p>5.不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，</p><p>6.这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p><p>7.css里不要有表达式expression</p><p>8.减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</p><p>9.避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</p><p>10.尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。</p><pre><code>在div.first里面加入div.second,在div.second里面加入div.third:        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $(div.first).append($divS));//reflow        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);//reflow优化代码：        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);        $(div.first).append($divS));//reflow或者：        var $divF = $(div.first);        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $divS.hide();        $(div.first).append($divS));        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);        $divS.show();//reflow  </code></pre><p>11.请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。</p><p>如果我们要经常去获取和操作这些值，则可以先将这些值缓存起来例如：</p><pre><code>var windowHeight = window.innerHeight;//reflowfor(i=0;i&lt;10;i++){     $body.height(windowHeight++);   　一系列关于windowHeight的操作....... }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从服务渲染过程谈性能优化&quot;&gt;&lt;a href=&quot;#从服务渲染过程谈性能优化&quot; class=&quot;headerlink&quot; title=&quot;从服务渲染过程谈性能优化&quot;&gt;&lt;/a&gt;从服务渲染过程谈性能优化&lt;/h1&gt;&lt;p&gt;本文将结合从在浏览器输入url，到展示最终页面的过程来对其进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>与原生交互的常见方式</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/11/44%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/11/44与原生交互的常见方式/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2019-01-10T08:07:28.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="返回交互"><a href="#返回交互" class="headerlink" title="返回交互"></a>返回交互</h4><pre><code>back: function() {    // IOS        try {            window.webkit.messageHandlers.back.postMessage({ back:0 });        } catch (error) { }        // 安卓        try {        window.NativeJavaScriptInterface.back({back:1});        } catch (err) {}}</code></pre><h4 id="获取token（由于网关问题，需要部署才能写入请求header的token）"><a href="#获取token（由于网关问题，需要部署才能写入请求header的token）" class="headerlink" title="获取token（由于网关问题，需要部署才能写入请求header的token）"></a>获取token（由于网关问题，需要部署才能写入请求header的token）</h4><pre><code>// ios    window.getToken = (token) =&gt; {    //全局写入请求头    http.setRequestHeader({&quot;Authorization&quot;:token});    axios.create({        headers:{ &quot;Authorization&quot;:token }    })    }// 安卓获取tokentry {    var token=  window.NativeJavaScriptInterface.getToken();    //全局写入请求头    http.setRequestHeader({&quot;Authorization&quot;:token});    axios.create({        headers:{ &quot;Authorization&quot;:token }    })} catch (err) {}</code></pre><h4 id="跟原生交互事件（orderInfo是事件名称需要和原生开发协定，-sourceType-1-orderId-orderId-是回调给原生参数）"><a href="#跟原生交互事件（orderInfo是事件名称需要和原生开发协定，-sourceType-1-orderId-orderId-是回调给原生参数）" class="headerlink" title="跟原生交互事件（orderInfo是事件名称需要和原生开发协定，{ sourceType:1,orderId:orderId }是回调给原生参数）"></a>跟原生交互事件（orderInfo是事件名称需要和原生开发协定，{ sourceType:1,orderId:orderId }是回调给原生参数）</h4><pre><code>// ios try {   window.webkit.messageHandlers.orderInfo.postMessage({ sourceType:1,orderId:orderId }); } catch (error) { } //安卓  try { window.NativeJavaScriptInterface.orderInfo(&apos;1&apos;,orderId); } catch (err) {}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;返回交互&quot;&gt;&lt;a href=&quot;#返回交互&quot; class=&quot;headerlink&quot; title=&quot;返回交互&quot;&gt;&lt;/a&gt;返回交互&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;back: function() {
    // IOS
        try {
          
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 基础命令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/19/6Linux%20%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/19/6Linux 基础命令/</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2019-01-10T08:11:03.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><pre><code>创建目录 mkdir &lt;目录名称&gt;删除目录 rm &lt;目录名称&gt;定位目录 cd &lt;目录名称&gt;查看目录文件 ls ll修改目录名 mv &lt;目录名称&gt; &lt;新目录名称&gt;拷贝目录 cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>创建文件 touch &lt;文件名称&gt; vi &lt;文件名称&gt;删除文件 rm &lt;文件名称&gt;修改文件名 mv &lt;文件名称&gt; &lt;新文件名称&gt;拷贝文件 cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></pre><h2 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h2><pre><code>查看文件 cat &lt;文件名称&gt; head &lt;文件名称&gt; tail &lt;文件名称&gt;编辑文件内容 vi &lt;文件名称&gt;查找文件内容 grep &apos;关键字&apos; &lt;文件名称&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;创建目录 mkdir &amp;lt;目录名称&amp;gt;
删除目录 rm &amp;lt;目录名称&amp;gt;
定位目录 cd &amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于gulp的前端脚手架</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/02/12%E5%9F%BA%E4%BA%8Egulp%E7%9A%84%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/02/12基于gulp的前端脚手架/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2019-01-10T08:10:52.287Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到gulp和webpack各种脚手架，这次来入门下这二种脚手架。</p><h2 id="Gulp快速入门"><a href="#Gulp快速入门" class="headerlink" title="Gulp快速入门"></a>Gulp快速入门</h2><p>首先确保本地已安装node.js和npm<br>然后通过npm全局安装gulp</p><pre><code>$ npm install -g gulp   </code></pre><p>根据不同项目的要求，可选择适合的gulp插件进行后续开发。如果项目的要求基本相似（如小型的活动运营H5，平台页面等）可建立自己的脚手架工具以便于后续快速开发。</p><h3 id="搭建脚手架"><a href="#搭建脚手架" class="headerlink" title="搭建脚手架"></a>搭建脚手架</h3><p>1、首先在项目根目录下通过命令行安装项目依赖</p><pre><code>$ npm install --save-dev gulp</code></pre><p>2、在项目根目录下新建文件gulpfile.js。要想完成相关插件的配置，首先需要了解gulp相关方法</p><pre><code>gulp只有五个方法： task run watch src desttask 这个API用来创建任务，在命令行下可以输入 gulp test 来执行test的任务。run 这个API用来运行任务watch 这个API用来监听任务。src 这个API设置需要处理的文件的路径，可以是多个文件以数组的形式[main.scss,vender.scss]，也可以是正则表达式/*/ .scss。 dest 这个API设置生成文件的路径，一个任务可以有多个生成路径，一个可以输出未压缩的版本，另一个可以输出压缩后的版本。其实整个gulp的配置文件，基本上都是在做一些任务的配置，比如创建任务，监听任务等等。</code></pre><h3 id="基于脚手架进行开发"><a href="#基于脚手架进行开发" class="headerlink" title="基于脚手架进行开发"></a>基于脚手架进行开发</h3><p>1、拷贝package.json和gulpfile.js到相印项目根目录下，使用以下命令安装各插件</p><pre><code>$ npm install</code></pre><p>2、在根目录下键入相印命令进行所需的操作，如</p><pre><code>$ gulp</code></pre><h3 id="基本设定"><a href="#基本设定" class="headerlink" title="基本设定"></a>基本设定</h3><p>先大致地梳理一遍我们想要的功能和一些前提的设定。</p><p>1、脚手架自动化工具基于Gulp</p><p>2、基本的Task</p><pre><code>初始化目录结构初始化Index文件结构（迭代时可考虑基于Mobile OR PC）Sass自动编译CSS AutoPrefixer监听文件，自动刷新合并雪碧图</code></pre><h3 id="编写自己的Gulpfile-js"><a href="#编写自己的Gulpfile-js" class="headerlink" title="编写自己的Gulpfile.js"></a>编写自己的Gulpfile.js</h3><p>有了上面的基本约束后，现在建立自己的gulpfile文件，这里会详细记录每一个task的配置和使用。</p><p>首先把package.json和gulpfile.js建立起来</p><p>使用 npm init 初始化package.json（可一直按回车，或填写一些基本信息）。使用 npm install –save-dev gulp 使用gulp作为项目依赖</p><p>安装所需插件以及gulpfile.js的task配置</p><h4 id="初始化目录与文件"><a href="#初始化目录与文件" class="headerlink" title="初始化目录与文件"></a>初始化目录与文件</h4><p>首先需要初始化目录结构，这里使用fs-extra</p><p>使用以下命令进行安装 （后续的插件安装不再赘述，大家可从npmjs处查找相印的安装以及Api）</p><pre><code>npm install --save fs-extra</code></pre><p>先看一眼我们需要生成的目录结构</p><pre><code>├── dist # 编译后的文件    ├── html        └── index.html # home    ├── css    ├── js    └── img├── src     ├── img    ├── sprite    ├── pics    ├── js    └── sass        └── style.scss├── psd</code></pre><p>写入gulpfile.js</p><pre><code>var gulp = require(&apos;gulp&apos;);// 引入组件var path   = require(&apos;path&apos;), // node自带组件    fse    = require(&apos;fs-extra&apos;); // 通过npm下载// 获取当前文件路径var PWD = process.env.PWD || process.cwd(); // 兼容windowsgulp.task(&apos;init&apos;, function() {    var dirs = [&apos;dist&apos;,&apos;dist/html&apos;,&apos;dist/css&apos;,&apos;dist/img&apos;,&apos;dist/js&apos;,&apos;src&apos;,&apos;src/sass&apos;,&apos;src/js&apos;,&apos;src/img&apos;,&apos;src/pic&apos;,&apos;src/sprite&apos;,&apos;psd&apos;];    dirs.forEach(function (item,index) {        // 使用mkdirSync方法新建文件夹        fse.mkdirSync(path.join(PWD + &apos;/&apos;+ item));    })    // 往index里写入的基本内容    var template = &apos;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;/&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;;    fse.writeFileSync(path.join(PWD + &apos;/dist/html/index.html&apos;), template);    fse.writeFileSync(path.join(PWD + &apos;/src/sass/style.scss&apos;), &apos;@charset &quot;utf-8&quot;;&apos;);})</code></pre><p>此时运行$ gulp init发现目录已经生成完成了。再对index.html里的内容用编辑器的插件格式化一下，进入下一步。</p><h3 id="编译-sass以及为某些属性添加适当的前缀"><a href="#编译-sass以及为某些属性添加适当的前缀" class="headerlink" title="编译.sass以及为某些属性添加适当的前缀"></a>编译.sass以及为某些属性添加适当的前缀</h3><p>添加对sass编译的支持 安装插件gulp-sass。在gulpfile写入</p><pre><code>// 编译sassvar sass = require(&apos;gulp-sass&apos;);gulp.task(&apos;sass&apos;, function () {return gulp    // 在src/sass目录下匹配所有的.scss文件    .src(&apos;src/sass/**/*.scss&apos;)    // 基于一些配置项 运行sass()命令    .pipe(sass({        errLogToConsole: true,        outputStyle: &apos;expanded&apos;    }).on(&apos;error&apos;, sass.logError))    // 输出css    .pipe(gulp.dest(&apos;dist/css&apos;));});</code></pre><p>这时候在命令行敲入$ gulp sass发现已经跑起来了，但是存在两个问题</p><pre><code>每次修改完sass文件后都需要输入命令若sass有书写错误会直接退出gulp监听</code></pre><p>这两个问题我们放到最后再一起解决。</p><p>下面来为我们写的css的某些不兼容属性添加前缀。这里用到了插件gulp-autoprefixer，看一眼代码。其实都大同小异，大致的内容可在npmjs内查找到。</p><pre><code>var autoprefix = require(&apos;gulp-autoprefixer&apos;);gulp.task(&apos;autoprefixer&apos;, function () {return gulp.src(&apos;dist/css/**/*.css&apos;)    .pipe(autoprefixer({        browsers: [&apos;ios 5&apos;,&apos;android 2.3&apos;],        cascade: false    }))    .pipe(gulp.dest(&apos;dist/css&apos;));});</code></pre><p>下面测试一下，在scss写入一个css3属性</p><pre><code>perspective: 500;</code></pre><p>输入命令 $ gulp autoprefixer 发现文件没有更改。原因是sass文件还未被编译，这时候需要先敲一遍$ gulp sass编译。这时会发现css已经被添加了相印的后缀了</p><p><img src="/../about/1.png" alt="1111"></p><h4 id="开启服务器以及监听编译"><a href="#开启服务器以及监听编译" class="headerlink" title="开启服务器以及监听编译"></a>开启服务器以及监听编译</h4><p>终于到配置的最后一步了，我们的想法是当sass、js、html有所更改时都执行相印的命令。<br>如 自动压缩、合并文件、添加前缀、刷新浏览器</p><p>这里选用browser-sync同时我想当sass、sprite等文件改变时自动执行所需的task，使用watch命令对文件进行监听。话不多说，还是看源码。</p><pre><code>//=======================//     服务器 + 监听//=======================var browserSync = require(&apos;browser-sync&apos;).create();gulp.task(&apos;default&apos;, function() {    // 监听重载文件    var files = [    &apos;dist/html/**/*.html&apos;,    &apos;dist/css/**/*.css&apos;,    &apos;src/js/**/*.js&apos;,    &apos;src/sprite/**/*.png&apos;    ]    browserSync.init(files, {    server: {            baseDir: &quot;./&quot;,            directory: true        },    open: &apos;external&apos;,    startPath: &quot;dist/html/&quot;    });    // 监听编译文件    gulp.watch(&quot;dist/html/**/*.html&quot;).on(&apos;change&apos;, browserSync.reload);    gulp.watch(&quot;src/sass/**/*.scss&quot;, [&apos;sass&apos;]);    gulp.watch(&quot;src/sprite/**/*.png&quot;, [&apos;sprite&apos;]);    gulp.watch(&quot;dist/css/**/*.css&quot;, [&apos;autoprefixer&apos;]);});</code></pre><p>在命令行输入 $ gulp 这时我们的项目已经妥妥地跑起来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到gulp和webpack各种脚手架，这次来入门下这二种脚手架。&lt;/p&gt;
&lt;h2 id=&quot;Gulp快速入门&quot;&gt;&lt;a href=&quot;#Gulp快速入门&quot; class=&quot;headerlink&quot; title=&quot;Gulp快速入门&quot;&gt;&lt;/a&gt;Gulp快速入门&lt;/h2&gt;&lt;p&gt;首先确
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端自动化构建环境的搭建</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/01/28%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/01/28前端自动化环境构建/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2019-01-10T08:11:48.298Z</updated>
    
    <content type="html"><![CDATA[<p>Web前端使用工程化方式构建；</p><p>   目前需要一些简单的功能：</p><pre><code>1. 版本控制6. 编译SASS2. 检查JS3. 图片合并4. 压缩CSS5. 压缩JS</code></pre><p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p><p>目前最知名的构建工具： Gulp、Grunt、NPM + Webpack；</p><pre><code>grunt是前端工程化的先驱gulp更自然基于流的方式连接任务Webpack最年轻，擅长用于依赖管理，配置稍较复杂推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件</code></pre><h3 id="Use-Gulp-to-automate-front-end-build-tasks"><a href="#Use-Gulp-to-automate-front-end-build-tasks" class="headerlink" title="Use Gulp to automate front-end build tasks"></a>Use Gulp to automate front-end build tasks</h3><p>Gulp是基于 Node.js的，需要要安装 Node.js</p><p>1、为了确保依赖环境正确，我们先执行几个简单的命令检查。</p><pre><code>node -vNode是一个基于Chrome JavaScript V8引擎建立的一个解释器检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号</code></pre><p>2、接下来看看npm，它是 node 的包管理工具，可以利用它安装 gulp 所需的包</p><pre><code>npm -v这同样能得到npm的版本号，装 Node 时已经自动安装了npm</code></pre><p>3、开始安装Gulp</p><pre><code>npm install -g gulp全局安装 gulpgulp -v得到gulp的版本号，确认安装成功</code></pre><p>基础安装结束<br>-</p><p>4、切换到你的在项目根文件夹下，运行</p><pre><code>npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下</code></pre><p>5、安装gulp功能插件依赖包</p><pre><code>npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev</code></pre><blockquote><p>gulp功能模块的文件会放在项目所在的目录的./node_modules 下</p></blockquote><p>6、我们目前先使用一些简单的功能：</p><pre><code>- 检查Javascript- 编译Sass文件- 合并Javascript- 压缩合并并重命名Javascript</code></pre><blockquote><p>新建gulpfile.js 配置文件放在项目根目录下</p></blockquote><pre><code>演示项目目录结构   testProject        (项目名称)   |–.git             通过git进行版本控制,项目自动生成这个文件   |–node_modules     组件包目录   |–dist             **发布环境**（编译自动生成的）       |–css         样式文件(style.css style.min.css)       |–images     图片文件(压缩图片\合并后的图片)       |–js         js文件(main.js main.min.js)       |–index.html  静态页面文件(压缩html)   |–src             **开发环境**       |–sass                sass文件       |–images               图片文件       |–js                  js文件       |–index.html         静态文件   |–gulpfile.js              gulp配置文件   |–package.json             依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序</code></pre><blockquote><p>现在，项目文件夹都建好，组件也安装完毕了，我们需要编写gulpfile.js文件以指定gulp需要为我们完成什么任务。</p></blockquote><pre><code>gulpfile.js内容如下：// 引入gulpvar gulp = require(&apos;gulp&apos;);// 引入组件var jshint = require(&apos;gulp-jshint&apos;);//检查jsvar sass   = require(&apos;gulp-sass&apos;);    //编译Sassvar concat = require(&apos;gulp-concat&apos;);//合并var uglify = require(&apos;gulp-uglify&apos;);//uglify 组件（用于压缩 JS）var rename = require(&apos;gulp-rename&apos;);//重命名// 检查js脚本的任务gulp.task(&apos;lint&apos;, function() {    gulp.src(&apos;./js/*.js&apos;) //可配置你需要检查脚本的具体名字。        .pipe(jshint())        .pipe(jshint.reporter(&apos;default&apos;));});// 编译Sassgulp.task(&apos;sass&apos;, function() {    gulp.src(&apos;./scss/*.scss&apos;)        .pipe(sass())        .pipe(gulp.dest(&apos;./css&apos;));//dest()写入文件});// 合并，压缩js文件// 找到 js/ 目录下的所有 js 文件，压缩，重命名，最后将处理完成的js存放在 dist/js/ 目录下gulp.task(&apos;scripts&apos;, function() {    gulp.src(&apos;./js/*.js&apos;)        .pipe(concat(&apos;all.js&apos;))        .pipe(gulp.dest(&apos;./dist&apos;))        .pipe(rename(&apos;all.min.js&apos;))        .pipe(uglify())        .pipe(gulp.dest(&apos;./dist&apos;));        console.log(&apos;gulp task is done&apos;);//自定义提醒信息});.... // 其他任务类似// 定义默认任务,执行gulp会自动执行的任务gulp.task(&apos;default&apos;, function(){    gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;);    // 监听js文件变化，当文件发生变化后会自动执行任务    gulp.watch(&apos;./js/*.js&apos;, function(){        gulp.run(&apos;lint&apos;,&apos;scripts&apos;);    });});</code></pre><p>7、现在，回到命令行窗口，可以直接运行gulp任务了。</p><pre><code>gulp这将执行定义的default任务，就和以下的命令式同一个意思gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务：gulp sass</code></pre><p>8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心</p><pre><code>常见提醒：1.禁止在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre><p>9、gulp的插件数量很多，后面还可以根据自己的需要进行添加任务</p><pre><code>常用的gulp插件参考gulp-imagemin:         压缩图片gulp-ruby-sass:     支持sass，安装此版本需要安装rubygulp-minify-css:     压缩cssgulp-jshint:          检查jsgulp-uglify:          压缩jsgulp-concat:        合并文件gulp-rename:          重命名文件gulp-htmlmin:         压缩htmlgulp-clean:          清空文件夹gulp-livereload:     服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr）</code></pre><p>补充：ZSmart UED Team 的前端开发软件环境 (Windows, Linux, Mac OS X)</p><pre><code>安装Node.Js、NPM、Ruby、Java 基础环境Sublime Text3 + 插件           用于编写前端代码Google chrome 、Mozilla Firefox + FirebugInternet Explorer             进行兼容测试和预览页面UI、动画效果和交互功能Node.js+Gulp                 进行前端自动化构建、JS语法验证、CSS压缩，图片压缩等；Koala                         实时编译Less、Sass、Compass、CoffeeScript;Github                         存储自己的代码库 、git或SVN用于版本控制和团队Code ReviewTomcat、DedeAMPZ、MAMP      进行简单运行环境演示Photoshop CC 切图 + Sprites 合并小图标XMind                         画出清晰的工作或业务逻辑思维图</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web前端使用工程化方式构建；&lt;/p&gt;
&lt;p&gt;   目前需要一些简单的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 版本控制
6. 编译SASS
2. 检查JS
3. 图片合并
4. 压缩CSS
5. 压缩JS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些都是每个Web项目在构建、开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue项目实现记住密码到cookie功能</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/01/21vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%88%B0cookie%E5%8A%9F%E8%83%BD/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/01/21vue项目实现记住密码到cookie功能/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2019-01-10T08:07:21.062Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/1/30/161462f165cc17dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="效果图"></p><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h3><p>1.记住密码勾选，点登陆时，将账号和密码保存到cookie，下次登陆自动显示到表单内 2.不勾选，点登陆时候则清空之前保存到cookie的值，下次登陆需要手动输入</p><blockquote><p>大体思路就是通过存/取/删cookie实现的；每次进入登录页，先去读取cookie，如果浏览器的cookie中有账号信息，就自动填充到登录框中，存cookie是在登录成功之后，判断当前用户是否勾选了记住密码，如果勾选了，则把账号信息存到cookie当中，效果图如上：</p></blockquote><p>html代码</p><pre><code>&lt;div class=&quot;ms-login&quot;&gt;        &lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;0px&quot; class=&quot;demo-ruleForm&quot;&gt;            &lt;el-form-item prop=&quot;username&quot;&gt;                &lt;el-input v-model=&quot;ruleForm.username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;password&quot;&gt;                &lt;el-input type=&quot;password&quot; placeholder=&quot;密码&quot; v-model=&quot;ruleForm.password&quot; @keyup.enter.native=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;!-- `checked` 为 true 或 false --&gt;            &lt;el-checkbox v-model=&quot;checked&quot;&gt;记住密码&lt;/el-checkbox&gt;            &lt;br&gt;            &lt;br&gt;            &lt;div class=&quot;login-btn&quot;&gt;                &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;登录&lt;/el-button&gt;            &lt;/div&gt;        &lt;/el-form&gt;&lt;/div&gt;</code></pre><p>js代码</p><pre><code>//页面加载调用获取cookie值    mounted() {        this.getCookie();    },    methods: {        submitForm(formName) {             const self = this;            //判断复选框是否被勾选 勾选则调用配置cookie方法            if (self.checked == true) {                console.log(&quot;checked == true&quot;);                //传入账号名，密码，和保存天数3个参数                self.setCookie(self.ruleForm.username, self.ruleForm.password, 7);            }else {              console.log(&quot;清空Cookie&quot;);              //清空Cookie              self.clearCookie();            }            //与后端请求代码，本功能不需要与后台交互所以省略            console.log(&quot;登陆成功&quot;);    });},//设置cookiesetCookie(c_name, c_pwd, exdays) {    var exdate = new Date(); //获取时间    exdate.setTime(exdate.getTime() + 24 * 60 * 60 * 1000 * exdays); //保存的天数    //字符串拼接cookie    window.document.cookie = &quot;userName&quot; + &quot;=&quot; + c_name + &quot;;path=/;expires=&quot; + exdate.toGMTString();    window.document.cookie = &quot;userPwd&quot; + &quot;=&quot; + c_pwd + &quot;;path=/;expires=&quot; + exdate.toGMTString();},//读取cookiegetCookie: function() {    if (document.cookie.length &gt; 0) {        var arr = document.cookie.split(&apos;; &apos;); //这里显示的格式需要切割一下自己可输出看下        for (var i = 0; i &lt; arr.length; i++) {            var arr2 = arr[i].split(&apos;=&apos;); //再次切割            //判断查找相对应的值            if (arr2[0] == &apos;userName&apos;) {                this.ruleForm.username = arr2[1]; //保存到保存数据的地方            } else if (arr2[0] == &apos;userPwd&apos;) {                this.ruleForm.password = arr2[1];            }        }    }},//清除cookieclearCookie: function() {    this.setCookie(&quot;&quot;, &quot;&quot;, -1); //修改2值都为空，天数为负1天就好了}</code></pre><blockquote><p>浏览器中的cookie信息如下图，注意这里cookie的expire/Max-Age过期时间，这个时间是格林尼治标准时间GMT，世界统一的时间，GMT+8小时就是北京时间。(这里不做加密功能)</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/1/30/161462f165b73ac8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ok"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/30/161462f165cc17dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue组件之间的数据传递及共享</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/04/21/33vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/04/21/33vue组件之间的数据传递/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2019-01-10T08:05:02.497Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理项目中代码，在组件之间数据传递遇到了问题，所以做了这次总结，如有不对的地方，望指正。</p><h3 id="父组件如何将数据传到子组件中"><a href="#父组件如何将数据传到子组件中" class="headerlink" title="父组件如何将数据传到子组件中"></a>父组件如何将数据传到子组件中</h3><p>父组件可以通过Prop传递数据到子组件中。</p><p>这里需要注意的是：</p><pre><code>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。每次父组件更新时，子组件的所有 Prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</code></pre><p> 在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><p>1、Prop 作为初始值传入后，子组件想把它当作局部数据来用；</p><p>解决方法：定义一个局部变量，并用 prop 的值初始化它：</p><pre><code>props: [&apos;initialCounter&apos;],data: function () {return { counter: this.initialCounter }}    </code></pre><p>2、Prop 作为原始数据传入，由子组件处理成其它数据输出。</p><p>解决方法： 定义一个计算属性，处理 prop 的值并返回：</p><pre><code>props: [&apos;size&apos;],computed: {normalizedSize: function () {    return this.size.trim().toLowerCase()}}</code></pre><p>PS：上边的内容是vue文档里边有说的，我只是把自己在项目中遇到的问题抽出来了。</p><pre><code>// 父组件 index.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;child :lists=&quot;lists&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import child from &apos;./child.vue&apos;;    export default {        components: {            child        },        data() {            return {                lists: []            };        },        mounted() {            this.lists = [{                name: &apos;01&apos;,                content: &apos;hi,&apos;            }, {                name: &apos;02&apos;,                content: &apos;my name is Ellyliang&apos;            }];        }    };&lt;/script&gt;// 子组件 child.vue&lt;template&gt;    &lt;ul class=&quot;content&quot;&gt;    &lt;li v-for=&quot;(list, index) in getLists&quot; :key=&quot;index&quot; v-html=&quot;list.name + list.content&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&apos;lists&apos;],        data() {            return {                getLists: this.lists            };        },        mounted() {            this.getLists.push({                name: &apos;03&apos;,                content: &apos;不要在乎内容，我就是测试&apos;            });        }    };&lt;/script&gt;</code></pre><h3 id="子组件如何将数据传到父组件中"><a href="#子组件如何将数据传到父组件中" class="headerlink" title="子组件如何将数据传到父组件中"></a>子组件如何将数据传到父组件中</h3><p>子组件可通过vm.$emit将数据传递给父组件</p><p> <strong>vm.$emit是啥</strong></p><p>触发当前实例上的事件。附加参数都会传给监听器回调</p><pre><code>// 父组件 index.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;child :lists=&quot;lists&quot; @listenToChild=&quot;getChildMsg&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import child from &apos;./child.vue&apos;;    export default {        components: {            child        },        data() {            return {                lists: []            };        },        mounted() {            this.lists = [{                name: &apos;01&apos;,                content: &apos;hi,&apos;            }, {                name: &apos;02&apos;,                content: &apos;my name is Ellyliang&apos;            }];        },        methods: {            getChildMsg(val) {                alert(val);  // &apos;hello&apos;            }        }    };&lt;/script&gt;// 子组件 child.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;ul class=&quot;lists&quot;&gt;            &lt;li v-for=&quot;(list, index) in getLists&quot; :key=&quot;index&quot; v-html=&quot;list.name + list.content&quot;&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&apos;lists&apos;],        data() {            return {                getLists: this.lists            };        },        mounted() {            this.getLists.push({                name: &apos;03&apos;,                content: &apos;不要在乎内容，我就是测试&apos;            });            setTimeout(() =&gt; {                this.$emit(&apos;listenToChild&apos;, &apos;hello&apos;);            }, 15000);        }    };&lt;/script&gt;</code></pre><p>子组件给父组件传数据是不是也很方便。实现方法是就是在子组件中$emit数据，然后在父组件中通过事件@事件名接收值。</p><h3 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h3><p>事件巴士这种方法，不仅能处理父子组件传递，子父组件传递，还是处理平级组件之间的数值传递。其实现方法就是在全局new一个vue实例，然后传值给bus, 就是let bus = new vue();。通过这个全局的bus中的$emit, $on等等去实现数据的传递。这样处理有个问题，由于event bus处理数据传递很方便，不管在哪里都可以传递，这样导致滥用，从而导致代码很难去理解。</p><p> Event Bus实现</p><pre><code>let bus = new Vue();// 触发组件 A 中的事件bus.$emit(&apos;id-selected&apos;, 1);// 在组件 B 创建的钩子中监听事件bus.$on(&apos;id-selected&apos;, function (id) {// ...});</code></pre><p>具体组件的封装和使用，可参考vue-bus。</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex官网的专业术语，让有些人还是感觉，摸不着头脑，做一些实用场景给大家看</p><pre><code>state 用来数据共享数据存储mutation 用来注册改变数据状态getters 用来对共享数据进行过滤操作action 解决异步改变共享数据</code></pre><p>此时采用的演示方式还是用官方提供的vue-cli webpack版本</p><p>在src目录下我们创一个vuex文件夹，分别创建index.js,mutations.js,state.js,getters.js,actions.js</p><p>这样我们可对四种特性进行分文件，这样可以更加明确，清楚</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/74a488ee6821acb7e263.png" alt="目录"></p><p>我们分别把这四个特性放入index.js中进行store的实列化</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/df4e0b9aed60a84d45ef.png" alt="state主目录"></p><p>再把实列化的store引入就是所谓的index.js文件夹引入到main.js中，也可以同时把store注册到每一个组件中</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/60c0bddd7c2b31df2879.png" alt="state实例化"></p><h4 id="state如何用？"><a href="#state如何用？" class="headerlink" title="state如何用？"></a>state如何用？</h4><p>在页面中，title肯定是必备，那每个组件页面的title都肯定不一样，那我们如何去拿到title,title适合放在那里，根据每个页面切换，而改变title,这个牵扯的就是组件与组件中的通信</p><p>我们可以在state.js中先声明一数据值</p><pre><code>export default{    title : &quot;首页&quot;}</code></pre><p><strong>那我们如何在首页中拿到这个title值</strong></p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/a6dfd2f072b4b9a012e9.jpg" alt=""></p><p>那我们在mian.js中再加入new Vue,绑定title作用域的实例代码</p><p>我们在computed里进行数据监听，</p><p>此时我们就可以从store里拿到state.title</p><p>最后一步，我们在index.html中我们再进行vue组件之间的数据传递及共享绑定</p><p><strong>index.html</strong></p><pre><code>&lt;title&gt;{{title}}&lt;/title&gt;</code></pre><p>此时我们运行一下，打开dev-tools你会发现</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/46eded6760bba9be1619.jpg" alt=""></p><p>title这个数据已经在全局被共享了</p><h4 id="matutions如何使用"><a href="#matutions如何使用" class="headerlink" title="matutions如何使用"></a>matutions如何使用</h4><p>应用场景：</p><p>如果我们要改变顶层的共享数据，我们应该要用matutions来进行改变，如果你做公众号，后台一般会在连接的上给你一些参数，比方说sid,ck,tm,或者一些其它东西，你想把他存在state中，如果去做，那我们就通过matutions来进行注册事件，为了演示，我才这么做</p><p>注意：<br>对于vuex，我只推荐state状态存储只在一个页面中组件与组件之间的通信，不适合跨页面， 放一些状态</p><p><strong>state.js</strong></p><pre><code>export default{    START_PARMA : {},    title : &quot;首页&quot;}</code></pre><p>START_PARMA用来存放我以上连接参数的数据，我们先前一定要定意好</p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    state.START_PARMA = Object    }}</code></pre><p>我们对改变state数据进行一个事件注册，第一个参数是拿到state对象，第二个是传入的参数</p><ul><li>getParam官方说是type，其实就是注册的事件名</li><li>可以是单个参数</li><li><p>如果是多个参数，我们则用对象放入，如果你写两个参数，会报错</p><pre><code>export default {        name : &apos;advertisement&apos;,        created () {            const keyCode = sessionStorage.keyCode = getQueryString(&apos;keyCode&apos;)            const keyWord = sessionStorage.keyWord =  keyCode.split(&quot;_&quot;)[0]            const hunterCode = sessionStorage.hunterCode = keyCode.split(&quot;_&quot;)[1]            const sid = sessionStorage.sid= getQueryString(&apos;sid&apos;)            const ck = sessionStorage.ck = getQueryString(&apos;ck&apos;)            const tm = sessionStorage.tm = getQueryString(&apos;tm&apos;)            this.$store.commit(&apos;getParam&apos;,{                keyCode,                keyWord,                hunterCode,                sid,                ck,                tm            })        }    }</code></pre></li></ul><p>我们自己创建一个视图，然后在created里进行截取参数，因为store是注册到每个组件中的，所以我们要用this.$store来访问，那commit就是一个触发器，第一个是type类形名，第二个参我们用对象的方式传入，里面用的是es6的语法</p><p>此时你会发现</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/f0aa5d0df0fbe76c49f3.png" alt=""></p><p>此时的截取的状态放到了一个对象里，我们就可以使用了</p><h4 id="getters如何使用"><a href="#getters如何使用" class="headerlink" title="getters如何使用"></a>getters如何使用</h4><p>如果说getter就是对state里的数据进行一些过滤，改造等等</p><p>那比方说State里有一些这样的数据</p><p><strong>state.js</strong></p><pre><code>people : [        {name : &apos;ziksang1&apos;,age:21},        {name : &apos;ziksang2&apos;,age:10},        {name : &apos;ziksang3&apos;,age:30},        {name : &apos;ziksang4&apos;,age:40},        {name : &apos;ziksang5&apos;,age:50},        {name : &apos;ziksang6&apos;,age:30},        {name : &apos;ziksang7&apos;,age:80}    ]</code></pre><p>如果我们定义这些数据，然后我们要从，这些数据中筛选出年纪大于30的人，再进行返回，我们就可以用到getter,这里的getter的意思就是对vuex顶层数据进行过滤，而不改动state里原本的数据</p><p><strong>getters.js</strong></p><pre><code>export default{    changePeople: (state) =&gt;{        return state.people.filter(item=&gt;{            if(item.age&gt;30){                return true            }        })    }}</code></pre><p>好我们如何应用呢，我们在组件中里只要写入</p><pre><code>created () {        console.log(this.changePeople)},computed : {            changePeople () {                return this.$store.getters.changePeople            }},</code></pre><p>那我们可以打开命台看一下，看回的数据，</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/6dca03740c0b56087763.jpg" alt=""><br>接下来你如何想对数据进行操作那就看你自己的了</p><h4 id="action-如何使用？"><a href="#action-如何使用？" class="headerlink" title="action 如何使用？"></a>action 如何使用？</h4><p>action.是用来解决异步流程来改变state数据的，有想人说，那我直接在matution里面进行写进不就行了麻，那你可以试一下，因为matution是直接进行同步操作的</p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    setTimeout(()=&gt;{            state.START_PARMA = Object    },1000)    }}</code></pre><p>还是拿上面例子，如果你在mutations里进行异步操作，你会发现没用，并不会起任何效果，那怎么办，只有通过action-&gt;mutations-&gt;states,这个流程进行操作</p><p><strong>action.js</strong></p><pre><code>export default {    getParamSync (context,Object) {        setTimeout(()=&gt;{            context.commit(&apos;getParam&apos;,Object)        },3000)    }}</code></pre><p>写一个getParamSync函灵敏，第一个参数就是上下文，context是一个store对象，你也可以用解构的方式写出来,第二个参数还是我们要写入的接收到的参数，来改变触发mutations事件,再通过mutation来改变state,很好理解不难</p><p>然后我们就在组件里这么调用就可以了</p><pre><code>this.$store.dispatch(&apos;getParamSync&apos;,{    keyCode,    keyWord,    hunterCode,    sid,    ck,    tm})</code></pre><p>那组合action又是怎么玩呢？我们有时候向后台请求时，要通过第一个AJAX返回值来进行下一个action分发</p><p>我们可以用promise来进行异步处理</p><p><strong>actions.js</strong></p><pre><code>export default {    getParamSync (context,Object) {        return new Promise((reslove,reject)=&gt;{            setTimeout(()=&gt;{                context.commit(&apos;getParam&apos;,Object)                return reslove(&apos;成功&apos;)            },3000)        })    },    changetitleSync ({commit},title){        setTimeout(()=&gt;{            commit(&apos;changetitle&apos;,title)        },3000)    }}</code></pre><p>在getParamSync使用new promise之后，在resolve里返回‘成功’，再分发一个changetitleSync改变title的action方法</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/4a3b12a68fd64e5aa0ea.png" alt=""></p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    state.START_PARMA = Object    },    changetitle (state,title){        state.title = title    }}</code></pre><p>再在注册一个改变title的changetitle的type类型</p><p><strong>组中间调用</strong></p><pre><code>created(){this.$store.dispatch(&apos;getParamSync&apos;,{                keyCode,                keyWord,                hunterCode,                sid,                ck,                tm            }).then((res)=&gt;{                this.$store.dispatch(&apos;changetitleSync&apos;,res)            })}</code></pre><p>我们就可以在组件中进行一种链式调用，解决异步回调，来action套action,就成了一个组合action</p><p><strong>关于其它辅助用法</strong></p><ul><li>mapState 辅助函数</li><li>mapGetters 辅助函数</li><li>mapMutations 辅助函数</li><li>mapActions 辅助函数</li></ul><p>尤大神已经写的很全面了，大家可以参考vuex的官网，进行阅读一下。我在这里就没有必要再进行重新讲解了</p><p><strong>在vuex中，我认为vuex用在那里比较好？</strong></p><p>只适合运用于一个视图内组件与组件之间的组合传递，不适用于跨页面，但是可以共用，为了不因用户刷新页面，要进行初始化再次调用。</p><p><strong>不适合运用在那里</strong></p><p>在自己写一些Ui组件给大家或者开源用的话，不适用于写在vuex中，应该暴露所接收的Props,通过$emit来进行触发事件，一些关键性全局状态，不也适合存vuex中，你可以选择localStorage,sessionStorage</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理项目中代码，在组件之间数据传递遇到了问题，所以做了这次总结，如有不对的地方，望指正。&lt;/p&gt;
&lt;h3 id=&quot;父组件如何将数据传到子组件中&quot;&gt;&lt;a href=&quot;#父组件如何将数据传到子组件中&quot; class=&quot;headerlink&quot; title=&quot;父组件如何将数据传
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongodb常用操作指令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/03/29/27mongodb%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/03/29/27mongodb使用方法/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2019-01-10T08:07:42.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建简单mongodb服务器"><a href="#1-创建简单mongodb服务器" class="headerlink" title="1.创建简单mongodb服务器"></a>1.创建简单mongodb服务器</h3><ul><li><p><code>mongod --dbpath E:\MongoDB\db</code></p></li><li><p><code>mongo.exe</code></p></li></ul><h3 id="2-数据库操作-CRUD"><a href="#2-数据库操作-CRUD" class="headerlink" title="2.数据库操作(CRUD)"></a>2.数据库操作(CRUD)</h3><ul><li><p>显示数据库名称：<code>show dbs</code></p></li><li><p>切换数据库：<code>use &lt;dbname&gt;</code></p></li><li><p>删除当前数据库：<code>db.dropDatabase()</code></p></li><li><p>想要新建数据库，直接使用<code>use &lt;dbname&gt;</code>,在需要的时候会自动创建</p></li><li><p>新建表<code>db.&lt;表名&gt;.insert({})</code>;数据以json的格式</p></li><li><p>显示表名 ：<code>show collections</code></p></li></ul><blockquote><p>例子</p></blockquote><pre><code>&gt; use exapmledb&gt; db.ex_collection1.insert({x:1}) //在表ex_collection1中插入数据{x:1}&gt; show collections输出：ex_collection1system.indexes</code></pre><h4 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h4><ul><li><p>查询 ：<code>db.&lt;表名&gt;.find()</code> 默认返回所有数据</p><p>  <code>&gt; db.ex_collection1.find()</code> </p></li><li><p>查询表中数据，默认返回所有</p><p>  <code>{ &quot;_id&quot; : ObjectId(&quot;58e9e1c6d6ffabd315a4f74a&quot;), &quot;x&quot; : 1 }</code></p><p>  数据库会自动生成一个<code>_id</code>，也可以自己添加，但不能重复</p></li><li><p>条件查询：db.ex_collection1.find({x:1})</p></li><li><p>循环插入</p><p>  <code>&gt; for(i=2;i&lt;50;i++)db.ex_collection1.insert({x:i})</code></p></li><li><p>计算查询出来的总数</p><p>  <code>&gt; db.ex_collection1.find().count()</code>  </p></li><li><p>增加查询条件,下面表示，过滤前3条，返回两条，并且以x排序</p><p>  <code>db.ex_collection1.find().skip(3).limit(2).sort({x:1})</code></p><h4 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2 更新"></a>2.2 更新</h4></li><li><p>更新数据，比如将<code>x：1</code>的数据改为<code>x：999</code></p><p>  <code>db.ex_collection1.update({x:1},{x:999})</code> </p></li><li><p>部分更新，比如有数据{x:100, y:100, z:100},想要以z:100为条件，更新里面的y为99；</p><p>  <code>db.ex_collection1.update({z:100},{$set:{y:99}})</code></p></li><li><p>更新一条不存在的数据，如果查找y为100的数据，改为y：999，如果不存在的话就直接写入y：999数据,增加第三个参数true即可。</p><p>  <code>db.ex_collection1.update({y:100},{y:999},true)</code></p></li><li><p>更新多条数据，mongodb默认更新一条数据，比如有三条c为1的数据，使用前面方式更新只会修改第一条。</p><p>  <code>db.immoc_collection.update({c:1},{$set:{c:2}},false,true)</code></p></li></ul><h4 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h4><ul><li><p>删除数据</p><p>  <code>db.immoc_collection.remove({c:2})</code></p></li><li><p>删除表</p><p>  <code>db.ex_collection1.drop()</code></p></li></ul><h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h3><h4 id="3-1-查询创建索引"><a href="#3-1-查询创建索引" class="headerlink" title="3.1 查询创建索引"></a>3.1 查询创建索引</h4><ul><li><p>查询索引</p><p>  <code>db.ex_collection1.getIndexes()</code></p></li><li><p>创建索引(这里的1代表为正向，-1为负向索引)</p><p>  <code>db.imooc_collection.ensureIndex({x:1})</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-创建简单mongodb服务器&quot;&gt;&lt;a href=&quot;#1-创建简单mongodb服务器&quot; class=&quot;headerlink&quot; title=&quot;1.创建简单mongodb服务器&quot;&gt;&lt;/a&gt;1.创建简单mongodb服务器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单实现VUE中的MVVM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/03/09/43%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0VUE%E4%B8%AD%E7%9A%84MVVM/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/03/09/43简单实现VUE中的MVVM/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2019-01-10T08:05:51.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p>首先，我们需要了解一下 js 中的一个 API :<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty(obj, prop, descriptor)</a></p><p>一般情况下我们为一个对象添加一个属性一般都会这么写</p><pre><code>let object = {}object.test = &apos;test&apos;</code></pre><p>Object.defineProperty 也能做到同样的效果</p><pre><code>let object = {}, test = &apos;test&apos;Object.defineProperty(object, &apos;test&apos;, {    configurable: true,            // 描述该属性的描述符能否被改变，默认值为 false    enumerable: true,               // 能否被遍历，比如 for in，默认值为 false    get: function(){                // 取值的时候调用，object.test，默认值为 false        console.log(&apos;enter get&apos;)        return test    },    set: function(newValue){        // 设置值的时候使用        console.log(&apos;enter set&apos;)        test = newValue    }})</code></pre><p>这样写虽然代码量多了不少，但是却拥有了控制属性取值和设置值的权利，让我们来测试一下。</p><pre><code> object.test// enter get// testobject.test = &apos;test2&apos;// enter set// test2</code></pre><p>接着我们把 defindProperty 这个函数封装同时改造一下，方便我们调用</p><pre><code>let callback = {    target: null}let defineReactive = function(object, key, value){    let array = []    Object.defineProperty(object, key, {        configurable: true,        enumerable: true,        get: function(){            if(callback.target){                array.push(callback.target)            }            return value        },        set: function(newValue){            if(newValue != value){                array.forEach((fun)=&gt;fun(newValue, value))            }            value = newValue        }    })}</code></pre><p>可以从代码中看出来，我在函数内部声明了一个数组用于存放 <strong>callback</strong> 中的 <strong>target</strong>，当对 <strong>object</strong> 进行 <strong>get</strong> 操作(取值操作)的时候，就会往 <strong>callback</strong> 中存放函数，进行 <strong>set</strong> 操作(设置值)的时候执行数组中的函数。看看效果如何</p><pre><code>let object = {}defineReactive(object, &apos;test&apos;, &apos;test&apos;)callback.target = function(newValue, oldValue){console.log(&apos;我被添加进去了，新的值是：&apos; + newValue)}object.test// testcallback.target = nullobject.test = &apos;test2&apos;// 我被添加进去了，新的值是：test2callback.target = function(newValue, oldValue){console.log(&apos;添加第二个函数，新的值是：&apos; + newValue)}object.test// testcallback.target = nullobject.test = &apos;test3&apos;// 我被添加进去了，新的值是：test3// 添加第二个函数，新的值是：test3</code></pre><p>这样我们就达成了在 object.test 的值发生改变时，运行一个函数队列（虽然这个队列挺简陋的）的目的。</p><p>换个说法，当我们取值的时候，函数自动帮我们添加了针对当前值的依赖，当这个值发生变化的时候，处理了这些依赖，比如说 DOM 节点的变化。</p><p>这个也是 VUE 中实现 MVVM 的最核心的代码，当然在 VUE 中，这个依赖收集的过程远比现在的代码要复杂，这里仅仅实现了依赖的收集和触发，对于依赖的管理这里的代码还做不到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;defineProperty&quot;&gt;&lt;a href=&quot;#defineProperty&quot; class=&quot;headerlink&quot; title=&quot;defineProperty&quot;&gt;&lt;/a&gt;defineProperty&lt;/h2&gt;&lt;p&gt;首先，我们需要了解一下 js 中的一个 AP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript创建对象和实现继承</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/01/09/34JAVASCRIPT%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/01/09/34JAVASCRIPT对象/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2019-01-10T08:04:39.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript创建对象"><a href="#JavaScript创建对象" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h2><h3 id="构造函数模式创建对象"><a href="#构造函数模式创建对象" class="headerlink" title="构造函数模式创建对象"></a>构造函数模式创建对象</h3><pre><code>function Person(name, job) {    this.name = name    this.job = job    this.sayName = function() {        console.log(this.name)    }}var person1 = new Person(‘Jiang’, ‘student’)var person2 = new Person(‘X’, ‘Doctor’)</code></pre><p>没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作</p><pre><code>创建一个新对象这个新对象会被执行[[prototype]]链接这个新对象会绑定到函数调用的this返回这个对象</code></pre><p>使用这个方式创建对象可以检测对象类型</p><pre><code>person1 instanceof Object // trueperson1 instanceof Person //true</code></pre><p>但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次</p><h3 id="原型模式创建对象"><a href="#原型模式创建对象" class="headerlink" title="原型模式创建对象"></a>原型模式创建对象</h3><pre><code>function Person() {}Person.prototype.name = ‘Jiang’Person.prototype.job = ‘student’Person.prototype.sayName = function() {console.log(this.name)}var person1 = new Person()</code></pre><p>将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。</p><p>原型是一个非常重要的概念，在一篇文章看懂proto和prototype的关系及区别中讲的非常详细</p><p>更简单的写法</p><pre><code>function Person() {}Person.prototype = {name: ‘jiang’,job: ‘student’,sayName: function() {    console.log(this.name)}}var person1 = new Person()</code></pre><p>将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。</p><p>使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里</p><p>Person.prototype.constructor === Person  // false<br>如果需要这个属性的话，可以手动添加</p><pre><code>function Person() {}Person.prototype = {    constructor：Person    name: ‘jiang’,    job: ‘student’,    sayName: function() {        console.log(this.name)    }}</code></pre><p>不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法</p><pre><code>Object.defineProperty(Person.prototype, ‘constructor’, {enumerable: false,value: Person})</code></pre><p>缺点使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点</p><p>原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了</p><pre><code>function Person() {}Person.prototype = {    name: ‘jiang’,    friends: [‘Shelby’, ‘Court’]}var person1 = new Person()var person2 = new Person()person1.friends.push(‘Van’)console.log(person1.friends) //[“Shelby”, “Court”, “Van”]console.log(person2.friends) //[“Shelby”, “Court”, “Van”]console.log(person1.friends === person2.friends) // true</code></pre><p>friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript创建对象&quot;&gt;&lt;a href=&quot;#JavaScript创建对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript创建对象&quot;&gt;&lt;/a&gt;JavaScript创建对象&lt;/h2&gt;&lt;h3 id=&quot;构造函数模式创建对象&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从头实现一个koa框架</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/01/09/22koa%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/01/09/22koa框架/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2019-01-10T08:09:11.329Z</updated>
    
    <content type="html"><![CDATA[<p>看完之后甚是膜拜，决定收藏记录下，引用地址<a href="https://zhuanlan.zhihu.com/p/35040744" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35040744</a></p><p>笔者认为，理解koa，主要需要搞懂四条主线，其实也是实现koa的四个步骤，</p><p>   分别是：</p><pre><code>1. 封装node http Server2. 构造resquest, response, context对象3. 中间件机制4. 错误处理</code></pre><h4 id="主线一：封装node-http-Server-从hello-world说起"><a href="#主线一：封装node-http-Server-从hello-world说起" class="headerlink" title="主线一：封装node http Server: 从hello world说起"></a>主线一：封装node http Server: 从hello world说起</h4><p>首先，不考虑框架，如果使用原生http模块来实现一个返回hello world的后端app，代码如下：</p><pre><code>let http = require(&apos;http&apos;);let server = http.createServer((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});server.listen(3000, () =&gt; {    console.log(&apos;listenning on 3000&apos;);});</code></pre><p>实现koa的第一步，就是对这个原生的过程进行封装，为此，我们首先创建application.js实现一个Application对象：</p><pre><code>// application.jslet http = require(&apos;http&apos;);class Application {    /**    * 构造函数    */    constructor() {        this.callbackFunc;    }    /**    * 开启http server并传入callback    */    listen(...args) {        let server = http.createServer(this.callback());        server.listen(...args);    }    /**    * 挂载回调函数    * @param {Function} fn 回调处理函数    */    use(fn) {        this.callbackFunc = fn;    }    /**    * 获取http server所需的callback函数    * @return {Function} fn    */    callback() {        return (req, res) =&gt; {            this.callbackFunc(req, res);        };    }}module.exports = Application;</code></pre><p>然后创建example.js:</p><pre><code>let simpleKoa = require(&apos;./application&apos;);let app = new simpleKoa();app.use((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});app.listen(3000, () =&gt; {    console.log(&apos;listening on 3000&apos;);});</code></pre><p>可以看到，我们已经初步完成了对于http server的封装，主要实现了app.use注册回调函数，app.listen语法糖开启server并传入回调函数了，典型的koa风格。</p><p>但是美中不足的是，我们传入的回调函数，参数依然使用的是req和res，也就是node原生的request和response对象，这些原生对象和api提供的方法不够便捷，不符合一个框架需要提供的易用性。因此，我们需要进入第二条主线了。</p><h4 id="主线二：构造request-response-context对象"><a href="#主线二：构造request-response-context对象" class="headerlink" title="主线二：构造request, response, context对象"></a>主线二：构造request, response, context对象</h4><p>如果阅读koa文档，会发现koa有三个重要的对象，分别是request, response, context。其中request是对node原生的request的封装，response是对node原生response对象的封装，context对象则是回调函数上下文对象，挂载了koa request和response对象。下面我们一一来说明。</p><p>首先要明确的是，对于koa的request和response对象，只是提供了对node原生request和response对象的一些方法的封装，明确了这一点，我们的思路是，使用js的getter和setter属性，基于node的对象req/res对象封装koa的request/response对象。</p><p>规划一下我们要封装哪些易用的方法。这里在文章中为了易懂，姑且只实现以下方法：</p><p>对于simpleKoa request对象，实现query读取方法，能够读取到url中的参数，返回一个对象。</p><p>对于simpleKoa response对象，实现status读写方法，分别是读取和设置http response的状态码，以及body方法，用于构造返回信息。</p><p>而simpleKoa context对象，则挂载了request和response对象，并对一些常用方法进行了代理。</p><p>首先创建request.js:</p><pre><code>// request.jslet url = require(&apos;url&apos;);module.exports = {    get query() {        return url.parse(this.req.url, true).query;    }};</code></pre><p>很简单，就是导出了一个对象，其中包含了一个query的读取方法，通过url.parse方法解析url中的参数，并以对象的形式返回。需要注意的是，代码中的this.req代表的是node的原生request对象，this.req.url就是node原生request中获取url的方法。稍后我们修改application.js的时候，会为koa的request对象挂载这个req。</p><p>然后创建response.js:</p><pre><code>// response.jsmodule.exports = {    get body() {        return this._body;    },    /**    * 设置返回给客户端的body内容    *    * @param {mixed} data body内容    */    set body(data) {        this._body = data;    },    get status() {        return this.res.statusCode;    },    /**    * 设置返回给客户端的stausCode    *    * @param {number} statusCode 状态码    */    set status(statusCode) {        if (typeof statusCode !== &apos;number&apos;) {            throw new Error(&apos;statusCode must be a number!&apos;);        }        this.res.statusCode = statusCode;    }};</code></pre><p>status读写方法分别设置或读取this.res.statusCode。同样的，这个this.res是挂载的node原生response对象。而body读写方法分别设置、读取一个名为this._body的属性。这里设置body的时候并没有直接调用this.res.end来返回信息，这是考虑到koa当中我们可能会多次调用response的body方法覆盖性设置数据。真正的返回消息操作会在application.js中存在。</p><p>然后我们创建context.js文件，构造context对象的原型：</p><pre><code>// context.jsmodule.exports = {    get query() {        return this.request.query;    },    get body() {        return this.response.body;    },    set body(data) {        this.response.body = data;    },    get status() {        return this.response.status;    },    set status(statusCode) {        this.response.status = statusCode;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完之后甚是膜拜，决定收藏记录下，引用地址&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35040744&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/35040744
      
    
    </summary>
    
    
  </entry>
  
</feed>
