<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BigDeal@blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/luwenchun/luwenchun.github.io/"/>
  <updated>2018-07-29T03:25:59.388Z</updated>
  <id>https://github.com/luwenchun/luwenchun.github.io/</id>
  
  <author>
    <name>卢文春</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新公司常见功能函数封装</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/07/22/%E6%96%B0%E5%85%AC%E5%8F%B8%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/07/22/新公司常见功能函数封装/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2018-07-29T03:25:59.388Z</updated>
    
    <content type="html"><![CDATA[<p>这些函数包括常见的业务函数和通用函数</p><h4 id="解决移动端300MS的点击延时，依赖fastClick"><a href="#解决移动端300MS的点击延时，依赖fastClick" class="headerlink" title="解决移动端300MS的点击延时，依赖fastClick"></a>解决移动端300MS的点击延时，依赖fastClick</h4><p><a href="https://github.com/ftlabs/fastclick">更多查看：https://github.com/ftlabs/fastclick</a></p><pre><code>import FastClick from &apos;fastclick&apos;;(function(doc) {    if (&apos;addEventListener&apos; in doc) {    doc.addEventListener(&apos;DOMContentLoaded&apos;, function() {        FastClick.attach(doc.body);    }, false);    }})(document);</code></pre><h4 id="移动端使用rem适配"><a href="#移动端使用rem适配" class="headerlink" title="移动端使用rem适配"></a>移动端使用rem适配</h4><pre><code>(function(doc, win) {var docEl = doc.documentElement,    resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,    recalc = function() {    var clientWidth = docEl.clientWidth;    if (!clientWidth) return;    docEl.style.fontSize = 20 * (clientWidth / 320) + &apos;px&apos;;    };if (!doc.addEventListener) return;win.addEventListener(resizeEvt, recalc, false);doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);})(document, window);</code></pre><h4 id="后台响应状态码容错处理"><a href="#后台响应状态码容错处理" class="headerlink" title="后台响应状态码容错处理"></a>后台响应状态码容错处理</h4><pre><code>export const message =  [    { code: 400, msg: &apos;1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。&apos;},    { code: 404, msg: &apos;请求失败，请求所希望得到的资源未被在服务器上发现。&apos;},    { code: 405, msg: &apos;请求行中指定的请求方法不能被用于请求相应的资源。&apos;},    { code: 413, msg: &apos;服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&apos;},    { code: 414, msg: &apos;请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。&apos;},    { code: 500, msg: &apos;服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。&apos;},    { code: 501, msg: &apos;服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&apos;},    { code: 502, msg: &apos;作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&apos;},    { code: 503, msg: &apos;由于临时的服务器维护或者过载，服务器当前无法处理请求。&apos;},    { code: 504, msg: &apos;作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。&apos;},    { code: 505, msg: &apos;服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&apos;},    { code: 600, msg: &apos;&apos;},]</code></pre><h4 id="全局自定义过滤器，业务场景式过滤器在需要的实例处添加"><a href="#全局自定义过滤器，业务场景式过滤器在需要的实例处添加" class="headerlink" title="全局自定义过滤器，业务场景式过滤器在需要的实例处添加"></a>全局自定义过滤器，业务场景式过滤器在需要的实例处添加</h4><pre><code>import Vue from &apos;vue&apos;import * as path from &apos;../config/path&apos;;let filters = {prefixImagePath:function (value,level) {    if(!value||typeof value ==&apos;undefined&apos;||value==0){    return &apos;./images/noPicture.png&apos;;    }    return path[&apos;http://img13.360buyimg.com/&apos;+level]+value.toString();},dotReplace:function (value,maxNum) {    //todo计算字节    if(!value||typeof(value)==&apos;undefined&apos;||value==0){    return &apos;&apos;;    }    if(maxNum&gt;(value.length-1)){    return value;    }    return value.toString().substr(0,maxNum)+&apos;...&apos;},//.....priceFormat:function(value){    var valueSplit = [];    value=value.replace(/^(\d*)$/,&quot;$1.&quot;);    value=(value+&quot;00&quot;).replace(/(\d*\.\d\d)\d*/,&quot;$1&quot;);    value=value.replace(&quot;.&quot;,&quot;,&quot;);    var re=/(\d)(\d{3},)/;    while(re.test(value))    value=value.replace(re,&quot;$1,$2&quot;);    value=value.replace(/,(\d\d)$/,&quot;.$1&quot;);    valueSplit = value.split(&apos;.&apos;);    if(valueSplit[1]&gt;0){    return  value.replace(/^\./,&quot;0.&quot;)    }else {    return valueSplit[0];    }}};export default ((vue)=&gt; {for(let fid in filters){    vue.filter(fid,filters[fid]);}})(Vue)</code></pre><h4 id="简单封装本地存储及cookie操作"><a href="#简单封装本地存储及cookie操作" class="headerlink" title="简单封装本地存储及cookie操作"></a>简单封装本地存储及cookie操作</h4><pre><code>**只实例化一次，同域下跨页面数据共享****https://github.com/marcuswestin/store.js****https://github.com/js-cookie/js-cookie**        import iStore from &apos;store&apos;;        import jsCookie from &apos;js-cookie&apos;;        class Store {        constructor(){        }        getLocal(key){            return iStore.get(key);        }        setLocal(key,value){            iStore.set(key,value);        }        removeLocal(key){            iStore.remove(key);        }        setCookie(key,value){            jsCookie.set(key,value);        }        setCookies(_object={}){            for(let key in _object){            this.setCookie(key,_object[key]);            }        }        getCookie(key){            return jsCookie.get(key);        }        removeCookie(key){            jsCookie.remove(key);        }        getCookies(){            return jsCookie.get();        }        }        function install(){            let instance;            if(!window.hasOwnProperty(&apos;store&apos;)){            window.store = instance = new Store();            }else {            instance = window[&apos;store&apos;];            }            return instance;        }        export default install();</code></pre><h4 id="截取url参数值"><a href="#截取url参数值" class="headerlink" title="截取url参数值"></a>截取url参数值</h4><pre><code>getQueryValue(name){    let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    let subString = location.href.split(&apos;?&apos;)[1]||&apos;&apos;;    let r = subString.match(reg);    if(r!=null)return  decodeURI(r[2]); return null;}  getMutiQueryValue(_arr = []) {    let resultObj = {};    _arr.forEach((item, index) =&gt; {    resultObj[item] = this.getQueryValue(item);    })    return resultObj;}</code></pre><h4 id="浏览量"><a href="#浏览量" class="headerlink" title="浏览量"></a>浏览量</h4><pre><code>@param {Number} n @return String        browseCunt(n) {            n = typeof n == &apos;string&apos; ? Number(n) : n;            if (n &gt;= 10000) {            n = Math.round(Math.round(n / 100) / 10) /10+ &apos;W&apos;;            }            return n;        }</code></pre><h4 id="日期格式转换"><a href="#日期格式转换" class="headerlink" title="日期格式转换"></a>日期格式转换</h4><pre><code>@param {String|Number} date @return String        dateName(date) {            if (!date) return !1;            const curTime = (new Date()).getTime()            let old = new Date(date)            if (isNaN(old)) {   // IOS 兼容            old = new Date(date.replace(/\-/g, &apos;/&apos;));            }            let cur = curTime - old.getTime();            cur = Math.abs(cur);            let msg = &apos;&apos;;            if (cur &gt; 259200000) { // 大于三天,显示日期            // msg = ((old.getMonth()) &lt; 9 ? &apos;0&apos; + (old.getMonth() + 1) : (old.getMonth())) + &apos;-&apos; + (old.getDate() &lt; 9 ? &apos;0&apos; + old.getDate() : old.getDate());            msg = moment(old).format(&apos;YYYY-MM-DD&apos;);            } else if (cur &gt;= 86400000) {  // 大于等于24小时,显示X天前            msg = Math.floor(cur / 86400000) + &apos;天前&apos;;            } else if (cur &gt;= 3600000) {  // 大于等于1小时,显示X小时前            msg = Math.floor(cur / 3600000) + &apos;小时前&apos;;            } else if (cur &gt;= 60000) {  // 大于等于1分钟,显示X分钟前            msg = Math.floor(cur / 60000) + &apos;分钟前&apos;;            } else {  // 小于60S, 显示刚刚            msg = &apos;刚刚&apos;            }            return msg;        };</code></pre><p>###/* 封装ajax函数</p><pre><code>* @param {string}obj.type http连接的方式，包括POST和GET两种方式* @param {string}obj.url 发送请求的url* @param {boolean}obj.async 是否为异步请求，true为异步的，false为同步的* @param {object}obj.data 发送的参数，格式为对象类型* @param {function}obj.success ajax发送并接收成功调用的回调函数* @param {function}obj.error ajax发送失败或者接收失败调用的回调函数*///  ecDo.ajax({//      type:&apos;get&apos;,//      url:&apos;xxx&apos;,//      data:{//          id:&apos;111&apos;//      },//      success:function(res){//          console.log(res)//      }//  })ajax: function (obj) {    obj = obj || {};    obj.type = obj.type.toUpperCase() || &apos;POST&apos;;    obj.url = obj.url || &apos;&apos;;    obj.async = obj.async || true;    obj.data = obj.data || null;    obj.success = obj.success || function () {        };    obj.error = obj.error || function () {        };    var xmlHttp = null;    if (XMLHttpRequest) {        xmlHttp = new XMLHttpRequest();    } else {        xmlHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    }    var params = [];    for (var key in obj.data) {        params.push(key + &apos;=&apos; + obj.data[key]);    }    var postData = params.join(&apos;&amp;&apos;);    if (obj.type.toUpperCase() === &apos;POST&apos;) {        xmlHttp.open(obj.type, obj.url, obj.async);        xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;);        xmlHttp.send(postData);    } else if (obj.type.toUpperCase() === &apos;GET&apos;) {        xmlHttp.open(obj.type, obj.url + &apos;?&apos; + postData, obj.async);        xmlHttp.send(null);    }    xmlHttp.onreadystatechange = function () {        if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {            obj.success(xmlHttp.responseText);        } else {            obj.error(xmlHttp.responseText);        }    };}</code></pre><h3 id="图片没加载出来时用一张图片代替"><a href="#图片没加载出来时用一张图片代替" class="headerlink" title="//图片没加载出来时用一张图片代替"></a>//图片没加载出来时用一张图片代替</h3><pre><code>//图片没加载出来时用一张图片代替aftLoadImg: function (obj, url, errorUrl,cb) {    var oImg = new Image(), _this = this;    oImg.src = url;    oImg.onload = function () {        obj.src = oImg.src;        if (cb &amp;&amp; _this.istype(cb, &apos;function&apos;)) {            cb(obj);        }    }    oImg.onerror=function () {        obj.src=errorUrl;        if (cb &amp;&amp; _this.istype(cb, &apos;function&apos;)) {            cb(obj);        }    }},//图片滚动懒加载//@className {string} 要遍历图片的类名//@num {number} 距离多少的时候开始加载 默认 0//比如，一张图片距离文档顶部3000，num参数设置200，那么在页面滚动到2800的时候，图片加载。不传num参数就滚动，num默认是0，页面滚动到3000就加载//html代码//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;//&lt;p&gt;&lt;img data-src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/160319f12631736f&quot; class=&quot;load-img&quot; width=&apos;528&apos; height=&apos;304&apos; /&gt;&lt;/p&gt;....//data-src储存src的数据，到需要加载的时候把data-src的值赋值给src属性，图片就会加载。//详细可以查看testLoadImg.html//window.onload = function() {//    loadImg(&apos;load-img&apos;,100);//    window.onscroll = function() {//        ecDo.loadImg(&apos;load-img&apos;,100);//        }//}loadImg: function (className, num, errorUrl) {    var _className = className || &apos;ec-load-img&apos;, _num = num || 0, _this = this,_errorUrl=errorUrl||null;    var oImgLoad = document.getElementsByClassName(_className);    for (var i = 0, len = oImgLoad.length; i &lt; len; i++) {        //如果图片已经滚动到指定的高度        if (document.documentElement.clientHeight + document.documentElement.scrollTop &gt; oImgLoad[i].offsetTop - _num &amp;&amp; !oImgLoad[i].isLoad) {            //记录图片是否已经加载            oImgLoad[i].isLoad = true;            //设置过渡，当图片下来的时候有一个图片透明度变化            oImgLoad[i].style.cssText = &quot;transition: &apos;&apos;; opacity: 0;&quot;            if (oImgLoad[i].dataset) {                this.aftLoadImg(oImgLoad[i], oImgLoad[i].dataset.src, _errorUrl, function (o) {                    //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑                    setTimeout(function () {                        if (o.isLoad) {                            _this.removeClass(o, _className);                            o.style.cssText = &quot;&quot;;                        }                    }, 1000)                });            } else {                this.aftLoadImg(oImgLoad[i], oImgLoad[i].getAttribute(&quot;data-src&quot;), _errorUrl, function (o) {                    //添加定时器，确保图片已经加载完了，再把图片指定的的class，清掉，避免重复编辑                    setTimeout(function () {                        if (o.isLoad) {                            _this.removeClass(o, _className);                            o.style.cssText = &quot;&quot;;                        }                    }, 1000)                });            }            (function (i) {                setTimeout(function () {                    oImgLoad[i].style.cssText = &quot;transition:all 1s; opacity: 1;&quot;;                }, 16)            })(i);        }    }}</code></pre><h3 id="获取，设置url参数"><a href="#获取，设置url参数" class="headerlink" title="获取，设置url参数"></a>获取，设置url参数</h3><pre><code>//设置url参数//ecDo.setUrlPrmt({&apos;a&apos;:1,&apos;b&apos;:2})//result：a=1&amp;b=2setUrlPrmt: function (obj) {    var _rs = [];    for (var p in obj) {        if (obj[p] != null &amp;&amp; obj[p] != &apos;&apos;) {            _rs.push(p + &apos;=&apos; + obj[p])        }    }    return _rs.join(&apos;&amp;&apos;);},//获取url参数//ecDo.getUrlPrmt(&apos;test.com/write?draftId=122000011938&apos;)//result：Object{draftId: &quot;122000011938&quot;}getUrlPrmt: function (url) {    url = url ? url : window.location.href;    var _pa = url.substring(url.indexOf(&apos;?&apos;) + 1),        _arrS = _pa.split(&apos;&amp;&apos;),        _rs = {};    for (var i = 0, _len = _arrS.length; i &lt; _len; i++) {        var pos = _arrS[i].indexOf(&apos;=&apos;);        if (pos == -1) {            continue;        }        var name = _arrS[i].substring(0, pos),            value = window.decodeURIComponent(_arrS[i].substring(pos + 1));        _rs[name] = value;    }    return _rs;}</code></pre><h3 id="Date日期时间部分"><a href="#Date日期时间部分" class="headerlink" title="Date日期时间部分"></a>Date日期时间部分</h3><pre><code>//到某一个时间的倒计时//ecDo.getEndTime(&apos;2017/7/22 16:0:0&apos;)//result：&quot;剩余时间6天 2小时 28 分钟20 秒&quot;getEndTime: function (endTime) {    var startDate = new Date(); //开始时间，当前时间    var endDate = new Date(endTime); //结束时间，需传入时间参数    var t = endDate.getTime() - startDate.getTime(); //时间差的毫秒数    var d = 0,        h = 0,        m = 0,        s = 0;    if (t &gt;= 0) {        d = Math.floor(t / 1000 / 3600 / 24);        h = Math.floor(t / 1000 / 60 / 60 % 24);        m = Math.floor(t / 1000 / 60 % 60);        s = Math.floor(t / 1000 % 60);    }    return &quot;剩余时间&quot; + d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot; 分钟&quot; + s + &quot; 秒&quot;;}</code></pre><h3 id="适配rem"><a href="#适配rem" class="headerlink" title="适配rem"></a>适配rem</h3><pre><code>getFontSize: function (_client) {    var doc = document,        win = window;    var docEl = doc.documentElement,        resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,        recalc = function () {            var clientWidth = docEl.clientWidth;            if (!clientWidth) return;            //如果屏幕大于750（750是根据我效果图设置的，具体数值参考效果图），就设置clientWidth=750，防止font-size会超过100px            if (clientWidth &gt; _client) {                clientWidth = _client            }            //设置根元素font-size大小            docEl.style.fontSize = 100 * (clientWidth / _client) + &apos;px&apos;;        };    //屏幕大小改变，或者横竖屏切换时，触发函数    win.addEventListener(resizeEvt, recalc, false);    //文档加载完成时，触发函数    doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);}//ecDo.getFontSize(750)//使用方式很简单，比如效果图上，有张图片。宽高都是100px;//750是设计图的宽度//样式写法就是img{    width:1rem;    height:1rem;}//这样的设置，比如在屏幕宽度大于等于750px设备上，1rem=100px；图片显示就是宽高都是100px//比如在iphone6(屏幕宽度：375)上，375/750*100=50px;就是1rem=50px;图片显示就是宽高都是50px;</code></pre><h3 id="手机类型判断"><a href="#手机类型判断" class="headerlink" title="手机类型判断"></a>手机类型判断</h3><pre><code>browserInfo: function (type) {    switch (type) {        case &apos;android&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;android&apos;) !== -1        case &apos;iphone&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;iphone&apos;) !== -1        case &apos;ipad&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;ipad&apos;) !== -1        case &apos;weixin&apos;:            return navigator.userAgent.toLowerCase().indexOf(&apos;micromessenger&apos;) !== -1        default:            return navigator.userAgent.toLowerCase()    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些函数包括常见的业务函数和通用函数&lt;/p&gt;
&lt;h4 id=&quot;解决移动端300MS的点击延时，依赖fastClick&quot;&gt;&lt;a href=&quot;#解决移动端300MS的点击延时，依赖fastClick&quot; class=&quot;headerlink&quot; title=&quot;解决移动端300MS的点
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/23/性能优化方式/</id>
    <published>2018-06-22T16:00:00.000Z</published>
    <updated>2018-07-29T03:21:05.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从服务渲染过程谈性能优化"><a href="#从服务渲染过程谈性能优化" class="headerlink" title="从服务渲染过程谈性能优化"></a>从服务渲染过程谈性能优化</h1><p>本文将结合从在浏览器输入url，到展示最终页面的过程来对其进行一步步分析，并将在web 中的实际应用实践进行总结。</p><h3 id="模式-1-前后分离"><a href="#模式-1-前后分离" class="headerlink" title="模式 1 - 前后分离"></a>模式 1 - 前后分离</h3><p>从用户输入 url　到展示最终页面的过程，这种模式可简单的分为以下 5 部分</p><p>1、用户输入 url，开始拉取静态页面<br>2、静态页面加载完成后，解析文档标签，并开始拉取 CSS （一般 CSS 放于头部）<br>3、接着拉取 JS 文件（一般 JS 文件放于尾部）<br>4、当 JS 加载完成，便开始执行 JS 内容，发出请求并拿到数据<br>5、将数据与资源渲染到页面上，得到最终展示效果</p><p>具体流程图如下</p><p><img src="/../about/qg6ngypp8w.png" alt=""></p><p>这种处理形式应该占据大多数，然而也很容易发现一个问题就是<strong>请求数多，前后依赖大</strong>，如必须等待 JS 加载完成后执行时才会发起 数据请求，等待数据回来用户才可以展示最终页面，这种强依赖的关系使得整个应用的首屏渲染耗时增加不少。</p><h3 id="模式-2-数据直出"><a href="#模式-2-数据直出" class="headerlink" title="模式 2 - 数据直出"></a>模式 2 - 数据直出</h3><blockquote><p>数据请求在server端上提前获取，并和html一同返回，页面模板和数据的渲染在浏览器端上执行</p></blockquote><p>在模式 1 中，第 1 点用户输入 url 时 server 端不做其他处理直接返回 html ，在第 4 点向 server 请求获取数据。那么，同样都是向 server 请求获取，如果在第 1 点中将请求数据放在 server 上，将拿到的数据拼接到 HTML 上一并返回，那么可减少在前端页面上的一次数据请求时间。 这就是模式 2 - 数据直出所做的事，处理方式也很简单</p><p>1、用户输入 url ，在 server 返回 HTML 前去请求获取页面需要的数据<br>2、将数据拼接到 HTML 上 并 一起返回给前端（可以插入 script 标签将数据添加到全局变量上，或放到某个标签的 data 属性中，如 ）<br>3、在前端的JS代码中判断是否已在服务端拿到数据，直接拿该数据进行渲染页面，不再做数据请求</p><p>具体可下面的流程图看出这种模式下</p><p><img src="/../about/xingneng2.png" alt=""></p><p>这种模式与模式1 相比，减少了这两种模式请求数据的耗时差距。这块差距有多少呢？</p><h4 id="发起一个-HTTP-的网络请求过程"><a href="#发起一个-HTTP-的网络请求过程" class="headerlink" title="发起一个 HTTP 的网络请求过程"></a>发起一个 HTTP 的网络请求过程</h4><pre><code>DNS解析（100~200ms可以缓存）        |        |        建立TCP链接 (三次握手100~200ms )                |                |            HTTP Request( 半个RTT )                 |                |            HTTP Response( RTT 不确定优化空间 )</code></pre><p>注: RTT 为 Round-trip time 缩写，表示一个数据包从发出到返回所用的时间。</p><h4 id="HTTP-请求在前后端发出，差距有多少？"><a href="#HTTP-请求在前后端发出，差距有多少？" class="headerlink" title="HTTP 请求在前后端发出，差距有多少？"></a>HTTP 请求在前后端发出，差距有多少？</h4><p>由上面对 HTTP 的网络请求过程可看到建立一次完整的请求返回在耗时上明显的，特别是外网用户在进行 HTTP 请求时，由于网络等因素的影响，在网络连接及传输上将花费很多时间。而在服务端进行数据拉取，即使同样是 HTTP 请求，由于后端之间是处于同一个内网上的，所以传输十分高效，这是差距来源的大头，是优化的刚需。</p><h3 id="模式-3-直出-服务端渲染"><a href="#模式-3-直出-服务端渲染" class="headerlink" title="模式 3 - 直出 (服务端渲染)"></a>模式 3 - 直出 (服务端渲染)</h3><blockquote><p>数据请求在server端上提前获取，页面模板结合数据的渲染处理也在server上完成，输出最终 HTML</p></blockquote><p>模式 2 中将依赖于JS文件加载回来才能去发起的数据请求挪到 server 中，数据随着 HTML 一并返回。然后等待 JS 文件加载完成，JS 将服务端已给到的数据与HTML结合处理，生成最终的页面文档。</p><p>数据请求能放到 server 上，对于数据与HTML结合处理也可以在server上做，从而减少等待 JS 文件的加载时间。 这就是模式3 - 直出 (服务端渲染)，主要处理如下</p><p>1、server 上获取数据并将数据与页面模板结合，在服务端渲染成最终的 HTML<br>2、返回最终的 HTML 展示</p><p>可以从下图看出，页面的首屏展示不再需要等待 JS 文件回来，优化减少了这块时间</p><p><img src="/../about/1c5f64bc-29a7-11e6-800a-bd8b4af30b0f.png" alt=""></p><p>通过以上模式，将模式 1 - 常用模式中的第 3 和 4 点耗时进行了优化，那么可以再继续优化吗？在页面文档不大情况下，可将CSS内联到HTML中，这是优化请求量的做法。直出稍微不同的是需要考虑的是服务端最终渲染出来的文档的大小，在范围内也可将 CSS 文件内联到 HTML 中。这样的话，便优化了 CSS 的获取时间，如下图</p><p><img src="/../about/2b09bc10-29a7-11e6-8fa9-6dc12579b1aa.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>直出能够将常用模式优化到剩下了一次 HTML 请求，加快首屏渲染时间，使用服务端渲染，还能够优化前端渲染难以克服的 SEO 问题。而不管是简单的 数据直出 或是 服务端渲染直出 都能使页面的性能优化得到较大提高，以下将从实际应用中进行说明。</p><h1 id="从输入URL过程谈性能优化"><a href="#从输入URL过程谈性能优化" class="headerlink" title="从输入URL过程谈性能优化"></a>从输入URL过程谈性能优化</h1><pre><code>  1、用户输入网址（假设是个 HTML 页面，第一次访问，无缓存情况），浏览器向服务器发出HTTP请求，服务器返回 HTML 文件； （善用缓存，减少HTTP请求，减轻服务器压力） 2. 浏览器载入 HTML 代码，发现 &lt;head&gt; 内有一个 &lt;link&gt; 引用外部 CSS 文件,则浏览器立即发送CSS文件请求，获取浏览器返回的CSS文件；  （CSS文件合并，减少HTTP请求） 3. 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了； （CSS文件需要放置最上面，避免网页重新渲染） 4. 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； （图片文件合并，减少HTTP请求） 5. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；（最好图片都设置尺寸，避免重新渲染） 6. 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，会立即运行该js代码；（script最好放置页面最下面）                    7. js脚本执行了语句，它令浏览器隐藏掉代码中的某个 &lt;div&gt;,突然就少了一个元素，浏览器不得不重新渲染这部分代码； （页面初始化样式不要使用js控制）    8. 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面…… 9. 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 &lt;link&gt; 标签的 CSS 路径；10. 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</code></pre><h1 id="从渲染DOM树过程谈性能优化"><a href="#从渲染DOM树过程谈性能优化" class="headerlink" title="从渲染DOM树过程谈性能优化"></a>从渲染DOM树过程谈性能优化</h1><p><strong>reflow(回流)</strong></p><p> 说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染， 该过程称为reflow（回流）。</p><p>  reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p><p><strong>repaint(重绘)</strong></p><p>如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow（在IE下需要换一下说法，reflow 要比 repaint 更缓慢）。尽量避免reflow(回流)  ，reflow(回流)是导致DOM脚本执行低效的关键因素之一。页面上任何一个结点触发reflow，都会导致它的子结点及祖先结点重新渲染。</p><blockquote><p>在哪些情况下会导致reflow发生：</p></blockquote><pre><code> 改变窗囗大小 改变文字大小 添加/删除样式表内容的改变，如用户在输入框中敲字激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活)操作class属性脚本操作DOM计算offsetWidth和offsetHeight设置style属性性</code></pre><p> 那么为了减少回流要注意哪些方式呢？      </p><p>1.不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸</p><p>2.尽量通过class来设计元素样式，切忌用style</p><pre><code>var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; //  再一次的 reflow 和 repaintbstyle.color = &quot;blue&quot;; // repaintbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint// new DOM element - reflow, repaintdocument.body.appendChild(document.createTextNode(&apos;dude!&apos;));</code></pre><p>对上面代码优化：</p><pre><code>.b-class{　　padding:20px;　　color:blue;　　border:10px solid red;　　background-color:#fad;　　font-size:2em;}$div.addClass(&quot;b-class&quot;);</code></pre><p>3.实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute</p><p>4.权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。</p><p>5.不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，</p><p>6.这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。</p><p>7.css里不要有表达式expression</p><p>8.减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。</p><p>9.避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。</p><p>10.尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。</p><pre><code>在div.first里面加入div.second,在div.second里面加入div.third:        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $(div.first).append($divS));//reflow        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);//reflow优化代码：        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);        $(div.first).append($divS));//reflow或者：        var $divF = $(div.first);        $divS = $(&quot;&lt;div class=&apos;second&apos;&gt;&lt;/div&gt;&quot;);        $divS.hide();        $(div.first).append($divS));        $divT = $(&quot;&lt;div class=&apos;third&apos;&gt;&lt;/div&gt;&quot;);        $divS.append($divT);        $divS.show();//reflow  </code></pre><p>11.请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。</p><p>如果我们要经常去获取和操作这些值，则可以先将这些值缓存起来例如：</p><pre><code>var windowHeight = window.innerHeight;//reflowfor(i=0;i&lt;10;i++){     $body.height(windowHeight++);   　一系列关于windowHeight的操作....... }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从服务渲染过程谈性能优化&quot;&gt;&lt;a href=&quot;#从服务渲染过程谈性能优化&quot; class=&quot;headerlink&quot; title=&quot;从服务渲染过程谈性能优化&quot;&gt;&lt;/a&gt;从服务渲染过程谈性能优化&lt;/h1&gt;&lt;p&gt;本文将结合从在浏览器输入url，到展示最终页面的过程来对其进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>与原生交互的常见方式</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/06/11/%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/06/11/与原生交互的常见方式/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-07-29T03:19:41.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="返回交互"><a href="#返回交互" class="headerlink" title="返回交互"></a>返回交互</h4><pre><code>back: function() {    // IOS        try {            window.webkit.messageHandlers.back.postMessage({ back:0 });        } catch (error) { }        // 安卓        try {        window.NativeJavaScriptInterface.back({back:1});        } catch (err) {}}</code></pre><h4 id="获取token（由于网关问题，需要部署才能写入请求header的token）"><a href="#获取token（由于网关问题，需要部署才能写入请求header的token）" class="headerlink" title="获取token（由于网关问题，需要部署才能写入请求header的token）"></a>获取token（由于网关问题，需要部署才能写入请求header的token）</h4><pre><code>// ios    window.getToken = (token) =&gt; {    //全局写入请求头    http.setRequestHeader({&quot;Authorization&quot;:token});    axios.create({        headers:{ &quot;Authorization&quot;:token }    })    }// 安卓获取tokentry {    var token=  window.NativeJavaScriptInterface.getToken();    //全局写入请求头    http.setRequestHeader({&quot;Authorization&quot;:token});    axios.create({        headers:{ &quot;Authorization&quot;:token }    })} catch (err) {}</code></pre><h4 id="跟原生交互事件（orderInfo是事件名称需要和原生开发协定，-sourceType-1-orderId-orderId-是回调给原生参数）"><a href="#跟原生交互事件（orderInfo是事件名称需要和原生开发协定，-sourceType-1-orderId-orderId-是回调给原生参数）" class="headerlink" title="跟原生交互事件（orderInfo是事件名称需要和原生开发协定，{ sourceType:1,orderId:orderId }是回调给原生参数）"></a>跟原生交互事件（orderInfo是事件名称需要和原生开发协定，{ sourceType:1,orderId:orderId }是回调给原生参数）</h4><pre><code>// ios try {   window.webkit.messageHandlers.orderInfo.postMessage({ sourceType:1,orderId:orderId }); } catch (error) { } //安卓  try { window.NativeJavaScriptInterface.orderInfo(&apos;1&apos;,orderId); } catch (err) {}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;返回交互&quot;&gt;&lt;a href=&quot;#返回交互&quot; class=&quot;headerlink&quot; title=&quot;返回交互&quot;&gt;&lt;/a&gt;返回交互&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;back: function() {
    // IOS
        try {
          
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 基础命令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/19/Linux%20%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/19/Linux 基础命令/</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2018-07-29T03:24:51.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><pre><code>创建目录 mkdir &lt;目录名称&gt;删除目录 rm &lt;目录名称&gt;定位目录 cd &lt;目录名称&gt;查看目录文件 ls ll修改目录名 mv &lt;目录名称&gt; &lt;新目录名称&gt;拷贝目录 cp &lt;目录名称&gt; &lt;新目录名称&gt;</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>创建文件 touch &lt;文件名称&gt; vi &lt;文件名称&gt;删除文件 rm &lt;文件名称&gt;修改文件名 mv &lt;文件名称&gt; &lt;新文件名称&gt;拷贝文件 cp &lt;文件名称&gt; &lt;新文件名称&gt;</code></pre><h2 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h2><pre><code>查看文件 cat &lt;文件名称&gt; head &lt;文件名称&gt; tail &lt;文件名称&gt;编辑文件内容 vi &lt;文件名称&gt;查找文件内容 grep &apos;关键字&apos; &lt;文件名称&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;创建目录 mkdir &amp;lt;目录名称&amp;gt;
删除目录 rm &amp;lt;目录名称&amp;gt;
定位目录 cd &amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于gulp的前端脚手架</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/02/%E5%9F%BA%E4%BA%8Egulp%E7%9A%84%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/02/基于gulp的前端脚手架/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-07-29T03:20:14.971Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到gulp和webpack各种脚手架，这次来入门下这二种脚手架。</p><h2 id="Gulp快速入门"><a href="#Gulp快速入门" class="headerlink" title="Gulp快速入门"></a>Gulp快速入门</h2><p>首先确保本地已安装node.js和npm<br>然后通过npm全局安装gulp</p><pre><code>$ npm install -g gulp   </code></pre><p>根据不同项目的要求，可选择适合的gulp插件进行后续开发。如果项目的要求基本相似（如小型的活动运营H5，平台页面等）可建立自己的脚手架工具以便于后续快速开发。</p><h3 id="搭建脚手架"><a href="#搭建脚手架" class="headerlink" title="搭建脚手架"></a>搭建脚手架</h3><p>1、首先在项目根目录下通过命令行安装项目依赖</p><pre><code>$ npm install --save-dev gulp</code></pre><p>2、在项目根目录下新建文件gulpfile.js。要想完成相关插件的配置，首先需要了解gulp相关方法</p><pre><code>gulp只有五个方法： task run watch src desttask 这个API用来创建任务，在命令行下可以输入 gulp test 来执行test的任务。run 这个API用来运行任务watch 这个API用来监听任务。src 这个API设置需要处理的文件的路径，可以是多个文件以数组的形式[main.scss,vender.scss]，也可以是正则表达式/*/ .scss。 dest 这个API设置生成文件的路径，一个任务可以有多个生成路径，一个可以输出未压缩的版本，另一个可以输出压缩后的版本。其实整个gulp的配置文件，基本上都是在做一些任务的配置，比如创建任务，监听任务等等。</code></pre><h3 id="基于脚手架进行开发"><a href="#基于脚手架进行开发" class="headerlink" title="基于脚手架进行开发"></a>基于脚手架进行开发</h3><p>1、拷贝package.json和gulpfile.js到相印项目根目录下，使用以下命令安装各插件</p><pre><code>$ npm install</code></pre><p>2、在根目录下键入相印命令进行所需的操作，如</p><pre><code>$ gulp</code></pre><h3 id="基本设定"><a href="#基本设定" class="headerlink" title="基本设定"></a>基本设定</h3><p>先大致地梳理一遍我们想要的功能和一些前提的设定。</p><p>1、脚手架自动化工具基于Gulp</p><p>2、基本的Task</p><pre><code>初始化目录结构初始化Index文件结构（迭代时可考虑基于Mobile OR PC）Sass自动编译CSS AutoPrefixer监听文件，自动刷新合并雪碧图</code></pre><h3 id="编写自己的Gulpfile-js"><a href="#编写自己的Gulpfile-js" class="headerlink" title="编写自己的Gulpfile.js"></a>编写自己的Gulpfile.js</h3><p>有了上面的基本约束后，现在建立自己的gulpfile文件，这里会详细记录每一个task的配置和使用。</p><p>首先把package.json和gulpfile.js建立起来</p><p>使用 npm init 初始化package.json（可一直按回车，或填写一些基本信息）。使用 npm install –save-dev gulp 使用gulp作为项目依赖</p><p>安装所需插件以及gulpfile.js的task配置</p><h4 id="初始化目录与文件"><a href="#初始化目录与文件" class="headerlink" title="初始化目录与文件"></a>初始化目录与文件</h4><p>首先需要初始化目录结构，这里使用fs-extra</p><p>使用以下命令进行安装 （后续的插件安装不再赘述，大家可从npmjs处查找相印的安装以及Api）</p><pre><code>npm install --save fs-extra</code></pre><p>先看一眼我们需要生成的目录结构</p><pre><code>├── dist # 编译后的文件    ├── html        └── index.html # home    ├── css    ├── js    └── img├── src     ├── img    ├── sprite    ├── pics    ├── js    └── sass        └── style.scss├── psd</code></pre><p>写入gulpfile.js</p><pre><code>var gulp = require(&apos;gulp&apos;);// 引入组件var path   = require(&apos;path&apos;), // node自带组件    fse    = require(&apos;fs-extra&apos;); // 通过npm下载// 获取当前文件路径var PWD = process.env.PWD || process.cwd(); // 兼容windowsgulp.task(&apos;init&apos;, function() {    var dirs = [&apos;dist&apos;,&apos;dist/html&apos;,&apos;dist/css&apos;,&apos;dist/img&apos;,&apos;dist/js&apos;,&apos;src&apos;,&apos;src/sass&apos;,&apos;src/js&apos;,&apos;src/img&apos;,&apos;src/pic&apos;,&apos;src/sprite&apos;,&apos;psd&apos;];    dirs.forEach(function (item,index) {        // 使用mkdirSync方法新建文件夹        fse.mkdirSync(path.join(PWD + &apos;/&apos;+ item));    })    // 往index里写入的基本内容    var template = &apos;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;/&gt;&lt;title&gt;&lt;/title&gt;&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&apos;;    fse.writeFileSync(path.join(PWD + &apos;/dist/html/index.html&apos;), template);    fse.writeFileSync(path.join(PWD + &apos;/src/sass/style.scss&apos;), &apos;@charset &quot;utf-8&quot;;&apos;);})</code></pre><p>此时运行$ gulp init发现目录已经生成完成了。再对index.html里的内容用编辑器的插件格式化一下，进入下一步。</p><h3 id="编译-sass以及为某些属性添加适当的前缀"><a href="#编译-sass以及为某些属性添加适当的前缀" class="headerlink" title="编译.sass以及为某些属性添加适当的前缀"></a>编译.sass以及为某些属性添加适当的前缀</h3><p>添加对sass编译的支持 安装插件gulp-sass。在gulpfile写入</p><pre><code>// 编译sassvar sass = require(&apos;gulp-sass&apos;);gulp.task(&apos;sass&apos;, function () {return gulp    // 在src/sass目录下匹配所有的.scss文件    .src(&apos;src/sass/**/*.scss&apos;)    // 基于一些配置项 运行sass()命令    .pipe(sass({        errLogToConsole: true,        outputStyle: &apos;expanded&apos;    }).on(&apos;error&apos;, sass.logError))    // 输出css    .pipe(gulp.dest(&apos;dist/css&apos;));});</code></pre><p>这时候在命令行敲入$ gulp sass发现已经跑起来了，但是存在两个问题</p><pre><code>每次修改完sass文件后都需要输入命令若sass有书写错误会直接退出gulp监听</code></pre><p>这两个问题我们放到最后再一起解决。</p><p>下面来为我们写的css的某些不兼容属性添加前缀。这里用到了插件gulp-autoprefixer，看一眼代码。其实都大同小异，大致的内容可在npmjs内查找到。</p><pre><code>var autoprefix = require(&apos;gulp-autoprefixer&apos;);gulp.task(&apos;autoprefixer&apos;, function () {return gulp.src(&apos;dist/css/**/*.css&apos;)    .pipe(autoprefixer({        browsers: [&apos;ios 5&apos;,&apos;android 2.3&apos;],        cascade: false    }))    .pipe(gulp.dest(&apos;dist/css&apos;));});</code></pre><p>下面测试一下，在scss写入一个css3属性</p><pre><code>perspective: 500;</code></pre><p>输入命令 $ gulp autoprefixer 发现文件没有更改。原因是sass文件还未被编译，这时候需要先敲一遍$ gulp sass编译。这时会发现css已经被添加了相印的后缀了</p><p><img src="/../about/1.png" alt="1111"></p><h4 id="开启服务器以及监听编译"><a href="#开启服务器以及监听编译" class="headerlink" title="开启服务器以及监听编译"></a>开启服务器以及监听编译</h4><p>终于到配置的最后一步了，我们的想法是当sass、js、html有所更改时都执行相印的命令。<br>如 自动压缩、合并文件、添加前缀、刷新浏览器</p><p>这里选用browser-sync同时我想当sass、sprite等文件改变时自动执行所需的task，使用watch命令对文件进行监听。话不多说，还是看源码。</p><pre><code>//=======================//     服务器 + 监听//=======================var browserSync = require(&apos;browser-sync&apos;).create();gulp.task(&apos;default&apos;, function() {    // 监听重载文件    var files = [    &apos;dist/html/**/*.html&apos;,    &apos;dist/css/**/*.css&apos;,    &apos;src/js/**/*.js&apos;,    &apos;src/sprite/**/*.png&apos;    ]    browserSync.init(files, {    server: {            baseDir: &quot;./&quot;,            directory: true        },    open: &apos;external&apos;,    startPath: &quot;dist/html/&quot;    });    // 监听编译文件    gulp.watch(&quot;dist/html/**/*.html&quot;).on(&apos;change&apos;, browserSync.reload);    gulp.watch(&quot;src/sass/**/*.scss&quot;, [&apos;sass&apos;]);    gulp.watch(&quot;src/sprite/**/*.png&quot;, [&apos;sprite&apos;]);    gulp.watch(&quot;dist/css/**/*.css&quot;, [&apos;autoprefixer&apos;]);});</code></pre><p>在命令行输入 $ gulp 这时我们的项目已经妥妥地跑起来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到gulp和webpack各种脚手架，这次来入门下这二种脚手架。&lt;/p&gt;
&lt;h2 id=&quot;Gulp快速入门&quot;&gt;&lt;a href=&quot;#Gulp快速入门&quot; class=&quot;headerlink&quot; title=&quot;Gulp快速入门&quot;&gt;&lt;/a&gt;Gulp快速入门&lt;/h2&gt;&lt;p&gt;首先确
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue项目实现记住密码到cookie功能</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/01/vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%88%B0cookie%E5%8A%9F%E8%83%BD/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/01/vue项目实现记住密码到cookie功能/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-07-29T03:22:04.111Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/1/30/161462f165cc17dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="效果图"></p><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h3><p>1.记住密码勾选，点登陆时，将账号和密码保存到cookie，下次登陆自动显示到表单内 2.不勾选，点登陆时候则清空之前保存到cookie的值，下次登陆需要手动输入</p><blockquote><p>大体思路就是通过存/取/删cookie实现的；每次进入登录页，先去读取cookie，如果浏览器的cookie中有账号信息，就自动填充到登录框中，存cookie是在登录成功之后，判断当前用户是否勾选了记住密码，如果勾选了，则把账号信息存到cookie当中，效果图如上：</p></blockquote><p>html代码</p><pre><code>&lt;div class=&quot;ms-login&quot;&gt;        &lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;0px&quot; class=&quot;demo-ruleForm&quot;&gt;            &lt;el-form-item prop=&quot;username&quot;&gt;                &lt;el-input v-model=&quot;ruleForm.username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;password&quot;&gt;                &lt;el-input type=&quot;password&quot; placeholder=&quot;密码&quot; v-model=&quot;ruleForm.password&quot; @keyup.enter.native=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;!-- `checked` 为 true 或 false --&gt;            &lt;el-checkbox v-model=&quot;checked&quot;&gt;记住密码&lt;/el-checkbox&gt;            &lt;br&gt;            &lt;br&gt;            &lt;div class=&quot;login-btn&quot;&gt;                &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&apos;ruleForm&apos;)&quot;&gt;登录&lt;/el-button&gt;            &lt;/div&gt;        &lt;/el-form&gt;&lt;/div&gt;</code></pre><p>js代码</p><pre><code>//页面加载调用获取cookie值    mounted() {        this.getCookie();    },    methods: {        submitForm(formName) {             const self = this;            //判断复选框是否被勾选 勾选则调用配置cookie方法            if (self.checked == true) {                console.log(&quot;checked == true&quot;);                //传入账号名，密码，和保存天数3个参数                self.setCookie(self.ruleForm.username, self.ruleForm.password, 7);            }else {              console.log(&quot;清空Cookie&quot;);              //清空Cookie              self.clearCookie();            }            //与后端请求代码，本功能不需要与后台交互所以省略            console.log(&quot;登陆成功&quot;);    });},//设置cookiesetCookie(c_name, c_pwd, exdays) {    var exdate = new Date(); //获取时间    exdate.setTime(exdate.getTime() + 24 * 60 * 60 * 1000 * exdays); //保存的天数    //字符串拼接cookie    window.document.cookie = &quot;userName&quot; + &quot;=&quot; + c_name + &quot;;path=/;expires=&quot; + exdate.toGMTString();    window.document.cookie = &quot;userPwd&quot; + &quot;=&quot; + c_pwd + &quot;;path=/;expires=&quot; + exdate.toGMTString();},//读取cookiegetCookie: function() {    if (document.cookie.length &gt; 0) {        var arr = document.cookie.split(&apos;; &apos;); //这里显示的格式需要切割一下自己可输出看下        for (var i = 0; i &lt; arr.length; i++) {            var arr2 = arr[i].split(&apos;=&apos;); //再次切割            //判断查找相对应的值            if (arr2[0] == &apos;userName&apos;) {                this.ruleForm.username = arr2[1]; //保存到保存数据的地方            } else if (arr2[0] == &apos;userPwd&apos;) {                this.ruleForm.password = arr2[1];            }        }    }},//清除cookieclearCookie: function() {    this.setCookie(&quot;&quot;, &quot;&quot;, -1); //修改2值都为空，天数为负1天就好了}</code></pre><blockquote><p>浏览器中的cookie信息如下图，注意这里cookie的expire/Max-Age过期时间，这个时间是格林尼治标准时间GMT，世界统一的时间，GMT+8小时就是北京时间。(这里不做加密功能)</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/1/30/161462f165b73ac8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ok"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/30/161462f165cc17dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端自动化构建环境的搭建</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/05/01/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/05/01/前端自动化环境构建/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-07-29T03:20:02.751Z</updated>
    
    <content type="html"><![CDATA[<p>Web前端使用工程化方式构建；</p><p>   目前需要一些简单的功能：</p><pre><code>1. 版本控制6. 编译SASS2. 检查JS3. 图片合并4. 压缩CSS5. 压缩JS</code></pre><p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p><p>目前最知名的构建工具： Gulp、Grunt、NPM + Webpack；</p><pre><code>grunt是前端工程化的先驱gulp更自然基于流的方式连接任务Webpack最年轻，擅长用于依赖管理，配置稍较复杂推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件</code></pre><h3 id="Use-Gulp-to-automate-front-end-build-tasks"><a href="#Use-Gulp-to-automate-front-end-build-tasks" class="headerlink" title="Use Gulp to automate front-end build tasks"></a>Use Gulp to automate front-end build tasks</h3><p>Gulp是基于 Node.js的，需要要安装 Node.js</p><p>1、为了确保依赖环境正确，我们先执行几个简单的命令检查。</p><pre><code>node -vNode是一个基于Chrome JavaScript V8引擎建立的一个解释器检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号</code></pre><p>2、接下来看看npm，它是 node 的包管理工具，可以利用它安装 gulp 所需的包</p><pre><code>npm -v这同样能得到npm的版本号，装 Node 时已经自动安装了npm</code></pre><p>3、开始安装Gulp</p><pre><code>npm install -g gulp全局安装 gulpgulp -v得到gulp的版本号，确认安装成功</code></pre><p>基础安装结束<br>-</p><p>4、切换到你的在项目根文件夹下，运行</p><pre><code>npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下</code></pre><p>5、安装gulp功能插件依赖包</p><pre><code>npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev</code></pre><blockquote><p>gulp功能模块的文件会放在项目所在的目录的./node_modules 下</p></blockquote><p>6、我们目前先使用一些简单的功能：</p><pre><code>- 检查Javascript- 编译Sass文件- 合并Javascript- 压缩合并并重命名Javascript</code></pre><blockquote><p>新建gulpfile.js 配置文件放在项目根目录下</p></blockquote><pre><code>演示项目目录结构   testProject        (项目名称)   |–.git             通过git进行版本控制,项目自动生成这个文件   |–node_modules     组件包目录   |–dist             **发布环境**（编译自动生成的）       |–css         样式文件(style.css style.min.css)       |–images     图片文件(压缩图片\合并后的图片)       |–js         js文件(main.js main.min.js)       |–index.html  静态页面文件(压缩html)   |–src             **开发环境**       |–sass                sass文件       |–images               图片文件       |–js                  js文件       |–index.html         静态文件   |–gulpfile.js              gulp配置文件   |–package.json             依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序</code></pre><blockquote><p>现在，项目文件夹都建好，组件也安装完毕了，我们需要编写gulpfile.js文件以指定gulp需要为我们完成什么任务。</p></blockquote><pre><code>gulpfile.js内容如下：// 引入gulpvar gulp = require(&apos;gulp&apos;);// 引入组件var jshint = require(&apos;gulp-jshint&apos;);//检查jsvar sass   = require(&apos;gulp-sass&apos;);    //编译Sassvar concat = require(&apos;gulp-concat&apos;);//合并var uglify = require(&apos;gulp-uglify&apos;);//uglify 组件（用于压缩 JS）var rename = require(&apos;gulp-rename&apos;);//重命名// 检查js脚本的任务gulp.task(&apos;lint&apos;, function() {    gulp.src(&apos;./js/*.js&apos;) //可配置你需要检查脚本的具体名字。        .pipe(jshint())        .pipe(jshint.reporter(&apos;default&apos;));});// 编译Sassgulp.task(&apos;sass&apos;, function() {    gulp.src(&apos;./scss/*.scss&apos;)        .pipe(sass())        .pipe(gulp.dest(&apos;./css&apos;));//dest()写入文件});// 合并，压缩js文件// 找到 js/ 目录下的所有 js 文件，压缩，重命名，最后将处理完成的js存放在 dist/js/ 目录下gulp.task(&apos;scripts&apos;, function() {    gulp.src(&apos;./js/*.js&apos;)        .pipe(concat(&apos;all.js&apos;))        .pipe(gulp.dest(&apos;./dist&apos;))        .pipe(rename(&apos;all.min.js&apos;))        .pipe(uglify())        .pipe(gulp.dest(&apos;./dist&apos;));        console.log(&apos;gulp task is done&apos;);//自定义提醒信息});.... // 其他任务类似// 定义默认任务,执行gulp会自动执行的任务gulp.task(&apos;default&apos;, function(){    gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;);    // 监听js文件变化，当文件发生变化后会自动执行任务    gulp.watch(&apos;./js/*.js&apos;, function(){        gulp.run(&apos;lint&apos;,&apos;scripts&apos;);    });});</code></pre><p>7、现在，回到命令行窗口，可以直接运行gulp任务了。</p><pre><code>gulp这将执行定义的default任务，就和以下的命令式同一个意思gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务：gulp sass</code></pre><p>8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心</p><pre><code>常见提醒：1.禁止在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</code></pre><p>9、gulp的插件数量很多，后面还可以根据自己的需要进行添加任务</p><pre><code>常用的gulp插件参考gulp-imagemin:         压缩图片gulp-ruby-sass:     支持sass，安装此版本需要安装rubygulp-minify-css:     压缩cssgulp-jshint:          检查jsgulp-uglify:          压缩jsgulp-concat:        合并文件gulp-rename:          重命名文件gulp-htmlmin:         压缩htmlgulp-clean:          清空文件夹gulp-livereload:     服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr）</code></pre><p>补充：ZSmart UED Team 的前端开发软件环境 (Windows, Linux, Mac OS X)</p><pre><code>安装Node.Js、NPM、Ruby、Java 基础环境Sublime Text3 + 插件           用于编写前端代码Google chrome 、Mozilla Firefox + FirebugInternet Explorer             进行兼容测试和预览页面UI、动画效果和交互功能Node.js+Gulp                 进行前端自动化构建、JS语法验证、CSS压缩，图片压缩等；Koala                         实时编译Less、Sass、Compass、CoffeeScript;Github                         存储自己的代码库 、git或SVN用于版本控制和团队Code ReviewTomcat、DedeAMPZ、MAMP      进行简单运行环境演示Photoshop CC 切图 + Sprites 合并小图标XMind                         画出清晰的工作或业务逻辑思维图</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web前端使用工程化方式构建；&lt;/p&gt;
&lt;p&gt;   目前需要一些简单的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 版本控制
6. 编译SASS
2. 检查JS
3. 图片合并
4. 压缩CSS
5. 压缩JS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些都是每个Web项目在构建、开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue组件之间的数据传递及共享</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/04/21/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/04/21/vue组件之间的数据传递/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-07-29T03:19:14.006Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理项目中代码，在组件之间数据传递遇到了问题，所以做了这次总结，如有不对的地方，望指正。</p><h3 id="父组件如何将数据传到子组件中"><a href="#父组件如何将数据传到子组件中" class="headerlink" title="父组件如何将数据传到子组件中"></a>父组件如何将数据传到子组件中</h3><p>父组件可以通过Prop传递数据到子组件中。</p><p>这里需要注意的是：</p><pre><code>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。每次父组件更新时，子组件的所有 Prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</code></pre><p> 在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><p>1、Prop 作为初始值传入后，子组件想把它当作局部数据来用；</p><p>解决方法：定义一个局部变量，并用 prop 的值初始化它：</p><pre><code>props: [&apos;initialCounter&apos;],data: function () {return { counter: this.initialCounter }}    </code></pre><p>2、Prop 作为原始数据传入，由子组件处理成其它数据输出。</p><p>解决方法： 定义一个计算属性，处理 prop 的值并返回：</p><pre><code>props: [&apos;size&apos;],computed: {normalizedSize: function () {    return this.size.trim().toLowerCase()}}</code></pre><p>PS：上边的内容是vue文档里边有说的，我只是把自己在项目中遇到的问题抽出来了。</p><pre><code>// 父组件 index.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;child :lists=&quot;lists&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import child from &apos;./child.vue&apos;;    export default {        components: {            child        },        data() {            return {                lists: []            };        },        mounted() {            this.lists = [{                name: &apos;01&apos;,                content: &apos;hi,&apos;            }, {                name: &apos;02&apos;,                content: &apos;my name is Ellyliang&apos;            }];        }    };&lt;/script&gt;// 子组件 child.vue&lt;template&gt;    &lt;ul class=&quot;content&quot;&gt;    &lt;li v-for=&quot;(list, index) in getLists&quot; :key=&quot;index&quot; v-html=&quot;list.name + list.content&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&apos;lists&apos;],        data() {            return {                getLists: this.lists            };        },        mounted() {            this.getLists.push({                name: &apos;03&apos;,                content: &apos;不要在乎内容，我就是测试&apos;            });        }    };&lt;/script&gt;</code></pre><h3 id="子组件如何将数据传到父组件中"><a href="#子组件如何将数据传到父组件中" class="headerlink" title="子组件如何将数据传到父组件中"></a>子组件如何将数据传到父组件中</h3><p>子组件可通过vm.$emit将数据传递给父组件</p><p> <strong>vm.$emit是啥</strong></p><p>触发当前实例上的事件。附加参数都会传给监听器回调</p><pre><code>// 父组件 index.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;child :lists=&quot;lists&quot; @listenToChild=&quot;getChildMsg&quot;&gt;&lt;/child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import child from &apos;./child.vue&apos;;    export default {        components: {            child        },        data() {            return {                lists: []            };        },        mounted() {            this.lists = [{                name: &apos;01&apos;,                content: &apos;hi,&apos;            }, {                name: &apos;02&apos;,                content: &apos;my name is Ellyliang&apos;            }];        },        methods: {            getChildMsg(val) {                alert(val);  // &apos;hello&apos;            }        }    };&lt;/script&gt;// 子组件 child.vue&lt;template&gt;    &lt;div class=&quot;content&quot;&gt;        &lt;ul class=&quot;lists&quot;&gt;            &lt;li v-for=&quot;(list, index) in getLists&quot; :key=&quot;index&quot; v-html=&quot;list.name + list.content&quot;&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        props: [&apos;lists&apos;],        data() {            return {                getLists: this.lists            };        },        mounted() {            this.getLists.push({                name: &apos;03&apos;,                content: &apos;不要在乎内容，我就是测试&apos;            });            setTimeout(() =&gt; {                this.$emit(&apos;listenToChild&apos;, &apos;hello&apos;);            }, 15000);        }    };&lt;/script&gt;</code></pre><p>子组件给父组件传数据是不是也很方便。实现方法是就是在子组件中$emit数据，然后在父组件中通过事件@事件名接收值。</p><h3 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h3><p>事件巴士这种方法，不仅能处理父子组件传递，子父组件传递，还是处理平级组件之间的数值传递。其实现方法就是在全局new一个vue实例，然后传值给bus, 就是let bus = new vue();。通过这个全局的bus中的$emit, $on等等去实现数据的传递。这样处理有个问题，由于event bus处理数据传递很方便，不管在哪里都可以传递，这样导致滥用，从而导致代码很难去理解。</p><p> Event Bus实现</p><pre><code>let bus = new Vue();// 触发组件 A 中的事件bus.$emit(&apos;id-selected&apos;, 1);// 在组件 B 创建的钩子中监听事件bus.$on(&apos;id-selected&apos;, function (id) {// ...});</code></pre><p>具体组件的封装和使用，可参考vue-bus。</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>vuex官网的专业术语，让有些人还是感觉，摸不着头脑，做一些实用场景给大家看</p><pre><code>state 用来数据共享数据存储mutation 用来注册改变数据状态getters 用来对共享数据进行过滤操作action 解决异步改变共享数据</code></pre><p>此时采用的演示方式还是用官方提供的vue-cli webpack版本</p><p>在src目录下我们创一个vuex文件夹，分别创建index.js,mutations.js,state.js,getters.js,actions.js</p><p>这样我们可对四种特性进行分文件，这样可以更加明确，清楚</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/74a488ee6821acb7e263.png" alt="目录"></p><p>我们分别把这四个特性放入index.js中进行store的实列化</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/df4e0b9aed60a84d45ef.png" alt="state主目录"></p><p>再把实列化的store引入就是所谓的index.js文件夹引入到main.js中，也可以同时把store注册到每一个组件中</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/60c0bddd7c2b31df2879.png" alt="state实例化"></p><h4 id="state如何用？"><a href="#state如何用？" class="headerlink" title="state如何用？"></a>state如何用？</h4><p>在页面中，title肯定是必备，那每个组件页面的title都肯定不一样，那我们如何去拿到title,title适合放在那里，根据每个页面切换，而改变title,这个牵扯的就是组件与组件中的通信</p><p>我们可以在state.js中先声明一数据值</p><pre><code>export default{    title : &quot;首页&quot;}</code></pre><p><strong>那我们如何在首页中拿到这个title值</strong></p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/a6dfd2f072b4b9a012e9.jpg" alt=""></p><p>那我们在mian.js中再加入new Vue,绑定title作用域的实例代码</p><p>我们在computed里进行数据监听，</p><p>此时我们就可以从store里拿到state.title</p><p>最后一步，我们在index.html中我们再进行vue组件之间的数据传递及共享绑定</p><p><strong>index.html</strong></p><pre><code>&lt;title&gt;{{title}}&lt;/title&gt;</code></pre><p>此时我们运行一下，打开dev-tools你会发现</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/46eded6760bba9be1619.jpg" alt=""></p><p>title这个数据已经在全局被共享了</p><h4 id="matutions如何使用"><a href="#matutions如何使用" class="headerlink" title="matutions如何使用"></a>matutions如何使用</h4><p>应用场景：</p><p>如果我们要改变顶层的共享数据，我们应该要用matutions来进行改变，如果你做公众号，后台一般会在连接的上给你一些参数，比方说sid,ck,tm,或者一些其它东西，你想把他存在state中，如果去做，那我们就通过matutions来进行注册事件，为了演示，我才这么做</p><p>注意：<br>对于vuex，我只推荐state状态存储只在一个页面中组件与组件之间的通信，不适合跨页面， 放一些状态</p><p><strong>state.js</strong></p><pre><code>export default{    START_PARMA : {},    title : &quot;首页&quot;}</code></pre><p>START_PARMA用来存放我以上连接参数的数据，我们先前一定要定意好</p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    state.START_PARMA = Object    }}</code></pre><p>我们对改变state数据进行一个事件注册，第一个参数是拿到state对象，第二个是传入的参数</p><ul><li>getParam官方说是type，其实就是注册的事件名</li><li>可以是单个参数</li><li><p>如果是多个参数，我们则用对象放入，如果你写两个参数，会报错</p><pre><code>export default {        name : &apos;advertisement&apos;,        created () {            const keyCode = sessionStorage.keyCode = getQueryString(&apos;keyCode&apos;)            const keyWord = sessionStorage.keyWord =  keyCode.split(&quot;_&quot;)[0]            const hunterCode = sessionStorage.hunterCode = keyCode.split(&quot;_&quot;)[1]            const sid = sessionStorage.sid= getQueryString(&apos;sid&apos;)            const ck = sessionStorage.ck = getQueryString(&apos;ck&apos;)            const tm = sessionStorage.tm = getQueryString(&apos;tm&apos;)            this.$store.commit(&apos;getParam&apos;,{                keyCode,                keyWord,                hunterCode,                sid,                ck,                tm            })        }    }</code></pre></li></ul><p>我们自己创建一个视图，然后在created里进行截取参数，因为store是注册到每个组件中的，所以我们要用this.$store来访问，那commit就是一个触发器，第一个是type类形名，第二个参我们用对象的方式传入，里面用的是es6的语法</p><p>此时你会发现</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/f0aa5d0df0fbe76c49f3.png" alt=""></p><p>此时的截取的状态放到了一个对象里，我们就可以使用了</p><h4 id="getters如何使用"><a href="#getters如何使用" class="headerlink" title="getters如何使用"></a>getters如何使用</h4><p>如果说getter就是对state里的数据进行一些过滤，改造等等</p><p>那比方说State里有一些这样的数据</p><p><strong>state.js</strong></p><pre><code>people : [        {name : &apos;ziksang1&apos;,age:21},        {name : &apos;ziksang2&apos;,age:10},        {name : &apos;ziksang3&apos;,age:30},        {name : &apos;ziksang4&apos;,age:40},        {name : &apos;ziksang5&apos;,age:50},        {name : &apos;ziksang6&apos;,age:30},        {name : &apos;ziksang7&apos;,age:80}    ]</code></pre><p>如果我们定义这些数据，然后我们要从，这些数据中筛选出年纪大于30的人，再进行返回，我们就可以用到getter,这里的getter的意思就是对vuex顶层数据进行过滤，而不改动state里原本的数据</p><p><strong>getters.js</strong></p><pre><code>export default{    changePeople: (state) =&gt;{        return state.people.filter(item=&gt;{            if(item.age&gt;30){                return true            }        })    }}</code></pre><p>好我们如何应用呢，我们在组件中里只要写入</p><pre><code>created () {        console.log(this.changePeople)},computed : {            changePeople () {                return this.$store.getters.changePeople            }},</code></pre><p>那我们可以打开命台看一下，看回的数据，</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/6dca03740c0b56087763.jpg" alt=""><br>接下来你如何想对数据进行操作那就看你自己的了</p><h4 id="action-如何使用？"><a href="#action-如何使用？" class="headerlink" title="action 如何使用？"></a>action 如何使用？</h4><p>action.是用来解决异步流程来改变state数据的，有想人说，那我直接在matution里面进行写进不就行了麻，那你可以试一下，因为matution是直接进行同步操作的</p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    setTimeout(()=&gt;{            state.START_PARMA = Object    },1000)    }}</code></pre><p>还是拿上面例子，如果你在mutations里进行异步操作，你会发现没用，并不会起任何效果，那怎么办，只有通过action-&gt;mutations-&gt;states,这个流程进行操作</p><p><strong>action.js</strong></p><pre><code>export default {    getParamSync (context,Object) {        setTimeout(()=&gt;{            context.commit(&apos;getParam&apos;,Object)        },3000)    }}</code></pre><p>写一个getParamSync函灵敏，第一个参数就是上下文，context是一个store对象，你也可以用解构的方式写出来,第二个参数还是我们要写入的接收到的参数，来改变触发mutations事件,再通过mutation来改变state,很好理解不难</p><p>然后我们就在组件里这么调用就可以了</p><pre><code>this.$store.dispatch(&apos;getParamSync&apos;,{    keyCode,    keyWord,    hunterCode,    sid,    ck,    tm})</code></pre><p>那组合action又是怎么玩呢？我们有时候向后台请求时，要通过第一个AJAX返回值来进行下一个action分发</p><p>我们可以用promise来进行异步处理</p><p><strong>actions.js</strong></p><pre><code>export default {    getParamSync (context,Object) {        return new Promise((reslove,reject)=&gt;{            setTimeout(()=&gt;{                context.commit(&apos;getParam&apos;,Object)                return reslove(&apos;成功&apos;)            },3000)        })    },    changetitleSync ({commit},title){        setTimeout(()=&gt;{            commit(&apos;changetitle&apos;,title)        },3000)    }}</code></pre><p>在getParamSync使用new promise之后，在resolve里返回‘成功’，再分发一个changetitleSync改变title的action方法</p><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/4a3b12a68fd64e5aa0ea.png" alt=""></p><p><strong>mutations.js</strong></p><pre><code>export default{    getParam (state,Object) {    state.START_PARMA = Object    },    changetitle (state,title){        state.title = title    }}</code></pre><p>再在注册一个改变title的changetitle的type类型</p><p><strong>组中间调用</strong></p><pre><code>created(){this.$store.dispatch(&apos;getParamSync&apos;,{                keyCode,                keyWord,                hunterCode,                sid,                ck,                tm            }).then((res)=&gt;{                this.$store.dispatch(&apos;changetitleSync&apos;,res)            })}</code></pre><p>我们就可以在组件中进行一种链式调用，解决异步回调，来action套action,就成了一个组合action</p><p><strong>关于其它辅助用法</strong></p><ul><li>mapState 辅助函数</li><li>mapGetters 辅助函数</li><li>mapMutations 辅助函数</li><li>mapActions 辅助函数</li></ul><p>尤大神已经写的很全面了，大家可以参考vuex的官网，进行阅读一下。我在这里就没有必要再进行重新讲解了</p><p><strong>在vuex中，我认为vuex用在那里比较好？</strong></p><p>只适合运用于一个视图内组件与组件之间的组合传递，不适用于跨页面，但是可以共用，为了不因用户刷新页面，要进行初始化再次调用。</p><p><strong>不适合运用在那里</strong></p><p>在自己写一些Ui组件给大家或者开源用的话，不适用于写在vuex中，应该暴露所接收的Props,通过$emit来进行触发事件，一些关键性全局状态，不也适合存vuex中，你可以选择localStorage,sessionStorage</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理项目中代码，在组件之间数据传递遇到了问题，所以做了这次总结，如有不对的地方，望指正。&lt;/p&gt;
&lt;h3 id=&quot;父组件如何将数据传到子组件中&quot;&gt;&lt;a href=&quot;#父组件如何将数据传到子组件中&quot; class=&quot;headerlink&quot; title=&quot;父组件如何将数据传
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongodb常用操作指令</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/03/29/mongodb%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/03/29/mongodb使用方法/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-07-29T03:19:00.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建简单mongodb服务器"><a href="#1-创建简单mongodb服务器" class="headerlink" title="1.创建简单mongodb服务器"></a>1.创建简单mongodb服务器</h3><ul><li><p><code>mongod --dbpath E:\MongoDB\db</code></p></li><li><p><code>mongo.exe</code></p></li></ul><h3 id="2-数据库操作-CRUD"><a href="#2-数据库操作-CRUD" class="headerlink" title="2.数据库操作(CRUD)"></a>2.数据库操作(CRUD)</h3><ul><li><p>显示数据库名称：<code>show dbs</code></p></li><li><p>切换数据库：<code>use &lt;dbname&gt;</code></p></li><li><p>删除当前数据库：<code>db.dropDatabase()</code></p></li><li><p>想要新建数据库，直接使用<code>use &lt;dbname&gt;</code>,在需要的时候会自动创建</p></li><li><p>新建表<code>db.&lt;表名&gt;.insert({})</code>;数据以json的格式</p></li><li><p>显示表名 ：<code>show collections</code></p></li></ul><blockquote><p>例子</p></blockquote><pre><code>&gt; use exapmledb&gt; db.ex_collection1.insert({x:1}) //在表ex_collection1中插入数据{x:1}&gt; show collections输出：ex_collection1system.indexes</code></pre><h4 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h4><ul><li><p>查询 ：<code>db.&lt;表名&gt;.find()</code> 默认返回所有数据</p><p>  <code>&gt; db.ex_collection1.find()</code> </p></li><li><p>查询表中数据，默认返回所有</p><p>  <code>{ &quot;_id&quot; : ObjectId(&quot;58e9e1c6d6ffabd315a4f74a&quot;), &quot;x&quot; : 1 }</code></p><p>  数据库会自动生成一个<code>_id</code>，也可以自己添加，但不能重复</p></li><li><p>条件查询：db.ex_collection1.find({x:1})</p></li><li><p>循环插入</p><p>  <code>&gt; for(i=2;i&lt;50;i++)db.ex_collection1.insert({x:i})</code></p></li><li><p>计算查询出来的总数</p><p>  <code>&gt; db.ex_collection1.find().count()</code>  </p></li><li><p>增加查询条件,下面表示，过滤前3条，返回两条，并且以x排序</p><p>  <code>db.ex_collection1.find().skip(3).limit(2).sort({x:1})</code></p><h4 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2 更新"></a>2.2 更新</h4></li><li><p>更新数据，比如将<code>x：1</code>的数据改为<code>x：999</code></p><p>  <code>db.ex_collection1.update({x:1},{x:999})</code> </p></li><li><p>部分更新，比如有数据{x:100, y:100, z:100},想要以z:100为条件，更新里面的y为99；</p><p>  <code>db.ex_collection1.update({z:100},{$set:{y:99}})</code></p></li><li><p>更新一条不存在的数据，如果查找y为100的数据，改为y：999，如果不存在的话就直接写入y：999数据,增加第三个参数true即可。</p><p>  <code>db.ex_collection1.update({y:100},{y:999},true)</code></p></li><li><p>更新多条数据，mongodb默认更新一条数据，比如有三条c为1的数据，使用前面方式更新只会修改第一条。</p><p>  <code>db.immoc_collection.update({c:1},{$set:{c:2}},false,true)</code></p></li></ul><h4 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h4><ul><li><p>删除数据</p><p>  <code>db.immoc_collection.remove({c:2})</code></p></li><li><p>删除表</p><p>  <code>db.ex_collection1.drop()</code></p></li></ul><h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h3><h4 id="3-1-查询创建索引"><a href="#3-1-查询创建索引" class="headerlink" title="3.1 查询创建索引"></a>3.1 查询创建索引</h4><ul><li><p>查询索引</p><p>  <code>db.ex_collection1.getIndexes()</code></p></li><li><p>创建索引(这里的1代表为正向，-1为负向索引)</p><p>  <code>db.imooc_collection.ensureIndex({x:1})</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-创建简单mongodb服务器&quot;&gt;&lt;a href=&quot;#1-创建简单mongodb服务器&quot; class=&quot;headerlink&quot; title=&quot;1.创建简单mongodb服务器&quot;&gt;&lt;/a&gt;1.创建简单mongodb服务器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单实现VUE中的MVVM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/03/09/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0VUE%E4%B8%AD%E7%9A%84MVVM/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/03/09/简单实现VUE中的MVVM/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-07-29T03:21:28.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p>首先，我们需要了解一下 js 中的一个 API :<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty(obj, prop, descriptor)</a></p><p>一般情况下我们为一个对象添加一个属性一般都会这么写</p><pre><code>let object = {}object.test = &apos;test&apos;</code></pre><p>Object.defineProperty 也能做到同样的效果</p><pre><code>let object = {}, test = &apos;test&apos;Object.defineProperty(object, &apos;test&apos;, {    configurable: true,            // 描述该属性的描述符能否被改变，默认值为 false    enumerable: true,               // 能否被遍历，比如 for in，默认值为 false    get: function(){                // 取值的时候调用，object.test，默认值为 false        console.log(&apos;enter get&apos;)        return test    },    set: function(newValue){        // 设置值的时候使用        console.log(&apos;enter set&apos;)        test = newValue    }})</code></pre><p>这样写虽然代码量多了不少，但是却拥有了控制属性取值和设置值的权利，让我们来测试一下。</p><pre><code> object.test// enter get// testobject.test = &apos;test2&apos;// enter set// test2</code></pre><p>接着我们把 defindProperty 这个函数封装同时改造一下，方便我们调用</p><pre><code>let callback = {    target: null}let defineReactive = function(object, key, value){    let array = []    Object.defineProperty(object, key, {        configurable: true,        enumerable: true,        get: function(){            if(callback.target){                array.push(callback.target)            }            return value        },        set: function(newValue){            if(newValue != value){                array.forEach((fun)=&gt;fun(newValue, value))            }            value = newValue        }    })}</code></pre><p>可以从代码中看出来，我在函数内部声明了一个数组用于存放 <strong>callback</strong> 中的 <strong>target</strong>，当对 <strong>object</strong> 进行 <strong>get</strong> 操作(取值操作)的时候，就会往 <strong>callback</strong> 中存放函数，进行 <strong>set</strong> 操作(设置值)的时候执行数组中的函数。看看效果如何</p><pre><code>let object = {}defineReactive(object, &apos;test&apos;, &apos;test&apos;)callback.target = function(newValue, oldValue){console.log(&apos;我被添加进去了，新的值是：&apos; + newValue)}object.test// testcallback.target = nullobject.test = &apos;test2&apos;// 我被添加进去了，新的值是：test2callback.target = function(newValue, oldValue){console.log(&apos;添加第二个函数，新的值是：&apos; + newValue)}object.test// testcallback.target = nullobject.test = &apos;test3&apos;// 我被添加进去了，新的值是：test3// 添加第二个函数，新的值是：test3</code></pre><p>这样我们就达成了在 object.test 的值发生改变时，运行一个函数队列（虽然这个队列挺简陋的）的目的。</p><p>换个说法，当我们取值的时候，函数自动帮我们添加了针对当前值的依赖，当这个值发生变化的时候，处理了这些依赖，比如说 DOM 节点的变化。</p><p>这个也是 VUE 中实现 MVVM 的最核心的代码，当然在 VUE 中，这个依赖收集的过程远比现在的代码要复杂，这里仅仅实现了依赖的收集和触发，对于依赖的管理这里的代码还做不到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;defineProperty&quot;&gt;&lt;a href=&quot;#defineProperty&quot; class=&quot;headerlink&quot; title=&quot;defineProperty&quot;&gt;&lt;/a&gt;defineProperty&lt;/h2&gt;&lt;p&gt;首先，我们需要了解一下 js 中的一个 AP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从头实现一个koa框架</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/01/09/koa%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/01/09/koa框架/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2018-07-29T03:18:36.950Z</updated>
    
    <content type="html"><![CDATA[<p>看完之后甚是膜拜，决定收藏记录下，引用地址<a href="https://zhuanlan.zhihu.com/p/35040744" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35040744</a></p><p>笔者认为，理解koa，主要需要搞懂四条主线，其实也是实现koa的四个步骤，</p><p>   分别是：</p><pre><code>1. 封装node http Server2. 构造resquest, response, context对象3. 中间件机制4. 错误处理</code></pre><h4 id="主线一：封装node-http-Server-从hello-world说起"><a href="#主线一：封装node-http-Server-从hello-world说起" class="headerlink" title="主线一：封装node http Server: 从hello world说起"></a>主线一：封装node http Server: 从hello world说起</h4><p>首先，不考虑框架，如果使用原生http模块来实现一个返回hello world的后端app，代码如下：</p><pre><code>let http = require(&apos;http&apos;);let server = http.createServer((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});server.listen(3000, () =&gt; {    console.log(&apos;listenning on 3000&apos;);});</code></pre><p>实现koa的第一步，就是对这个原生的过程进行封装，为此，我们首先创建application.js实现一个Application对象：</p><pre><code>// application.jslet http = require(&apos;http&apos;);class Application {    /**    * 构造函数    */    constructor() {        this.callbackFunc;    }    /**    * 开启http server并传入callback    */    listen(...args) {        let server = http.createServer(this.callback());        server.listen(...args);    }    /**    * 挂载回调函数    * @param {Function} fn 回调处理函数    */    use(fn) {        this.callbackFunc = fn;    }    /**    * 获取http server所需的callback函数    * @return {Function} fn    */    callback() {        return (req, res) =&gt; {            this.callbackFunc(req, res);        };    }}module.exports = Application;</code></pre><p>然后创建example.js:</p><pre><code>let simpleKoa = require(&apos;./application&apos;);let app = new simpleKoa();app.use((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});app.listen(3000, () =&gt; {    console.log(&apos;listening on 3000&apos;);});</code></pre><p>可以看到，我们已经初步完成了对于http server的封装，主要实现了app.use注册回调函数，app.listen语法糖开启server并传入回调函数了，典型的koa风格。</p><p>但是美中不足的是，我们传入的回调函数，参数依然使用的是req和res，也就是node原生的request和response对象，这些原生对象和api提供的方法不够便捷，不符合一个框架需要提供的易用性。因此，我们需要进入第二条主线了。</p><h4 id="主线二：构造request-response-context对象"><a href="#主线二：构造request-response-context对象" class="headerlink" title="主线二：构造request, response, context对象"></a>主线二：构造request, response, context对象</h4><p>如果阅读koa文档，会发现koa有三个重要的对象，分别是request, response, context。其中request是对node原生的request的封装，response是对node原生response对象的封装，context对象则是回调函数上下文对象，挂载了koa request和response对象。下面我们一一来说明。</p><p>首先要明确的是，对于koa的request和response对象，只是提供了对node原生request和response对象的一些方法的封装，明确了这一点，我们的思路是，使用js的getter和setter属性，基于node的对象req/res对象封装koa的request/response对象。</p><p>规划一下我们要封装哪些易用的方法。这里在文章中为了易懂，姑且只实现以下方法：</p><p>对于simpleKoa request对象，实现query读取方法，能够读取到url中的参数，返回一个对象。</p><p>对于simpleKoa response对象，实现status读写方法，分别是读取和设置http response的状态码，以及body方法，用于构造返回信息。</p><p>而simpleKoa context对象，则挂载了request和response对象，并对一些常用方法进行了代理。</p><p>首先创建request.js:</p><pre><code>// request.jslet url = require(&apos;url&apos;);module.exports = {    get query() {        return url.parse(this.req.url, true).query;    }};</code></pre><p>很简单，就是导出了一个对象，其中包含了一个query的读取方法，通过url.parse方法解析url中的参数，并以对象的形式返回。需要注意的是，代码中的this.req代表的是node的原生request对象，this.req.url就是node原生request中获取url的方法。稍后我们修改application.js的时候，会为koa的request对象挂载这个req。</p><p>然后创建response.js:</p><pre><code>// response.jsmodule.exports = {    get body() {        return this._body;    },    /**    * 设置返回给客户端的body内容    *    * @param {mixed} data body内容    */    set body(data) {        this._body = data;    },    get status() {        return this.res.statusCode;    },    /**    * 设置返回给客户端的stausCode    *    * @param {number} statusCode 状态码    */    set status(statusCode) {        if (typeof statusCode !== &apos;number&apos;) {            throw new Error(&apos;statusCode must be a number!&apos;);        }        this.res.statusCode = statusCode;    }};</code></pre><p>status读写方法分别设置或读取this.res.statusCode。同样的，这个this.res是挂载的node原生response对象。而body读写方法分别设置、读取一个名为this._body的属性。这里设置body的时候并没有直接调用this.res.end来返回信息，这是考虑到koa当中我们可能会多次调用response的body方法覆盖性设置数据。真正的返回消息操作会在application.js中存在。</p><p>然后我们创建context.js文件，构造context对象的原型：</p><pre><code>// context.jsmodule.exports = {    get query() {        return this.request.query;    },    get body() {        return this.response.body;    },    set body(data) {        this.response.body = data;    },    get status() {        return this.response.status;    },    set status(statusCode) {        this.response.status = statusCode;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完之后甚是膜拜，决定收藏记录下，引用地址&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35040744&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/35040744
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript创建对象和实现继承</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2018/01/09/JAVASCRIPT%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2018/01/09/JAVASCRIPT对象/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2018-07-29T03:21:30.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript创建对象"><a href="#JavaScript创建对象" class="headerlink" title="JavaScript创建对象"></a>JavaScript创建对象</h2><h3 id="构造函数模式创建对象"><a href="#构造函数模式创建对象" class="headerlink" title="构造函数模式创建对象"></a>构造函数模式创建对象</h3><pre><code>function Person(name, job) {    this.name = name    this.job = job    this.sayName = function() {        console.log(this.name)    }}var person1 = new Person(‘Jiang’, ‘student’)var person2 = new Person(‘X’, ‘Doctor’)</code></pre><p>没有显示的创建对象，使用new来调用这个构造函数，使用new后会自动执行如下操作</p><pre><code>创建一个新对象这个新对象会被执行[[prototype]]链接这个新对象会绑定到函数调用的this返回这个对象</code></pre><p>使用这个方式创建对象可以检测对象类型</p><pre><code>person1 instanceof Object // trueperson1 instanceof Person //true</code></pre><p>但是使用构造函数创建对象，每个方法都要在每个实例上重新创建一次</p><h3 id="原型模式创建对象"><a href="#原型模式创建对象" class="headerlink" title="原型模式创建对象"></a>原型模式创建对象</h3><pre><code>function Person() {}Person.prototype.name = ‘Jiang’Person.prototype.job = ‘student’Person.prototype.sayName = function() {console.log(this.name)}var person1 = new Person()</code></pre><p>将信息直接添加到原型对象上。使用原型的好处是可以让所有的实例对象共享它所包含的属性和方法，不必在构造函数中定义对象实例信息。</p><p>原型是一个非常重要的概念，在一篇文章看懂proto和prototype的关系及区别中讲的非常详细</p><p>更简单的写法</p><pre><code>function Person() {}Person.prototype = {name: ‘jiang’,job: ‘student’,sayName: function() {    console.log(this.name)}}var person1 = new Person()</code></pre><p>将Person.prototype设置为等于一个以对象字面量形式创建的对象，但是会导致.constructor不在指向Person了。</p><p>使用这种方式，完全重写了默认的Person.prototype对象，因此 .constructor也不会存在这里</p><p>Person.prototype.constructor === Person  // false<br>如果需要这个属性的话，可以手动添加</p><pre><code>function Person() {}Person.prototype = {    constructor：Person    name: ‘jiang’,    job: ‘student’,    sayName: function() {        console.log(this.name)    }}</code></pre><p>不过这种方式还是不够好，应为constructor属性默认是不可枚举的，这样直接设置，它将是可枚举的。所以可以时候，Object.defineProperty方法</p><pre><code>Object.defineProperty(Person.prototype, ‘constructor’, {enumerable: false,value: Person})</code></pre><p>缺点使用原型，所有的属性都将被共享，这是个很大的优点，同样会带来一些缺点</p><p>原型中所有属性实例是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也勉强可以，毕竟实例属性可以屏蔽原型属性。但是引用类型值，就会出现问题了</p><pre><code>function Person() {}Person.prototype = {    name: ‘jiang’,    friends: [‘Shelby’, ‘Court’]}var person1 = new Person()var person2 = new Person()person1.friends.push(‘Van’)console.log(person1.friends) //[“Shelby”, “Court”, “Van”]console.log(person2.friends) //[“Shelby”, “Court”, “Van”]console.log(person1.friends === person2.friends) // true</code></pre><p>friends存在与原型中，实例person1和person2指向同一个原型，person1修改了引用的数组，也会反应到实例person2中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript创建对象&quot;&gt;&lt;a href=&quot;#JavaScript创建对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript创建对象&quot;&gt;&lt;/a&gt;JavaScript创建对象&lt;/h2&gt;&lt;h3 id=&quot;构造函数模式创建对象&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript之闭包</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/12/29/Javascript%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/12/29/Javascript之闭包/</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2018-07-29T03:21:32.552Z</updated>
    
    <content type="html"><![CDATA[<p>面试当中总觉得自己也不是特别明白，今天过来总结一下。</p><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>JavaScript的闭包是一个特色。官方解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。这句话相信有许多人看不懂。我来表述一下我对JavaScript闭包的理解：</p><p>闭包的例子：</p><pre><code>var count=10;//全局作用域 标记为flag1function add(){    var count=0;//函数全局作用域 标记为flag2    return function(){        count+=1;//函数的内部作用域        alert(count);    }}var s=add()s();//输出1s();//输出2</code></pre><p>add()的返回值是一个函数，首先第一次调用s()的时候，是执行add()的返回的函数，也就是下面这个函数：</p><pre><code>function(){        count+=1;//函数的内部作用域        alert(count);}</code></pre><p>也就是将count+1，在输出，那count是从哪儿来的的呢，根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count ，</p><pre><code>var count=10;//全局作用域function add(){    //var count=0;注释掉了    return function(){        count+=1;//函数的内部作用域        alert(count);    }}var s=add()s();//输出11s();//输出12</code></pre><p>自然这是体现不出闭包的性质，只为了说明函数作用域链 继续说明：第一次执行，是没有疑问的输出1，那第二次的过程是怎样的呢？ 继续执行那个函数的返回的方法，还是count+=1;然后再输出count ，这里问题就来了，不应该继续向上寻找，找到count=0；然后输出1吗？不知道有没有注意一个问题，那就是s()执行的是下面这个函数</p><pre><code>function(){        count+=1;//函数的内部作用域        alert(count);}</code></pre><p>也就是说add()，只被执行了一次。然后执行两次s()，那count的值就是只声明了一次。</p><p>var s=add()，函数add 只在这里执行了一次。</p><p>下面执行的都是s()，那第二次的count的值是从哪儿来的，没错它还是第一次执行add时，留下来的那个变量。</p><p>（这怎么可能，函数变量执行完就会被释放啊，为什么还在？这里就是一个垃圾回收机制的引用计数问题）。</p><blockquote><p>如果一个变量的引用不为0，那么他不会被垃圾回收机制回收，引用，就是被调用</p></blockquote><p>由于再次执行s()的时候，再次引用了第一次add()产生的变量count ，所以count没有被释放，第一次s(),count 的值为1,第二次执行s()，count的值再加1，自然就是2了。</p><p>让我们返回来再看看，根据以上所说，如果执行两次add() ，那就应该输出 都是1，来改一下这个函数</p><pre><code>function add(){    var count=0;//函数全局作用域    return function(){        count+=1;//函数的内部作用域        alert(count);    }}add()();//输出1add()();//输出1</code></pre><p>果真如此。输出的两次都是1.</p><p>另外，我觉得阮一峰说的闭包也是很简洁的：“我的理解是，闭包就是能够读取其他函数内部变量的函数。”</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p><p>变量的作用域无非就是两种：全局变量和局部变量。</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><p>Js代码</p><pre><code>　　var n=999;　　function f1(){　　　　alert(n);　　}　　f1(); // 999</code></pre><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p><pre><code>　  function f1(){　　　　var n=999;　　}　　alert(n); // error</code></pre><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p><pre><code>　　function f1(){　　　　n=999;　　}　　f1();　　alert(n); // 999   </code></pre><p>有时候需要得到函数内的局部变量，在函数的内部，再定义一个函数。</p><pre><code>function f1(){    　　　　n=999;    　　　　function f2(){    　　　　　　alert(n); // 999    　　　　}    　　}</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值就可以在f1外部读取它的内部变量了</p><pre><code>    　function f1(){    　　　　n=999;    　　　　function f2(){    　　　　　　alert(n);    　　　　}    　　　　return f2;    　　}    　　var result=f1();    　　result(); // 999</code></pre><h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><ul><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p></li><li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便<strong>改变父函数内部变量的值。</strong></p></li></ul><p>###闭包的用途</p><p>1、前面提到的可以读取函数内部的变量</p><p>2、让这些变量的值始终保持在内存中。</p><p>怎么来理解这句话呢？请看下面的代码。</p><pre><code>    　function f1(){    　　　　var n=999;    　　　　nAdd=function(){n+=1}    　　　　function f2(){    　　　　　　alert(n);    　　　　}    　　　　return f2;    　　}    　　var result=f1();    　　result(); // 999    　　nAdd();    　　result(); // 1000</code></pre><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试当中总觉得自己也不是特别明白，今天过来总结一下。&lt;/p&gt;
&lt;h3 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h3&gt;&lt;p&gt;JavaScript的闭包是一个特色。官
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Express中间件</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/12/25/Express%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/12/25/Express中间件/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-07-29T03:21:50.030Z</updated>
    
    <content type="html"><![CDATA[<p>中间件（Middleware） 是一个函数，它可以访问请求对象（request）, 响应对象（response）, 和 web 应用中处于请求-响应循环流程中的中间件(next)。</p><p><strong>中间件的功能包括：</strong></p><pre><code>1、执行任何代码。2、修改请求和响应对象。3、终结请求-响应循环。4、调用堆栈中的下一个中间件.</code></pre><p>简单的说，中间件就是在请求-响应的过程中给我们提供一个可以修改内容的机会。</p><p>看看express中如何使用中间件</p><pre><code>const express = require(&apos;express&apos;);const app = express();app.use((req, res, next) =&gt; {    console.log(1);    next();});app.use((req, res, next) =&gt; {    console.log(2);    next();});app.route(&apos;/&apos;).get((req, res) =&gt; {    res.jsonp(123);})app.listen(3031, () =&gt; {    console.log(`connect success in http://localhost:3031`);});</code></pre><p>当你访问<a href="http://localhost:3031时，终端会显示：" target="_blank" rel="noopener">http://localhost:3031时，终端会显示：</a></p><p><img src="/../about/middleware1.png" alt="你看"></p><p>从上面的代码中，我们可以看到，每个use中间件(函数)，除了请求对象req、响应对象res，还有一个next，这是神马呢？</p><p>其实，它表示是下一个中间件(函数)，也就是第一个的中间件(函数)中的next是第二个中间件(函数)，如果你不调用next，就不会调用下一个中间件(函数)，也就是说到此结束了。</p><p>而express的逻辑是只有所有中间件都被执行了，才会执行路由，也就是说，如果上面的实例中，第二个中间件不调用next，就不会执行route路由。</p><p>下面来简单的实现express中的中间件</p><pre><code>const http = require(&apos;http&apos;);function express() {    const func = [];    let request;    let i = 0;    function app(req, res) {        let count = 0;        function next() {            const task = func[count++];                console.log(count);            if (!task) {                //等待所有中间件执行完毕，再执行路由                if (request &amp;&amp; count &gt;= func.length) {                    request(req, res);                }                return;            }            task(req, res, next);        }        next();    }    //中间件函数    app.use = (task) =&gt; {        func.push(task);    }    // 路由函数    app.route = (fn) =&gt; {        request = fn;    }    return app;}const app = express();app.use((req, res, next) =&gt; {    console.log(1);    next();});app.use((req, res, next) =&gt; {    console.log(2);    next();});app.route((req, res) =&gt; {    // 主页if (req.url == &quot;/&quot;) {    res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html&quot; });    res.end(&quot;Welcome to the homepage!&quot;);}// About页面else if (req.url == &quot;/about&quot;) {    res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html&quot; });    res.end(&quot;Welcome to the about page!&quot;);}})http.createServer(app).listen(3031, () =&gt; {    console.log(`connect success in http://localhost:3031`);});</code></pre><p>当访问<a href="http://localhost:3031时，可以看到中间件执行顺序：" target="_blank" rel="noopener">http://localhost:3031时，可以看到中间件执行顺序：</a></p><p><img src="/../about/middleware2.png" alt="你看"></p><p>在上面的代码中，我们实现了express函数，其中利用闭包的特性，声明了一个用来保存中间件(函数)的数组func，<br>同时在next函数中又声明了一个用来记录已执行的中间件的个数.</p><p>最后，定义了两个静态方法use和route。</p><p>这就是express中中间件的逻辑，每调用一次use，就将函数抛到一个数组中，然后每次处理请求时，都会调用所有中间件，也就是循环一次数组(建立在你每次中间件都调用next的情况下)，最后执行route。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中间件（Middleware） 是一个函数，它可以访问请求对象（request）, 响应对象（response）, 和 web 应用中处于请求-响应循环流程中的中间件(next)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间件的功能包括：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ajaix异步问题</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/11/16/ajax%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/11/16/ajax异步问题/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2018-07-29T03:17:27.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise-封装ajax想顺序执行ajax"><a href="#Promise-封装ajax想顺序执行ajax" class="headerlink" title="Promise 封装ajax想顺序执行ajax"></a>Promise 封装ajax想顺序执行ajax</h3><pre><code>        function $myAjax(url, method, data, callback) {        let p = new Promise(function(resolve, reject) {            $Ajax.request({                url: url,                method: method,                data: data,                success: function(resp) {                    callback(resp);                    resolve();                },                failure: function(xhr) {                    //todo                    reject();                }            });        });        return p;        }        let $docs = document;        $docs.getElementById(&apos;xxx&apos;).onclick = function() {        $myAjax(&apos;https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&apos;, &apos;get&apos;, { &apos;memberid&apos;: 1920740, &apos;activeid&apos;: 1 }, function(resp) {            console.log(resp);            console.log(1);        }).then(function() {            return            $myAjax(&apos;https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&apos;, &apos;get&apos;, { &apos;memberid&apos;: 1920740, &apos;activeid&apos;: 1 }, function(resp) {            console.log(resp);            console.log(2);        })        }).then(function() {             return            $myAjax(&apos;https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&apos;, &apos;get&apos;, { &apos;memberid&apos;: 1920740, &apos;activeid&apos;: 1 }, function(resp) {            console.log(resp);            console.log(3);        })        });        };打出的顺序经常是1，3，2;由于每个回调函数必须return，后面两个then是基于第一个promise的异步，所以不是顺序执行的</code></pre><p>最直观的办法是用异步嵌套，但代码看起来很蠢。比较好的解决办法是es6的async await</p><h3 id="es6的async-await"><a href="#es6的async-await" class="headerlink" title="es6的async await"></a>es6的async await</h3><p>$docs.getElementById(‘xxx’).onclick = async function() {<br>  let resp1 = await $myAjax(‘<a href="https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&#39;" target="_blank" rel="noopener">https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&#39;</a>)<br>  let resp2 = await $myAjax(‘<a href="https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&#39;" target="_blank" rel="noopener">https://mhd.uzai.com/api/CommonActive/GetPrizeGivingByUserid&#39;</a>)<br>  }</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Promise-封装ajax想顺序执行ajax&quot;&gt;&lt;a href=&quot;#Promise-封装ajax想顺序执行ajax&quot; class=&quot;headerlink&quot; title=&quot;Promise 封装ajax想顺序执行ajax&quot;&gt;&lt;/a&gt;Promise 封装ajax想顺序
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/10/01/BOM/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/10/01/BOM/</id>
    <published>2017-09-30T16:00:00.000Z</published>
    <updated>2018-07-29T03:21:44.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h1><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ul><li>BOM的核心是window，它表示浏览器的一个实例。window 对象既是通过 js 访问浏览器窗口的一个接口，又是 es 规定的Global 对象。</li><li>全局变量不能通过 delete 操作符删除，但是 window 对象上的属性是可以的。</li><li>直接访问为未声明的变量会报错，但是可以通过 window对象上的属性来查询某个未声明的变量是否存在。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue = oldValue  <span class="comment">//会抛出错误，因为后者未声明</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h2><ul><li>JS 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，后者则是每隔指定的时间就执行一次。</li><li><code>setTimeout()</code>方法可以接受两个参数，第一个是要执行的代码，也可以是字符串，但是推荐用<code>function(){}</code>。后一个参数是执行前需要等待的毫秒数。传递字符串可能导致性能损失，因此不建议。</li><li>值得注意的是，经过了指定的毫秒，代码也不一定会执行。js 是一个单线程序的解释器，有一个任务队列。如果队列是空的，那么代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完毕以后再执行。</li><li>取消的时候可以用<code>clearTime()</code>方法.把相应的数字 id 传递进去。</li><li>注意在以上方法中this 指向全局，window 对象。严格模式下是 undefined。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeoutId 是一个数字 ID</span></span><br><span class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'heiheihei'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">clearTimeout(timeoutId) <span class="comment">//即立即取消这个超时调用</span></span><br></pre></td></tr></table></figure><ul><li>取消间隔调用<code>setInterval()</code>远比取消<code>setTimeout()</code>重要的多，因为间隔调用如果不干涉会一直执行。</li><li>一般认为，使用setTimeout 模拟 setInterval 是最佳实践。因为后一个间歇调用可能会在前一个间歇调用结束前启动。使用模拟方式则可以避免这一情况。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inc</span>(<span class="params"></span>) </span>&#123; <span class="comment">//模拟setInterval 方法，间隔增加直至最大值</span></span><br><span class="line">num++</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">setTimeout(inc, <span class="number">500</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(inc, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ul><li>location 是最有用的 BOM 对象之一，而且它既是 window 对象的属性，也是 document 对象的属性。 <code>window.location</code>和<code>document.location</code>引用的是同一个对象。</li><li><p>location 对象的用处不止表现在它保存着当前文档的信息，而且还可以通过不同属性访问 URL 的解析片段。</p><p>  属性名 | 例子 | 说明<br>  —-|:——:|—-<br>  hash | ‘#contents’  | URL 中的 hash，#后面的字符，没有则为空<br>  host | ‘<a href="http://www.baidu.com:80&#39;" target="_blank" rel="noopener">www.baidu.com:80&#39;</a>  | 服务器名称和端口号(如果有)<br>  hostname | ‘<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>  | 服务器名称<br>  href | ‘<a href="http://www.baidu.com:80/dd.html#hash1?q=name&#39;" target="_blank" rel="noopener">www.baidu.com:80/dd.html#hash1?q=name&#39;</a>  | 完整URL<br>  pathname | ‘/dd.html’  | URL 中的目录和文件名<br>  port|’80’|端口<br>  protocol| ‘http:’|协议名和冒号<br>  search|’?q=name’|查询字符串，别忘了有问号开头</p></li></ul><ul><li>尽管 <code>location.search</code> 可以查询到查询的字符串，但是没法逐个访问，并不方便。创建一个函数返回对象，得到对应的 key 和 value。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//字符串是否为空</span></span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">var</span> args = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> items = qs.length ? qs.split(<span class="string">'&amp;'</span>) : []</span><br><span class="line">  <span class="keyword">var</span> item = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    item = items[i].split(<span class="string">'='</span>)</span><br><span class="line">    <span class="comment">//进行解码</span></span><br><span class="line">    name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>])</span><br><span class="line">    value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">      args[name] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位置操作location"><a href="#位置操作location" class="headerlink" title="位置操作location"></a>位置操作location</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改 URL</span></span><br><span class="line">location.assign(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">'xxx'</span></span><br><span class="line">location.href = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><ul><li>上述的三种方式得到的效果完全一样，因为后面的两个也会调用assign()方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 URL 修改成'http://www.baidu.com#section1' 页面不跳转</span></span><br><span class="line">location.hash = <span class="string">'#section1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 url 修改成'http://www.baidu.com:80' 页面跳转</span></span><br><span class="line">location.port = <span class="number">80</span></span><br></pre></td></tr></table></figure><ul><li>每次修改 location 的属性(hash 除外)，页面都会以新 URL 重新加载。</li><li>当通过上述任何一种方式修改 URL 后，浏览器的历史记录就会生成一条新纪录。通过后退按钮都会回到前一个页面。</li><li>使用 replace()方法可以禁用后退按钮。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浏览器跳转到百度，但不会在历史纪录中生成新纪录，而且不能回到之前的页面</span></span><br><span class="line">location.replace(<span class="string">'http://www.baidu.com'</span>)</span><br></pre></td></tr></table></figure><ul><li><code>location.reload()</code>方法会让浏览器以最有效的方式重新加载，可能使用缓存。</li><li><code>location.reload(true)</code>方法会让浏览器强制完全重载。</li><li>reload()方法之后的代码<strong>可能，也可能不会执行</strong>，所以放在最后一行吧。</li></ul><p>##history 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>)<span class="comment">//后退一页</span></span><br><span class="line">history.go(<span class="number">1</span>)<span class="comment">//前进一页</span></span><br><span class="line">history.go(<span class="number">2</span>)<span class="comment">//前进2页</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="string">'www.baidu.com'</span>) <span class="comment">//跳转到最近的百度页面，如果没有这条字符串，那么什么也不做</span></span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">history.forwward()<span class="comment">//前进后退的简写方法</span></span><br><span class="line"></span><br><span class="line">history.length  <span class="comment">//数量，新加载的页面是0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BOM对象&quot;&gt;&lt;a href=&quot;#BOM对象&quot; class=&quot;headerlink&quot; title=&quot;BOM对象&quot;&gt;&lt;/a&gt;BOM对象&lt;/h1&gt;&lt;h2 id=&quot;window对象&quot;&gt;&lt;a href=&quot;#window对象&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/10/01/BFC%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/10/01/BFC问题/</id>
    <published>2017-09-30T16:00:00.000Z</published>
    <updated>2018-07-29T03:17:07.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。要明白BFC到底是什么，首先来看看什么是视觉格式化模型。</p><h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>视觉格式化模型定义了盒（Box）的生成，盒主要包括了块盒、行内盒、匿名盒（没有名字不能被选择器选中的盒）以及一些实验性的盒（未来可能添加到规范中）。盒的类型由display属性决定。</p><h3 id="块盒（block-box）"><a href="#块盒（block-box）" class="headerlink" title="块盒（block box）"></a>块盒（block box）</h3><p>块盒有以下特性：</p><pre><code>1、当元素的CSS属性display为block，list-item或 table时，它是块级元素 block-level；2、视觉上呈现为块，竖直排列；3、块级盒参与(块格式化上下文)；4、每个块级元素至少生成一个块级盒，称为主要块级盒(principal block-level box)。一些元素，比如&lt;li&gt;，生成额外的盒来放置项目符号，不过多数元素只生成一个主要块级盒。</code></pre><h3 id="行内盒（inline-box）"><a href="#行内盒（inline-box）" class="headerlink" title="行内盒（inline box）"></a>行内盒（inline box）</h3><pre><code>1、当元素的CSS属性display的计算值为inline，inline-block或inline-table时，称它为行内级元素；2、视觉上它将内容与其它行内级元素排列为多行；典型的如段落内容，有文本(可以有多种格式譬如着重)，或图片，都是行内级元素；3、行内级元素生成行内级盒(inline-level boxes)，参与行内格式化上下文(inline formatting context)。同时参与生成行内格式化上下文的行内级盒称为行内盒(inline boxes)。所有display:inline的非替换元素生成的盒是行内盒；4、不参与生成行内格式化上下文的行内级盒称为原子行内级盒(atomic inline-level boxes)。这些盒由可替换行内元素，或 display 值为 inline-block 或 inline-table 的元素生成，不能拆分成多个盒；</code></pre><h3 id="匿名盒（anonymous-box）"><a href="#匿名盒（anonymous-box）" class="headerlink" title="匿名盒（anonymous box）"></a>匿名盒（anonymous box）</h3><p>匿名盒也有份匿名块盒与匿名行内盒，因为匿名盒没有名字，不能利用选择器来选择它们，所以它们的所有属性都为inherit或初始默认值；</p><p>如下面例子，会创键匿名块盒来包含毗邻的行内级盒：</p><pre><code>&lt;div&gt;    Some inline text    &lt;p&gt;followed by a paragraph&lt;/p&gt;    followed by more inline text.&lt;/div&gt;</code></pre><h3 id="三个定位方案"><a href="#三个定位方案" class="headerlink" title="三个定位方案"></a>三个定位方案</h3><p>在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动已经绝对定位。</p><h4 id="常规流-Normal-flow"><a href="#常规流-Normal-flow" class="headerlink" title="常规流(Normal flow)"></a>常规流(Normal flow)</h4><pre><code>在常规流中，盒一个接着一个排列;在块级格式化上下文里面， 它们竖着排列；在行内格式化上下文里面， 它们横着排列;当position为static或relative，并且float为none时会触发常规流；对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置；对于相对定位(relative positioning)，position: relative，盒偏移位置由这些属性定义top，bottom，leftandright。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。</code></pre><h4 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动(Floats)"></a>浮动(Floats)</h4><pre><code>盒称为浮动盒(floating boxes)；它位于当前行的开头或末尾；这导致常规流环绕在它的周边，除非设置 clear 属性；</code></pre><h4 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位(Absolute positioning)"></a>绝对定位(Absolute positioning)</h4><pre><code>绝对定位方案，盒从常规流中被移除，不影响常规流的布局；它的定位相对于它的包含块，相关CSS属性：top，bottom，left及right；如果元素的属性position为absolute或fixed，它是绝对定位元素；对于position: absolute，元素定位将相对于最近的一个relative、fixed或absolute的父元素，如果没有则相对于body；</code></pre><h3 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h3><p>到这里，已经对CSS的定位有一定的了解了，从上面的信息中也可以得知，块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。<br>BFC的创建方法</p><pre><code>根元素或其它包含它的元素；浮动 (元素的float不为none)；绝对定位元素 (元素的position为absolute或fixed)；行内块inline-blocks(元素的 display: inline-block)；表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；overflow的值不为visible的元素；弹性盒 flex boxes (元素的display: flex或inline-flex)；</code></pre><p>但其中，最常见的就是overflow:hidden、float:left/right、position:absolute。也就是说，每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。</p><h3 id="BFC的范围"><a href="#BFC的范围" class="headerlink" title="BFC的范围"></a>BFC的范围</h3><p>BFC的范围在MDN中是这样描述的。</p><pre><code>A block formatting context contains everything inside of the element creating it that is not also inside a descendant element that creates a new block formatting context.</code></pre><p>中文的意思一个BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。<br>这段看上去有点奇怪，我是这么理解的，加入有下面代码，class名为.BFC代表创建了新的块格式化：</p><pre><code>&lt;div id=&apos;div_1&apos; class=&apos;BFC&apos;&gt;    &lt;div id=&apos;div_2&apos;&gt;        &lt;div id=&apos;div_3&apos;&gt;&lt;/div&gt;        &lt;div id=&apos;div_4&apos;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&apos;div_5&apos; class=&apos;BFC&apos;&gt;        &lt;div id=&apos;div_6&apos;&gt;&lt;/div&gt;        &lt;div id=&apos;div_7&apos;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>这段代码表示，#div_1创建了一个块格式上下文，这个上下文包括了#div_2、#div_3、#div_4、#div_5。<br>即#div_2中的子元素也属于#div_1所创建的BFC。但由于#div_5创建了新的BFC，所以#div_6和#div_7就被排除在外层的BFC之外。</p><p>我认为，这从另一方角度说明，一个元素不能同时存在于两个BFC中。</p><p>BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。这是利用BFC清除浮动所利用的特性，关于清除浮动将在后面讲述。</p><p>如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用，所以这个假设就不成立了。</p><h3 id="BFC的效果"><a href="#BFC的效果" class="headerlink" title="BFC的效果"></a>BFC的效果</h3><p>就如刚才提到的，BFC的最显著的效果就是建立一个隔离的空间，断绝空间内外元素间相互的作用。然而，BFC还有更多的特性：</p><pre><code>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with &apos;overflow&apos; other than &apos;visible&apos; (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the &apos;margin&apos; properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.In a block formatting context, each box&apos;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box&apos;s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</code></pre><h3 id="简单归纳一下："><a href="#简单归纳一下：" class="headerlink" title="简单归纳一下："></a>简单归纳一下：</h3><pre><code>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；处于同一个BFC中的元素相互影响，可能会发生margin collapse；每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；浮动盒区域不叠加到BFC上；</code></pre><p>这么多性质有点难以理解，但可以作如下推理来帮助理解：html的根元素就是<html>，而根元素会创建一个BFC，创建一个新的BFC时就相当于在这个元素内部创建一个新的<html>，子元素的定位就如同在一个新<html>页面中那样，而这个新旧html页面之间时不会相互影响的。</html></html></html></p><p>上述这个理解并不是最准确的理解，甚至是将因果倒置了（因为html是根元素，因此才会有BFC的特性，而不是BFC有html的特性），但这样的推理可以帮助理解BFC这个概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是BFC&quot;&gt;&lt;a href=&quot;#什么是BFC&quot; class=&quot;headerlink&quot; title=&quot;什么是BFC&quot;&gt;&lt;/a&gt;什么是BFC&lt;/h2&gt;&lt;p&gt;BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS3 动画</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/09/15/CSS3%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/09/15/CSS3动画/</id>
    <published>2017-09-14T16:00:00.000Z</published>
    <updated>2018-07-29T03:16:37.783Z</updated>
    
    <content type="html"><![CDATA[<p> CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。</p><p> css动画分为CSS Transition和 CSS Animation</p><h3 id="CSS-Transition"><a href="#CSS-Transition" class="headerlink" title="CSS Transition"></a>CSS Transition</h3><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><p>语法</p><pre><code>transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)/*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/transition：width,.5s,ease,.2s/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/transition：all,.5s</code></pre><p> 上面栗子是简写模式，也可以分开写各个属性（这个在下面就不再重复了）</p><pre><code>transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s;</code></pre><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬！</p><p>语法</p><pre><code>animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/animation: logo2-line 2s linear;/*2秒后开始执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/animation: logo2-line 2s linear 2s;/*无限执行logo2-line动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*/animation: logo2-line 2s linear alternate infinite;animation-fill-mode : none | forwards | backwards | both;/*none：不改变默认行为。    forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。    backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both：向前和向后填充模式都被应用。  */      </code></pre><h3 id="logo展示动画"><a href="#logo展示动画" class="headerlink" title="logo展示动画"></a>logo展示动画</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf406b0855a99?imageslim" alt="你看"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;reset.css&quot;&gt;&lt;/head&gt;&lt;style&gt;.logo-box{    width: 600px;    margin: 100px auto;    font-size: 0;    position: relative;}.logo-box div{    display: inline-block;}.logo-box .logo-text{    margin-left: 10px;}.logo-box .logo1{    animation: logo1 1s ease-in 2s;    animation-fill-mode:backwards;}.logo-box .logo-text{    animation: logoText 1s ease-in 3s;    animation-fill-mode:backwards;}.logo-box .logo2{    position: absolute;    top: 20px;    left: 20px;    animation: logo2-middle 2s ease-in;}.logo-box .logo2 img{    animation: logo2-line 2s linear;}@keyframes logo1 {    0%{        transform:rotate(180deg);        opacity: 0;    }    100%{        transform:rotate(0deg);        opacity: 1;    }}@keyframes logoText {    0%{        transform:translateX(30px);        opacity: 0;    }    100%{        transform:translateX(0);        opacity: 1;    }}@keyframes logo2-line {    0% { transform: translateX(200px)}    25% { transform: translateX(150px)}    50% { transform: translateX(100px)}    75% { transform: translateX(50px)}    100% { transform: translateX(0); }}@keyframes logo2-middle {    0% { transform: translateY(0);     }    25% { transform: translateY(-100px);     }    50% { transform: translateY(0);     }    75% { transform: translateY(-50px);     }    100% { transform: translateY(0); }}&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;logo-box&quot;&gt;&lt;div class=&quot;logo1&quot;&gt;&lt;img src=&quot;logo1.jpg&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;logo2&quot;&gt;&lt;img src=&quot;logo2.jpg&quot;/&gt;&lt;/div&gt;&lt;div class=&quot;logo-text&quot;&gt;&lt;img src=&quot;logo3.jpg&quot;/&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;wraper&quot;&gt;&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>下面让大家看一个专业级别的<br><img src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf406a3af6c0a?imageslim" alt="你看"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    body {        font-family: Arial,&quot;Helvetica Neue&quot;,Helvetica,sans-serif;        overflow: hidden;        background: #fff;    }    .center {        margin: 80px auto;    }    .so {        display: block;        width: 500px;        height: 156px;        background: #ffffff;    }    .so .inner {        width: 500px;        height: 156px;        position: absolute;    }    .so .inner * {        position: absolute;        animation-iteration-count: infinite;        animation-duration: 3.5s;    }    .so .inner .name {        position: absolute;        font-size: 54px;        left: 130px;        top: 95px;    }    .so .inner .name .b {        font-weight: bold;    }    .so .inner .stack-box {        top: 100px;        width: 115px;        height: 56px;    }    .so .inner .box {        width: 115px;        height: 56px;        left: 0px;    }    .so .inner .box div {        background: #BCBBBB;    }    .so .inner .box .bottom {        bottom: 0px;        left: 0px;        width: 115px;        height: 12px;    }    .so .inner .box .left {        bottom: 11px;        left: 0px;        width: 12px;        height: 34px;    }    .so .inner .box .right {        bottom: 11px;        left: 103px;        width: 12px;        height: 34px;    }    .so .inner .box .top {        top: 0px;        left: 0px;        width: 0;        height: 12px;    }    .so .inner .stack {        left: 22px;        top: 22px;    }    .so .inner .stack .inner-item {        background: #F48024;        width: 71px;        height: 12px;    }    .so .inner .stack .item {        transition: transform 0.3s;        width: 291px;    }    .so .inner .stack div:nth-child(1) {        transform: rotate(0deg);    }    .so .inner .stack div:nth-child(2) {        transform: rotate(12deg);    }    .so .inner .stack div:nth-child(3) {        transform: rotate(24deg);    }    .so .inner .stack div:nth-child(4) {        transform: rotate(36deg);    }    .so .inner .stack div:nth-child(5) {        transform: rotate(48deg);    }    .so .inner .box {        animation-name: box;    }    .so .inner .box .top {        animation-name: box-top;    }    .so .inner .box .left {        animation-name: box-left;    }    .so .inner .box .right {        animation-name: box-right;    }    .so .inner .box .bottom {        animation-name: box-bottom;    }    .so .inner .stack-box {        animation-name: stack-box;    }    .so .inner .stack {        animation-name: stack;    }    .so .inner .stack .inner-item {        animation-name: stack-items;    }    .so .inner .stack .item:nth-child(1) {        animation-name: stack-item-1;    }    .so .inner .stack .item:nth-child(2) {        animation-name: stack-item-2;    }    .so .inner .stack .item:nth-child(3) {        animation-name: stack-item-3;    }    .so .inner .stack .item:nth-child(4) {        animation-name: stack-item-4;    }    .so .inner .stack .item:nth-child(5) {        animation-name: stack-item-5;    }    @keyframes stack {        0% {            left: 22px;        }        15% {            left: 22px;        }        30% {            left: 52px;        }        50% {            left: 52px;        }        80% {            left: 22px;        }    }    @keyframes stack-item-1 {        0% {            transform: rotate(12deg * 0);        }        10% {            transform: rotate(0deg);        }        50% {            transform: rotate(0deg);        }        54% {            transform: rotate(0deg);        }        92% {            transform: rotate(12deg * 0);        }    }    @keyframes stack-item-2 {        0% {            transform: rotate(12deg * 1);        }        10% {            transform: rotate(0deg);        }        50% {            transform: rotate(0deg);        }        54% {            transform: rotate(0deg);        }        92% {            transform: rotate(12deg * 1);        }    }    @keyframes stack-item-3 {        0% {            transform: rotate(12deg * 2);        }        10% {            transform: rotate(0deg);        }        50% {            transform: rotate(0deg);        }        54% {            transform: rotate(0deg);        }        92% {            transform: rotate(12deg * 2);        }    }    @keyframes stack-item-4 {        0% {            transform: rotate(12deg * 3);        }        10% {            transform: rotate(0deg);        }        50% {            transform: rotate(0deg);        }        54% {            transform: rotate(0deg);        }        92% {            transform: rotate(12deg * 3);        }    }    @keyframes stack-item-5 {        0% {            transform: rotate(12deg * 4);        }        10% {            transform: rotate(0deg);        }        50% {            transform: rotate(0deg);        }        54% {            transform: rotate(0deg);        }        92% {            transform: rotate(12deg * 4);        }    }    @keyframes stack-items {        0% {            width: 71px;        }        15% {            width: 71px;        }        30% {            width: 12px;        }        50% {            width: 12px;        }        80% {            width: 71px;        }    }    @keyframes box {        0% {            left: 0;        }        15% {            left: 0;        }        30% {            left: 30px;        }        50% {            left: 30px;        }        80% {            left: 0;        }    }    @keyframes box-top {        0% {            width: 0;        }        6% {            width: 0;        }        15% {            width: 115px;        }        30% {            width: 56px;        }        50% {            width: 56px;        }        59% {            width: 0;        }    }    @keyframes box-bottom {        0% {            width: 115px;        }        15% {            width: 115px;        }        30% {            width: 56px;        }        50% {            width: 56px;        }        80% {            width: 115px;        }    }    @keyframes box-right {        15% {            left: 103px;        }        30% {            left: 44px;        }        50% {            left: 44px;        }        80% {            left: 103px;        }    }    @keyframes stack-box {        0% {            transform: rotate(0deg);        }        30% {            transform: rotate(0deg);        }        40% {            transform: rotate(135deg);        }        50% {            transform: rotate(135deg);        }        83% {            transform: rotate(360deg);        }        100% {            transform: rotate(360deg);        }    }&lt;/style&gt;&lt;body&gt;&lt;div class=&quot;so center&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;        &lt;div class=&quot;stack-box&quot;&gt;            &lt;div class=&quot;stack&quot;&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;div class=&quot;inner-item&quot;&gt;&lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;div class=&quot;inner-item&quot;&gt;&lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;div class=&quot;inner-item&quot;&gt;&lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;div class=&quot;inner-item&quot;&gt;&lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;div class=&quot;inner-item&quot;&gt;&lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;box&quot;&gt;                &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;name&quot;&gt;            stack&lt;span class=&quot;b&quot;&gt;overflow&lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。</p><pre><code>img{    height:15px;    width:15px;}img:hover{    height: 450px;    width: 450px;}</code></pre><p>transition的作用在于，指定状态变化所需要的时间。</p><pre><code>img{    transition: 1s;}</code></pre><p>上面代码指定，图片放大的过程需要1秒，效果如下。</p><p>我们还可以指定transition适用的属性，比如只适用于height。</p><pre><code>img{    transition: 1s height;}</code></pre><p>这样一来，只有height的变化需要1秒实现，其他变化（主要是width）依然瞬间实现，效果如下。</p><h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h4><p>在同一行transition语句中，可以分别指定多个属性。</p><pre><code>img{    transition: 1s height, 1s width;}</code></pre><p>但是，这样一来，height和width的变化是同时进行的，跟不指定它们没有差别，效果如下。</p><p>我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。</p><pre><code>img{    transition: 1s height, 1s 1s width;}</code></pre><p>上面代码指定，width在1秒之后，再开始变化，也就是延迟（delay）1秒，效果如下。</p><p>delay的真正意义在于，它指定了动画发生的顺序，使得多个不同的transition可以连在一起，形成复杂效果.</p><h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h4><p>transition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。</p><pre><code>img{    transition: 1s ease;}</code></pre><p>除了ease以外，其他模式还包括</p><pre><code>（1）linear：匀速（2）ease-in：加速（3）ease-out：减速（4）cubic-bezier函数：自定义速度模式</code></pre><p>最后那个cubic-bezier，可以使用<a href="http://cubic-bezier.com/#.67,.21,.83,.67" target="_blank" rel="noopener">工具网站</a>来定制。</p><pre><code>img{    transition: 1s height cubic-bezier(.83,.97,.05,1.44);}</code></pre><p>上面的代码会产生一个最后阶段放大过度、然后回缩的效果。</p><h4 id="transition的各项属性"><a href="#transition的各项属性" class="headerlink" title="transition的各项属性"></a>transition的各项属性</h4><p>transition的完整写法如下。</p><pre><code>img{    transition: 1s 1s height ease;}</code></pre><p>这其实是一个简写形式，可以单独定义成各个属性。</p><pre><code>img{    transition-property: height;    transition-duration: 1s;    transition-delay: 1s;    transition-timing-function: ease;}</code></pre><h4 id="transition的使用注意"><a href="#transition的使用注意" class="headerlink" title="transition的使用注意"></a>transition的使用注意</h4><p>（1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</p><p>（2）不是所有的CSS属性都支持transition，完整的列表查看这里，以及具体的效果。</p><p>（3）transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</p><h4 id="transition的局限"><a href="#transition的局限" class="headerlink" title="transition的局限"></a>transition的局限</h4><p>transition的优点在于简单易用，但是它有几个很大的局限。</p><p>（1）transition需要事件触发，所以没法在网页加载时自动发生。</p><p>（2）transition是一次性的，不能重复发生，除非一再触发。</p><p>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p><p>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。CSS Animation就是为了解决这些问题而提出的。</p><h3 id="CSS-Animation"><a href="#CSS-Animation" class="headerlink" title="CSS Animation"></a>CSS Animation</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。</p><pre><code>div:hover {    animation: 1s rainbow;}</code></pre><p>上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。</p><pre><code>@keyframes rainbow {    0% { background: #c00; }    50% { background: orange; }    100% { background: yellowgreen; }}</code></pre><p>上面代码表示，rainbow效果一共有三个状态，分别为起始（0%）、中点（50%）和结束（100%）。如果有需要，完全可以插入更多状态。效果如下。</p><p>默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。</p><pre><code>div:hover {    animation: 1s rainbow infinite;}</code></pre><p>也可以指定动画具体播放的次数，比如3次。</p><pre><code>div:hover {    animation: 1s rainbow 3;}</code></pre><h4 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h4><p>动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。</p><pre><code>div:hover {    animation: 1s rainbow forwards;}</code></pre><p>forwards表示让动画停留在结束状态。</p><p>animation-fill-mode还可以使用下列值。</p><pre><code>（1）none：默认值，回到动画没开始时的状态。（2）backwards：让动画回到第一帧的状态。（3）both: 根据animation-direction（见后）轮流应用forwards和backwards规则。</code></pre><h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><p>动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。</p><p>下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。</p><pre><code>@keyframes rainbow {    0% { background-color: yellow; }    100% { background: blue; }}</code></pre><p>默认情况是，animation-direction等于normal。</p><pre><code>div:hover {    animation: 1s rainbow 3 normal;}</code></pre><p>此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图</p><p>简单说，animation-direction指定了动画播放的方向，最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用。</p><h4 id="animation的各项属性"><a href="#animation的各项属性" class="headerlink" title="animation的各项属性"></a>animation的各项属性</h4><p>同transition一样，animation也是一个简写形式。</p><pre><code>div:hover {    animation: 1s 1s rainbow linear 3 forwards normal;}</code></pre><p>这是一个简写形式，可以分解成各个单独的属性。</p><pre><code>div:hover {    animation-name: rainbow;    animation-duration: 1s;    animation-timing-function: linear;    animation-delay: 1s;    animation-fill-mode:forwards;    animation-direction: normal;    animation-iteration-count: 3;}</code></pre><p><strong>animation-name</strong>对应到动画名称，<strong>animation-duration</strong>是动画时长，还有其他属性：</p><pre><code>1. animation-timing-function：规定动画的速度曲线。默认是ease。2. animation-delay：规定动画何时开始。默认是 0。3. animation-iteration-count：规定动画被播放的次数。默认是 1。4. animation-direction：规定动画是否在下一周期逆向地播放。默认是normal。5. animation-play-state ：规定动画是否正在运行或暂停。默认是running。6. animation-fill-mode：规定动画执行之前和之后如何给动画的目标应用，默认是none，保留在最后一帧可以用forwards。</code></pre><h4 id="keyframes的写法"><a href="#keyframes的写法" class="headerlink" title="keyframes的写法"></a>keyframes的写法</h4><p>keyframes关键字用来定义动画的各个状态，它的写法相当自由。</p><pre><code>@keyframes rainbow {    0% { background: #c00 }    50% { background: orange }    100% { background: yellowgreen }}</code></pre><p>0%可以用from代表，100%可以用to代表，因此上面的代码等同于下面的形式。</p><pre><code>@keyframes rainbow {    from { background: #c00 }    50% { background: orange }    to { background: yellowgreen }}</code></pre><p>如果省略某个状态，浏览器会自动推算中间状态，所以下面都是合法的写法。</p><pre><code>@keyframes rainbow {    50% { background: orange }    to { background: yellowgreen }}@keyframes rainbow {    to { background: yellowgreen }}</code></pre><p>甚至，可以把多个状态写在一行。</p><pre><code>@keyframes pound {    from，to { transform: none; }    50% { transform: scale(1.2); }}</code></pre><p>另外一点需要注意的是，浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡</p><pre><code>div:hover {    animation: 1s rainbow infinite steps(10);}</code></pre><h4 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h4><p>有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态</p><p>上面动画中，如果鼠标移走，色块立刻回到动画开始状态。</p><p>如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。</p><pre><code>div {    animation: spin 1s linear infinite;    animation-play-state: paused;}div:hover {    animation-play-state: running;}</code></pre><p>上面的代码指定，没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放。效果如下</p><h4 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h4><p>目前，IE 10和Firefox（&gt;= 16）支持没有前缀的animation，而chrome不支持，所以必须使用webkit前缀。</p><p>也就是说，实际运用中，代码必须写成下面的样子。</p><pre><code>div:hover {    -webkit-animation: 1s rainbow;    animation: 1s rainbow;  }@-webkit-keyframes rainbow {    0% { background: #c00; }    50% { background: orange; }    100% { background: yellowgreen; }}@keyframes rainbow {    0% { background: #c00; }    50% { background: orange; }    100% { background: yellowgreen; }}</code></pre><h2 id="CSS-的transition和animation有何区别？"><a href="#CSS-的transition和animation有何区别？" class="headerlink" title="CSS 的transition和animation有何区别？"></a>CSS 的transition和animation有何区别？</h2><p>首先transition和animation都可以做动效，从语义上来理解，transition是过渡，由一个状态过渡到另一个状态，比如高度100px过渡到200px；而animation是动画，即更专业做动效的，animation有帧的概念，可以设置关键帧keyframe，一个动画可以由多个关键帧多个状态过渡组成，另外animation也包含上面提到的多个属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; CSS3 可以实现动画，代替原来的 Flash 和 JavaScript 方案。&lt;/p&gt;
&lt;p&gt; css动画分为CSS Transition和 CSS Animation&lt;/p&gt;
&lt;h3 id=&quot;CSS-Transition&quot;&gt;&lt;a href=&quot;#CSS-Transiti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Vue2.0实现后台系统权限控制</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/08/23/%E5%9F%BA%E4%BA%8EVue2.0%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/08/23/基于Vue2.0实现后台系统权限控制/</id>
    <published>2017-08-22T16:00:00.000Z</published>
    <updated>2018-07-29T03:24:25.567Z</updated>
    
    <content type="html"><![CDATA[<p>项目背景:现有一个后台管理系统，共存在两种类型的人员</p><p>①超级管理员（称作admin），②普通用户（称作editor）</p><p>每种类型的人看到的操作栏并不一样，可以进行的操作也不尽相同，于是就需要程序处理一下各个权限问题。</p><h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><p>1 创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</p><p>2 当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</p><p>3 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</p><p>4 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p><p><strong>在路由router.js里面声明权限为admin的路由(异步挂载的路由asyncRouterMap)</strong></p><pre><code>// router.jsimport Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)export const constantRouterMap = [{    path: &apos;/&apos;,    redirect: &apos;/login&apos;,    hidden: true},{    path: &apos;/login&apos;,    name: &apos;登录页面&apos;,    hidden: true,    component: resolve =&gt; require([&apos;../views/login/Login.vue&apos;], resolve)},{    path: &apos;/Readme&apos;,    // name: &apos;Readmehome&apos;,    index: &apos;Readme&apos;,    meta: {    title: &apos;Readme&apos;,    icon: &apos;el-icon-menu&apos;    },    component: resolve =&gt; require([&apos;../components/common/Home.vue&apos;], resolve),    children: [    {        name: &apos;Readme&apos;,        path: &apos;/&apos;,        meta: { title: &apos;Readme&apos;, icon: &apos;el-icon-menu&apos; },        component: resolve =&gt; require([&apos;../components/page/Readme.vue&apos;], resolve)    }    ]}]export default new Router({routes: constantRouterMap})// 异步挂载的路由// 动态需要根据权限加载的路由表export const asyncRouterMap = [{    path: &apos;/permission&apos;,    // name: &apos;permissionhome&apos;,    meta: {    title: &apos;permission&apos;,    icon: &apos;el-icon-setting&apos;,    roles: [&apos;admin&apos;]    },    component: resolve =&gt; require([&apos;../components/common/Home.vue&apos;], resolve),    children: [    {        name: &apos;permission&apos;,        path: &apos;/permission&apos;,        meta: {        title: &apos;permission&apos;, icon: &apos;el-icon-menu&apos;, roles: [&apos;admin&apos;]        },        component: resolve =&gt; require([&apos;../components/page/permission.vue&apos;], resolve)    }    ]},{ path: &apos;*&apos;, redirect: &apos;/404&apos;, hidden: true }]</code></pre><p>这里我们根据 <a href="https://router.vuejs.org/en/advanced/meta.html" target="_blank" rel="noopener">vue-router官方推荐</a> 的方法通过meta标签来标示改页面能访问的权限有哪些。如meta: { role: [‘admin’,’super_editor’] }表示该页面只有admin和超级编辑才能有资格进入。</p><p>注意事项：这里有一个需要非常注意的地方就是 404 页面一定要最后加载，如果放在constantRouterMap一同声明了404，后面的所以页面都会被拦截到404，详细的问题见<a href="https://github.com/vuejs/vue-router/issues/1176">addRoutes when you’ve got a wildcard route for 404s does not work</a></p><p><strong>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由，生成最终用户可访问的路由表。路由表存在vuex里面</strong></p><p><strong>permission.js</strong></p><pre><code>// permission.jsimport router from &apos;./router&apos;import store from &apos;./store&apos;import { Message } from &apos;element-ui&apos;import { getToken } from &apos;@/utils/auth&apos; // 验权const whiteList = [&apos;/login&apos;, &apos;/authredirect&apos;] // 不重定向白名单router.beforeEach((to, from, next) =&gt; {if (getToken()) { // 判断是否有token    if (to.path === &apos;/login&apos;) {    next({ path: &apos;/&apos; })    } else {    if (store.getters.roles.length === 0) {        console.log(&apos;roles====0&apos;)        store.dispatch(&apos;GetInfo&apos;).then(res =&gt; { // 拉取用户信息        const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;]        console.log(&apos;roles?&apos;, roles)        store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表            console.log(&apos;addrouters&apos;, store.getters.addRouters)            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record        })        }).catch(() =&gt; {        store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; {            Message.error(&apos;验证失败,请重新登录&apos;)            next({ path: &apos;/login&apos; })        })        })    } else {        console.log(&apos;====1&apos;)        next() // 当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面    }    }} else {    if (whiteList.indexOf(to.path) !== -1) {    next()    } else {    next(&apos;/login&apos;)    }}})</code></pre><p><strong>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件（菜单）。</strong></p><p><img src="/../about/vuex.png" alt="copy"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目背景:现有一个后台管理系统，共存在两种类型的人员&lt;/p&gt;
&lt;p&gt;①超级管理员（称作admin），②普通用户（称作editor）&lt;/p&gt;
&lt;p&gt;每种类型的人看到的操作栏并不一样，可以进行的操作也不尽相同，于是就需要程序处理一下各个权限问题。&lt;/p&gt;
&lt;h3 id=&quot;具体实
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://github.com/luwenchun/luwenchun.github.io/2017/08/15/DOM/"/>
    <id>https://github.com/luwenchun/luwenchun.github.io/2017/08/15/DOM/</id>
    <published>2017-08-14T16:00:00.000Z</published>
    <updated>2018-07-29T03:16:26.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><ul><li>文档节点 document 是每个文档的根节点。文档节点只有一个子节点，即 <code>&lt;html&gt;</code> 元素,称之为文档元素。在 HTML 中，文档元素始终是<code>&lt;html&gt;</code>元素。</li><li>HTML 元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，注释则通过注释节点表示。总共有12种节点类型，这些类型都继承于一个基类型。</li></ul><h2 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h2><ul><li>每个节点都有一个 nodeType 属性，用于表明节点类型。12个数值常量表示，任何节点类型必居其一。例如：</li></ul><ol><li>Node.ELEMENT_NODE(1)</li><li>Node.ATTRIBUTE_NODE(2)</li><li>Node.TEXT_NODE(3)</li></ol><ul><li>为了确保浏览器兼容，最好还是将 nodeType 属性与数字进行比较，因为 IE 没有公开 Node 类型的构造函数。</li><li>并不是所有节点类型都收到浏览器支持，最常用的还是元素和文本节点。</li><li>对于元素节点，nodeName 中保存的始终是元素的标签名，nodeValue 的值始终是 null。</li></ul><h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><ul><li>每个节点都有一个 childNodes 属性，保存着一个 NodeList 对象。这是一个类数组对象，就和 arguments 差不多。</li><li>它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映到 NodeList 对象中，可以当做是<strong>双向绑定</strong>的对象。</li><li>和 arguments 对象一样，可以使用<code>Array.prototype.slice.call(someNode.childNodes)</code>将 childNodes 转换成数组进行操作，方括号访问和 item()都是可以的，前者更常见些。</li><li>IE8及以前需要手动枚举，所以上述代码会失效。</li><li>每个节点有一个 parentNode 属性，指向文档树中的父节点。通过previousSibling和 nextSibling 属性，可以访问其他节点。如果没有前一个或后一个，值为 null。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nextSibling === <span class="literal">null</span>) &#123;  <span class="comment">//最后一个节点</span></span><br><span class="line">alert(<span class="string">'Last node'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.previousSibling === <span class="literal">null</span>) &#123; <span class="comment">//第一个节点</span></span><br><span class="line">alert(<span class="string">'First node!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有一个节点，那么这两个属性都会为 null。</li><li>父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和最后一个节点。<code>someNode.firstChild</code>始终等于<code>someNode.childNodes[0]</code>,<code>someNode.lastChild</code>始终等于<code>someNode.childNodes[someNode.childNodes.length-1]</code>。如果没有子节点，那么 firstChild 和 lastChild 始终为 null。</li><li>所有节点都有一个 ownerDocument 属性，指向整个文档的文档节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nod.ownerDocument  <span class="comment">//指向 document 节点</span></span><br></pre></td></tr></table></figure><h3 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h3><ul><li>appendChild()向 childNodes 列表末尾插入一个节点，默认返回新增节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnNode = someNode.appendChild(someNode)</span><br><span class="line"><span class="built_in">console</span>.log(returnNode === someNode) <span class="comment">//true  返回值即为插入的节点</span></span><br><span class="line"><span class="built_in">console</span>.log(someNode.lastChild === someNode) <span class="comment">//TRUE 最后一个节点为新插入的节点</span></span><br></pre></td></tr></table></figure><ul><li><p>如果传入到 appendChild()中的节点已经是文档中第一部分了，原位置就没有了这个节点，插入到新位置，相当于做了一次移动。</p></li><li><p>insertBefore()方法可以插入到某个特定位置，接受两个参数，插入的节点和作为参照的节点。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">returnNode = someNode.insertBefore(newNode, <span class="literal">null</span>)</span><br><span class="line">alert (returnNode === someNode.lastChild) <span class="comment">//true  插入成为最后一个节点</span></span><br><span class="line"></span><br><span class="line">returnNode = someNode.insertBefore(newNode, someNode.firstChild)</span><br><span class="line">alert (returnNode === someNode.firstChild) <span class="comment">//true 插入成为第一个节点</span></span><br></pre></td></tr></table></figure><ul><li>replaceChild()方法接受两个参数，插入的节点和要替换的节点，替换。</li><li>removeChild()方法接受一个参数，移除节点。</li><li>cloneNode()方法克隆节点，接受一个布尔值，true 表示深复制，也就是节点和整个子节点树。false 表示只复制节点本身。<strong>需要注意的是，这个节点返回的是复制后的节点，还需要手动方法把它插入到文档树中去。</strong></li><li>normalize()方法处理文档树中的文本节点，如果找到空文本节点就删除它，如果找到相邻的文本节点就合并为一个文本节点。</li></ul><h2 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h2><ul><li>nodeType的值为9，nodeValue 的值为’#document’</li><li>document.domain可以设置。当页面包含来自其他子域的框架和内嵌框架时，能够设置 document.domain 就非常方便。如果两个页面的 document.domain 的值设置为一样，他们就可以进行通信了。如果域名一开始是松散的，那么就不可以在设置成紧绷的了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设页面来自于p2p.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'wrox.com'</span>  <span class="comment">//成功，因为设置成了更松散的</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'p2p.wrox.com'</span> <span class="comment">//失败！因为设置成了更紧绷的域名</span></span><br></pre></td></tr></table></figure><ul><li>查找元素的两个方法：document.getElementById()，document.getElementByTagName()</li><li>第一个只返回第一次出现的元素，第二个返回的类数组对象HTMLCollection，也就是所有标签名一致的元素节点组，注意大小写尽量严格匹配，如果没找到会返回 null。</li><li>document.getElementByTagName()方法返回的类数组对象可以用 nameItem()访问也可以用方括号访问，传入 name 值。星号’*’代表全部。</li></ul><h2 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h2><ul><li>nodeType 的值是1，nodeName 的值为元素标签名，nodeValue 值为 null。</li><li>HTML 中所有标签都为大写，如果不确定是否为 HTML 或者 xml 最好进行标签名转换，toLowerCase()方法。不会出错。推荐做法。</li><li>取得特性：getAttribute(),setAttribute(), removeAttribute()方法。</li><li>setAttribute() 方法接受两个参数，特性名和值。如果特性存在，就会替换掉，如果特性不存在，直接创建并设置。</li><li>使用 document.createElement() 方法可以创建新元素。传入元素的标签名。</li></ul><h2 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h2><ul><li>nodeType 的值为3，nodeName 值为’#text’，nodeValue 值为节点所包含的文本。没有子节点。</li><li>通过 nodeValue 属性或者 data 属性修改文本。</li><li>通过 document.createTextNode()创建文本节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'&lt;strong&gt;Hello&lt;/strong&gt; World!'</span>)</span><br></pre></td></tr></table></figure><ul><li>一般情况下每个元素只有一个文本子节点，但如果我们自行删除或增加文本节点，会出现不是一个文本节点的情况。使用 normalize()方法进行去除空文本或者合并节点的操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.normalize()  <span class="comment">//element 元素的文本节点就会被规范化</span></span><br></pre></td></tr></table></figure><ul><li>Text 类型提供了一个与 normalize()相反的方法：splitText(),会按传入的数字分割 nodeValue 值，变成两个文本节点。原来的文本节点将包含开始到指定位置之前的内容，新文本节点将包含剩下的文本。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">element.className = <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'Hello world!'</span>)</span><br><span class="line">element.appendChild(textNode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>) <span class="comment">//方法返回的是后面的文本</span></span><br><span class="line">alert(element.firstChild.nodeValue)  <span class="comment">//'Hello'</span></span><br><span class="line">alert(newNode.nodeValue)  <span class="comment">//'world!'</span></span><br></pre></td></tr></table></figure><h2 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h2><ul><li>nodeType 的值是8，nodeName 值为’#comment’，nodeValue 是注释的内容，没有子节点。</li><li>Comment 类型和 Text 继承自相同的基类，拥有除了splitText()之外的所有字符串操作方法。也可以通过 nodeValue 和 data 取得内容。注释节点可以通过父节点访问。</li><li>这个节点很少进行操作，因为对算法鲜有影响。</li></ul><h2 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h2><ul><li>DocumentFragment 在文档中没有对应的标记。nodeType 值为11，nodeName 值为’#document-fragment’,nodeValue为 null。</li><li>创建文档片段可以使用 document.createDocumentFragment()方法，通常认为一次性的插入文档片段比多次浏览器渲染性能要高得多，所以如果有多次插入文档流的操作可以使用这个方式。</li></ul><h2 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h2><ul><li>nodeType 的值为2，nodeName 值为特性的名称，nodeValue 值为特性的值。</li><li>实际上，使用 getAttrbute()，setAtrribute(),removeAttribute()方法比操作节点更为方便。</li></ul><h1 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h1><ul><li>对 DOM 的两个主要的扩展是 Selectors API 和 HTML5.</li></ul><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><ul><li>Selectors API Level 1的核心是两个方法: querySelector()和 querySelectorAll().兼容性 IE8+。</li></ul><h3 id="querySelector方法"><a href="#querySelector方法" class="headerlink" title="querySelector方法"></a>querySelector方法</h3><ul><li>querySelector()方法接受一个 CSS 选择符，返回与该模式匹配的第一个元素，没有匹配返回 null。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>) <span class="comment">//获取 body 元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>) <span class="comment">//获取 ID 为 myDiv 的 div 元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">'.selected'</span>) <span class="comment">//获取 class 为 selected 的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">'img.button'</span>) <span class="comment">//获取类为 button 的 第一个 img 元素</span></span><br></pre></td></tr></table></figure><ul><li>通过 Document 类型调用 querySelector()方法时，会在文档元素范围内查找，通过 Element 类型查找时，则在该元素的后代元素范围内查找。</li><li>如果传入了不被支持的选择符，会报错。</li></ul><h3 id="querySelectorAll方法"><a href="#querySelectorAll方法" class="headerlink" title="querySelectorAll方法"></a>querySelectorAll方法</h3><ul><li>同上，返回的是一个 NodeList 实例。</li><li>具体来说，返回值实际上是一个带有所有属性和方法的 nodeList，底层实现列斯雨一组元素的快照，并非对文档进行搜索的动态查询。这样实现可以避免使用 NodeList 对象引起的大多数性能问题。</li><li>传入的 CSS 选择符有效，则返回一个 NodeList 对象，可能为空，如果传入了错误的选择符则抛出错误。</li></ul><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><ul><li>对于元素间的空格，IE9以及之前的版本不会返回文本节点，其他浏览器会返回文本节点。导致了使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一不一致，保持 DOM 规范不变，Element Travelsal规范重新定义了一组属性。</li></ul><table><thead><tr><th style="text-align:center">API</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">childElementCount</td><td style="text-align:center">返回子元素的个数</td></tr><tr><td style="text-align:center">firstElementChild</td><td style="text-align:center">指向第一个子元素,firstChild 的元素版</td></tr><tr><td style="text-align:center">lastElementChild</td><td style="text-align:center">指向最后一个子元素，lastChild 的元素版</td></tr><tr><td style="text-align:center">previousElementSibling</td><td style="text-align:center">前一个同级元素，previousSibling 的元素版</td></tr><tr><td style="text-align:center">nextElementSibling</td><td style="text-align:center">后一个同级元素，nextSiblingde 的元素版</td></tr></tbody></table><ul><li>利用这些元素不必担心空白文本节点，从而方便的查找元素。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = element.firstElementChild   <span class="comment">//元素的第一个子元素</span></span><br><span class="line"><span class="keyword">while</span> (child != element.lastElementChild) &#123;  <span class="comment">//并非最后一个子元素时，处理后，child 指向下一个子元素直至成为最后一个</span></span><br><span class="line">processChild(child)</span><br><span class="line">child = child.nextElementSibling</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h2><h3 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h3><ul><li>可以通过 doucument对象和所有的 HTML 元素进行调用，原生的实现让他具有极大性能优势。</li><li>接受一个参数，一个包含一或多个类名的字符串,返回带有指定类的所有元素的 NodeList。传入类名时，顺序先后不重要。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得所有类名为 username current 的元素，类名顺序无所谓</span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsername = <span class="built_in">document</span>.getElementSByClassName(<span class="string">'username current'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得 ID 为 myDiv 的元素中带有类名selected 的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>).getElementsByClassName(<span class="string">'selected'</span>)</span><br></pre></td></tr></table></figure><ul><li>和其他的选择器方法一样，只有位于调用元素树中的元素才会返回。</li><li>因为返回的对象是 NodeLst，所以使用这个方法与使用getElementsByTagName()以及其他返回 NodeList 的 DOM 方法都有相同的性能问题。</li><li><strong>这里要多说两句，因为在循环中经常使用 i &lt; selected.length 这样的语句，但每一次判断 i 是否小于类数组对象的长度时，都会对 NodeList 对象进行一次访问查询，导致性能下降。如果通过一个变量缓存这个 length，性能可以提升50%左右。所以尽量减少访问属性的次数。</strong></li></ul><h3 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h3><ul><li>所有元素都添加了了 classList 属性，是新集合类型 DOMTokenList 的实例。</li><li>classList 对象有一个表示自己长度的 length 属性，要去的每个元素可以使用 item()方法或者方括号语法。</li></ul><table><thead><tr><th>方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>add(value)</td><td style="text-align:center">将给定的字符串添加到列表中，如果已经存在，就不添加</td></tr><tr><td>contains(value)</td><td style="text-align:center">表示列表中是否存在给定的值，如果存在就不添加</td></tr><tr><td>remove(value)</td><td style="text-align:center">从列表中删除字符串</td></tr><tr><td>toggle(value)</td><td style="text-align:center">类似 jQuery 中的切换类名</td></tr></tbody></table><ul><li>有了 classList 属性，除非需要全部删除所有类名，或者完全重写元素属性，否则也用不到 className 属性了。</li></ul><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><ul><li>document.activeElement 属性,这个属性会引用 DOM 当前获得焦点的元素，获得焦点的方式有页面加载，用户输入，focus()方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)</span><br><span class="line">button.focus()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，文档刚刚加载完成时，activeElement 属性保存的是 document.body 元素的引用。加载期间值为 null。</li><li>另外，document.hasFocus()方法确定文档是否获得了焦点。只要文档加载完成或者其他元素调用了 focus()方法，这个返回值为 true.</li></ul><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><ul><li>HTML5规定可以为元素加载非标准的属性，添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加，随便命名，只要以 data-开头即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">'myDiv'</span> data-appId=<span class="string">'12345'</span> data-myname=<span class="string">'Nicholas'</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>自定义属性可以通过元素的 dataset 属性访问。</li><li>dataset 属性是 DOMStringMap 的一个实例，也就是一个键值对的映射。访问的属性名没有 data-前缀。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId</span><br><span class="line"><span class="keyword">var</span> myName = div.dataset.myname</span><br><span class="line"></span><br><span class="line">div.dataset.appId = <span class="number">23456</span></span><br><span class="line">div.dataset.myname = <span class="string">'Michael'</span></span><br></pre></td></tr></table></figure><ul><li>如果给元素添加一些不可见的数据一遍进行其他处理，在跟踪连接和混搭应用中，自定义属性能方便的知道点击来自哪里。</li></ul><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ul><li>通过 DOM 操作节点相对麻烦，因为不仅要创建，还要按照正确的顺序连接。使用插入标记的技术，直接插入 HTML 字符串更简单，速度也更快。</li></ul><h4 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h4><ul><li>读模式下，innerHTML 属性返回与调用元素的所有子节点（元素，注释，文本节点）对应的 HTML 标记。</li><li>写模式下，innerHTML 会根据指定的值创建新的 DOM 树，新的 DOM 树会完全取代原来的 DOM 节点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="keyword">this</span> is a &lt;strong&gt;paragraph&lt;<span class="regexp">/strong&gt;with a list following it&lt;/</span>p&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/对于上面的div 元素来说，它的 innerHTML 会返回如下字符串</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;this is a &lt;strong&gt;paragraph&lt;/</span>strong&gt;<span class="keyword">with</span> a list following it&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item2&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item3&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><ul><li>尽量注意，在通过 innerHTML 插入代码时，尽量收工检查一下其中的文本内容。</li></ul><h4 id="outerHTML-属性"><a href="#outerHTML-属性" class="headerlink" title="outerHTML 属性"></a>outerHTML 属性</h4><ul><li>基本同上，需要注意的是返回也会包括自身，看下面的例子。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"content"</span>&gt;</span><br><span class="line">  &lt;p&gt;<span class="keyword">this</span> is a &lt;strong&gt;paragraph&lt;<span class="regexp">/strong&gt;with a list following it&lt;/</span>p&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/对于上面的div 元素来说，它的 outerHTML 会返回如下字符串</span></span><br><span class="line"><span class="regexp">&lt;div id='content'&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;this is a &lt;strong&gt;paragraph&lt;/</span>strong&gt;<span class="keyword">with</span> a list following it&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item2&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item3&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><h4 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a>insertAdjacentHTML()方法</h4><ul><li>接受两个参数，插入位置和要插入的 HTML 文本。</li><li>太乱，不写了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'beforebegin'</span>, <span class="string">'&lt;p&gt;helloworld&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure><h4 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h4><ul><li>在使用 innerHTML、outerHTML、insertAdjacentHTML()方法最好收工删除要被替换的元素的所有事件处理程序和 Javascript 对象属性。因为在使用前述某个属性将该元素从文档树中删除后，元素与事件处理程序之间的绑定关系在内存中并没有一并删除。如果这种情况频繁出现，页面占用的内存数量就会明显增加。</li><li>再插入大量新 HTML 标记时，使用 innerHTML 属性与通过多次 DOM 操作先创建节点在指定他们的关系相比，效率高得多。因为设置 innerHTML 时，会创建 HTML 解析器（通常是 C++编写），比执行 js 快得多。</li><li>创建和销毁 HTML 解析器也会带来性能损失，所以最好不要频繁设置 innerHTML 等属性。</li></ul><h4 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView()方法"></a>scrollIntoView()方法</h4><ul><li>scrollIntoView()可以在所有 HTML 元素上调用，给方法传入 true 或者不传参，调用元素的顶部会与视窗顶部尽量平齐，如果传入 false，调用元素会尽量全部出现在视窗中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'#b_fav'</span>)</span><br><span class="line"></span><br><span class="line">div.scrollIntoView() <span class="comment">//滚动至div 出现在视窗页面顶部</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DOM对象&quot;&gt;&lt;a href=&quot;#DOM对象&quot; class=&quot;headerlink&quot; title=&quot;DOM对象&quot;&gt;&lt;/a&gt;DOM对象&lt;/h1&gt;&lt;h2 id=&quot;节点层次&quot;&gt;&lt;a href=&quot;#节点层次&quot; class=&quot;headerlink&quot; title=&quot;节点层次&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
